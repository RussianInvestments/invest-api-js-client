// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v3.19.1
// source: operations.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { InstrumentType, MoneyValue, Ping, PingDelaySettings, Quotation } from "./common";
import { Timestamp } from "./google/protobuf/timestamp";

/** Статус запрашиваемых операций. */
export enum OperationState {
  /** OPERATION_STATE_UNSPECIFIED - Статус операции не определён. */
  OPERATION_STATE_UNSPECIFIED = 0,
  /** OPERATION_STATE_EXECUTED - Исполнена частично или полностью. */
  OPERATION_STATE_EXECUTED = 1,
  /** OPERATION_STATE_CANCELED - Отменена. */
  OPERATION_STATE_CANCELED = 2,
  /** OPERATION_STATE_PROGRESS - Исполняется. */
  OPERATION_STATE_PROGRESS = 3,
  UNRECOGNIZED = -1,
}

/** Тип операции. */
export enum OperationType {
  /** OPERATION_TYPE_UNSPECIFIED - Тип операции не определён. */
  OPERATION_TYPE_UNSPECIFIED = 0,
  /** OPERATION_TYPE_INPUT - Пополнение брокерского счёта. */
  OPERATION_TYPE_INPUT = 1,
  /** OPERATION_TYPE_BOND_TAX - Удержание НДФЛ по купонам. */
  OPERATION_TYPE_BOND_TAX = 2,
  /** OPERATION_TYPE_OUTPUT_SECURITIES - Вывод ЦБ. */
  OPERATION_TYPE_OUTPUT_SECURITIES = 3,
  /** OPERATION_TYPE_OVERNIGHT - Доход по сделке РЕПО овернайт. */
  OPERATION_TYPE_OVERNIGHT = 4,
  /** OPERATION_TYPE_TAX - Удержание налога. */
  OPERATION_TYPE_TAX = 5,
  /** OPERATION_TYPE_BOND_REPAYMENT_FULL - Полное погашение облигаций. */
  OPERATION_TYPE_BOND_REPAYMENT_FULL = 6,
  /** OPERATION_TYPE_SELL_CARD - Продажа ЦБ с карты. */
  OPERATION_TYPE_SELL_CARD = 7,
  /** OPERATION_TYPE_DIVIDEND_TAX - Удержание налога по дивидендам. */
  OPERATION_TYPE_DIVIDEND_TAX = 8,
  /** OPERATION_TYPE_OUTPUT - Вывод денежных средств. */
  OPERATION_TYPE_OUTPUT = 9,
  /** OPERATION_TYPE_BOND_REPAYMENT - Частичное погашение облигаций. */
  OPERATION_TYPE_BOND_REPAYMENT = 10,
  /** OPERATION_TYPE_TAX_CORRECTION - Корректировка налога. */
  OPERATION_TYPE_TAX_CORRECTION = 11,
  /** OPERATION_TYPE_SERVICE_FEE - Удержание комиссии за обслуживание брокерского счёта. */
  OPERATION_TYPE_SERVICE_FEE = 12,
  /** OPERATION_TYPE_BENEFIT_TAX - Удержание налога за материальную выгоду. */
  OPERATION_TYPE_BENEFIT_TAX = 13,
  /** OPERATION_TYPE_MARGIN_FEE - Удержание комиссии за непокрытую позицию. */
  OPERATION_TYPE_MARGIN_FEE = 14,
  /** OPERATION_TYPE_BUY - Покупка ЦБ. */
  OPERATION_TYPE_BUY = 15,
  /** OPERATION_TYPE_BUY_CARD - Покупка ЦБ с карты. */
  OPERATION_TYPE_BUY_CARD = 16,
  /** OPERATION_TYPE_INPUT_SECURITIES - Перевод ценных бумаг из другого депозитария. */
  OPERATION_TYPE_INPUT_SECURITIES = 17,
  /** OPERATION_TYPE_SELL_MARGIN - Продажа в результате Margin-call. */
  OPERATION_TYPE_SELL_MARGIN = 18,
  /** OPERATION_TYPE_BROKER_FEE - Удержание комиссии за операцию. */
  OPERATION_TYPE_BROKER_FEE = 19,
  /** OPERATION_TYPE_BUY_MARGIN - Покупка в результате Margin-call. */
  OPERATION_TYPE_BUY_MARGIN = 20,
  /** OPERATION_TYPE_DIVIDEND - Выплата дивидендов. */
  OPERATION_TYPE_DIVIDEND = 21,
  /** OPERATION_TYPE_SELL - Продажа ЦБ. */
  OPERATION_TYPE_SELL = 22,
  /** OPERATION_TYPE_COUPON - Выплата купонов. */
  OPERATION_TYPE_COUPON = 23,
  /** OPERATION_TYPE_SUCCESS_FEE - Удержание комиссии SuccessFee. */
  OPERATION_TYPE_SUCCESS_FEE = 24,
  /** OPERATION_TYPE_DIVIDEND_TRANSFER - Передача дивидендного дохода. */
  OPERATION_TYPE_DIVIDEND_TRANSFER = 25,
  /** OPERATION_TYPE_ACCRUING_VARMARGIN - Зачисление вариационной маржи. */
  OPERATION_TYPE_ACCRUING_VARMARGIN = 26,
  /** OPERATION_TYPE_WRITING_OFF_VARMARGIN - Списание вариационной маржи. */
  OPERATION_TYPE_WRITING_OFF_VARMARGIN = 27,
  /** OPERATION_TYPE_DELIVERY_BUY - Покупка в рамках экспирации фьючерсного контракта. */
  OPERATION_TYPE_DELIVERY_BUY = 28,
  /** OPERATION_TYPE_DELIVERY_SELL - Продажа в рамках экспирации фьючерсного контракта. */
  OPERATION_TYPE_DELIVERY_SELL = 29,
  /** OPERATION_TYPE_TRACK_MFEE - Комиссия за управление по счёту автоследования. */
  OPERATION_TYPE_TRACK_MFEE = 30,
  /** OPERATION_TYPE_TRACK_PFEE - Комиссия за результат по счёту автоследования. */
  OPERATION_TYPE_TRACK_PFEE = 31,
  /** OPERATION_TYPE_TAX_PROGRESSIVE - Удержание налога по ставке 15%. */
  OPERATION_TYPE_TAX_PROGRESSIVE = 32,
  /** OPERATION_TYPE_BOND_TAX_PROGRESSIVE - Удержание налога по купонам по ставке 15%. */
  OPERATION_TYPE_BOND_TAX_PROGRESSIVE = 33,
  /** OPERATION_TYPE_DIVIDEND_TAX_PROGRESSIVE - Удержание налога по дивидендам по ставке 15%. */
  OPERATION_TYPE_DIVIDEND_TAX_PROGRESSIVE = 34,
  /** OPERATION_TYPE_BENEFIT_TAX_PROGRESSIVE - Удержание налога за материальную выгоду по ставке 15%. */
  OPERATION_TYPE_BENEFIT_TAX_PROGRESSIVE = 35,
  /** OPERATION_TYPE_TAX_CORRECTION_PROGRESSIVE - Корректировка налога по ставке 15%. */
  OPERATION_TYPE_TAX_CORRECTION_PROGRESSIVE = 36,
  /** OPERATION_TYPE_TAX_REPO_PROGRESSIVE - Удержание налога за возмещение по сделкам РЕПО по ставке 15%. */
  OPERATION_TYPE_TAX_REPO_PROGRESSIVE = 37,
  /** OPERATION_TYPE_TAX_REPO - Удержание налога за возмещение по сделкам РЕПО. */
  OPERATION_TYPE_TAX_REPO = 38,
  /** OPERATION_TYPE_TAX_REPO_HOLD - Удержание налога по сделкам РЕПО. */
  OPERATION_TYPE_TAX_REPO_HOLD = 39,
  /** OPERATION_TYPE_TAX_REPO_REFUND - Возврат налога по сделкам РЕПО. */
  OPERATION_TYPE_TAX_REPO_REFUND = 40,
  /** OPERATION_TYPE_TAX_REPO_HOLD_PROGRESSIVE - Удержание налога по сделкам РЕПО по ставке 15%. */
  OPERATION_TYPE_TAX_REPO_HOLD_PROGRESSIVE = 41,
  /** OPERATION_TYPE_TAX_REPO_REFUND_PROGRESSIVE - Возврат налога по сделкам РЕПО по ставке 15%. */
  OPERATION_TYPE_TAX_REPO_REFUND_PROGRESSIVE = 42,
  /** OPERATION_TYPE_DIV_EXT - Выплата дивидендов на карту. */
  OPERATION_TYPE_DIV_EXT = 43,
  /** OPERATION_TYPE_TAX_CORRECTION_COUPON - Корректировка налога по купонам. */
  OPERATION_TYPE_TAX_CORRECTION_COUPON = 44,
  /** OPERATION_TYPE_CASH_FEE - Комиссия за валютный остаток. */
  OPERATION_TYPE_CASH_FEE = 45,
  /** OPERATION_TYPE_OUT_FEE - Комиссия за вывод валюты с брокерского счёта. */
  OPERATION_TYPE_OUT_FEE = 46,
  /** OPERATION_TYPE_OUT_STAMP_DUTY - Гербовый сбор. */
  OPERATION_TYPE_OUT_STAMP_DUTY = 47,
  /** OPERATION_TYPE_OUTPUT_SWIFT - SWIFT-перевод. */
  OPERATION_TYPE_OUTPUT_SWIFT = 50,
  /** OPERATION_TYPE_INPUT_SWIFT - SWIFT-перевод. */
  OPERATION_TYPE_INPUT_SWIFT = 51,
  /** OPERATION_TYPE_OUTPUT_ACQUIRING - Перевод на карту. */
  OPERATION_TYPE_OUTPUT_ACQUIRING = 53,
  /** OPERATION_TYPE_INPUT_ACQUIRING - Перевод с карты. */
  OPERATION_TYPE_INPUT_ACQUIRING = 54,
  /** OPERATION_TYPE_OUTPUT_PENALTY - Комиссия за вывод средств. */
  OPERATION_TYPE_OUTPUT_PENALTY = 55,
  /** OPERATION_TYPE_ADVICE_FEE - Списание оплаты за сервис Советов. */
  OPERATION_TYPE_ADVICE_FEE = 56,
  /** OPERATION_TYPE_TRANS_IIS_BS - Перевод ценных бумаг с ИИС на брокерский счёт. */
  OPERATION_TYPE_TRANS_IIS_BS = 57,
  /** OPERATION_TYPE_TRANS_BS_BS - Перевод ценных бумаг с одного брокерского счёта на другой. */
  OPERATION_TYPE_TRANS_BS_BS = 58,
  /** OPERATION_TYPE_OUT_MULTI - Вывод денежных средств со счёта. */
  OPERATION_TYPE_OUT_MULTI = 59,
  /** OPERATION_TYPE_INP_MULTI - Пополнение денежных средств со счёта. */
  OPERATION_TYPE_INP_MULTI = 60,
  /** OPERATION_TYPE_OVER_PLACEMENT - Размещение биржевого овернайта. */
  OPERATION_TYPE_OVER_PLACEMENT = 61,
  /** OPERATION_TYPE_OVER_COM - Списание комиссии. */
  OPERATION_TYPE_OVER_COM = 62,
  /** OPERATION_TYPE_OVER_INCOME - Доход от оверанайта. */
  OPERATION_TYPE_OVER_INCOME = 63,
  /** OPERATION_TYPE_OPTION_EXPIRATION - Экспирация опциона. */
  OPERATION_TYPE_OPTION_EXPIRATION = 64,
  /** OPERATION_TYPE_FUTURE_EXPIRATION - Экспирация фьючерса. */
  OPERATION_TYPE_FUTURE_EXPIRATION = 65,
  UNRECOGNIZED = -1,
}

/** Результат подписки. */
export enum PortfolioSubscriptionStatus {
  /** PORTFOLIO_SUBSCRIPTION_STATUS_UNSPECIFIED - Тип не определён. */
  PORTFOLIO_SUBSCRIPTION_STATUS_UNSPECIFIED = 0,
  /** PORTFOLIO_SUBSCRIPTION_STATUS_SUCCESS - Успешно. */
  PORTFOLIO_SUBSCRIPTION_STATUS_SUCCESS = 1,
  /** PORTFOLIO_SUBSCRIPTION_STATUS_ACCOUNT_NOT_FOUND - Счёт не найден или недостаточно прав. */
  PORTFOLIO_SUBSCRIPTION_STATUS_ACCOUNT_NOT_FOUND = 2,
  /** PORTFOLIO_SUBSCRIPTION_STATUS_INTERNAL_ERROR - Произошла ошибка. */
  PORTFOLIO_SUBSCRIPTION_STATUS_INTERNAL_ERROR = 3,
  UNRECOGNIZED = -1,
}

/** Результат подписки. */
export enum PositionsAccountSubscriptionStatus {
  /** POSITIONS_SUBSCRIPTION_STATUS_UNSPECIFIED - Тип не определён. */
  POSITIONS_SUBSCRIPTION_STATUS_UNSPECIFIED = 0,
  /** POSITIONS_SUBSCRIPTION_STATUS_SUCCESS - Успешно. */
  POSITIONS_SUBSCRIPTION_STATUS_SUCCESS = 1,
  /** POSITIONS_SUBSCRIPTION_STATUS_ACCOUNT_NOT_FOUND - Счёт не найден или недостаточно прав. */
  POSITIONS_SUBSCRIPTION_STATUS_ACCOUNT_NOT_FOUND = 2,
  /** POSITIONS_SUBSCRIPTION_STATUS_INTERNAL_ERROR - Произошла ошибка. */
  POSITIONS_SUBSCRIPTION_STATUS_INTERNAL_ERROR = 3,
  UNRECOGNIZED = -1,
}

/** Запрос получения списка операций по счёту. */
export interface OperationsRequest {
  /** Идентификатор счёта клиента. */
  accountId: string;
  /** Начало периода по UTC. */
  from?:
    | Date
    | undefined;
  /** Окончание периода по UTC. */
  to?:
    | Date
    | undefined;
  /** Статус запрашиваемых операций. */
  state?:
    | OperationState
    | undefined;
  /** FIGI-идентификатор инструмента для фильтрации. */
  figi?: string | undefined;
}

/** Список операций. */
export interface OperationsResponse {
  /** Массив операций. */
  operations: Operation[];
}

/** Данные по операции. */
export interface Operation {
  /** Идентификатор операции. */
  id: string;
  /** Идентификатор родительской операции. */
  parentOperationId: string;
  /** Валюта операции. */
  currency: string;
  /** Сумма операции. */
  payment:
    | MoneyValue
    | undefined;
  /** Цена операции за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. */
  price:
    | MoneyValue
    | undefined;
  /** Статус операции. */
  state: OperationState;
  /** Количество единиц инструмента. */
  quantity: number;
  /** Неисполненный остаток по сделке. */
  quantityRest: number;
  /** FIGI-идентификатор инструмента, связанного с операцией. */
  figi: string;
  /** Тип инструмента. Возможные значения: </br></br>`bond` — облигация; </br>`share` — акция; </br>`currency` — валюта; </br>`etf` — фонд; </br>`futures` — фьючерс. */
  instrumentType: string;
  /** Дата и время операции в формате часовом поясе UTC. */
  date:
    | Date
    | undefined;
  /** Текстовое описание типа операции. */
  type: string;
  /** Тип операции. */
  operationType: OperationType;
  /** Массив сделок. */
  trades: OperationTrade[];
  /** Идентификатор актива */
  assetUid: string;
  /** Уникальный идентификатор позиции. */
  positionUid: string;
  /** Уникальный идентификатор инструмента. */
  instrumentUid: string;
  /** Массив дочерних операций. */
  childOperations: ChildOperationItem[];
}

/** Сделка по операции. */
export interface OperationTrade {
  /** Идентификатор сделки. */
  tradeId: string;
  /** Дата и время сделки по UTC. */
  dateTime:
    | Date
    | undefined;
  /** Количество инструментов. */
  quantity: number;
  /** Цена за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. */
  price: MoneyValue | undefined;
}

/** Запрос получения текущего портфеля по счёту. */
export interface PortfolioRequest {
  /** Идентификатор счёта пользователя. */
  accountId: string;
  /** Валюта, в которой нужно рассчитать портфель. */
  currency?: PortfolioRequest_CurrencyRequest | undefined;
}

export enum PortfolioRequest_CurrencyRequest {
  /** RUB - Рубли */
  RUB = 0,
  /** USD - Доллары */
  USD = 1,
  /** EUR - Евро */
  EUR = 2,
  UNRECOGNIZED = -1,
}

/** Текущий портфель по счёту. */
export interface PortfolioResponse {
  /** Общая стоимость акций в портфеле. */
  totalAmountShares:
    | MoneyValue
    | undefined;
  /** Общая стоимость облигаций в портфеле. */
  totalAmountBonds:
    | MoneyValue
    | undefined;
  /** Общая стоимость фондов в портфеле. */
  totalAmountEtf:
    | MoneyValue
    | undefined;
  /** Общая стоимость валют в портфеле. */
  totalAmountCurrencies:
    | MoneyValue
    | undefined;
  /** Общая стоимость фьючерсов в портфеле. */
  totalAmountFutures:
    | MoneyValue
    | undefined;
  /** Текущая относительная доходность портфеля в %. */
  expectedYield:
    | Quotation
    | undefined;
  /** Список позиций портфеля. */
  positions: PortfolioPosition[];
  /** Идентификатор счёта пользователя. */
  accountId: string;
  /** Общая стоимость опционов в портфеле. */
  totalAmountOptions:
    | MoneyValue
    | undefined;
  /** Общая стоимость структурных нот в портфеле. */
  totalAmountSp:
    | MoneyValue
    | undefined;
  /** Общая стоимость портфеля. */
  totalAmountPortfolio:
    | MoneyValue
    | undefined;
  /** Массив виртуальных позиций портфеля. */
  virtualPositions: VirtualPortfolioPosition[];
  /** Рассчитанная доходность портфеля за день в рублях */
  dailyYield:
    | MoneyValue
    | undefined;
  /** Относительная доходность в день в % */
  dailyYieldRelative: Quotation | undefined;
}

/** Запрос позиций портфеля по счёту. */
export interface PositionsRequest {
  /** Идентификатор счёта пользователя. */
  accountId: string;
}

/** Список позиций по счёту. */
export interface PositionsResponse {
  /** Массив валютных позиций портфеля. */
  money: MoneyValue[];
  /** Массив заблокированных валютных позиций портфеля. */
  blocked: MoneyValue[];
  /** Список ценно-бумажных позиций портфеля. */
  securities: PositionsSecurities[];
  /** Признак идущей выгрузки лимитов в данный момент. */
  limitsLoadingInProgress: boolean;
  /** Список фьючерсов портфеля. */
  futures: PositionsFutures[];
  /** Список опционов портфеля. */
  options: PositionsOptions[];
  /** Идентификатор счёта пользователя. */
  accountId: string;
}

/** Запрос доступного остатка для вывода. */
export interface WithdrawLimitsRequest {
  /** Идентификатор счёта пользователя. */
  accountId: string;
}

/** Доступный остаток для вывода. */
export interface WithdrawLimitsResponse {
  /** Массив валютных позиций портфеля. */
  money: MoneyValue[];
  /** Массив заблокированных валютных позиций портфеля. */
  blocked: MoneyValue[];
  /** Заблокировано под гарантийное обеспечение фьючерсов. */
  blockedGuarantee: MoneyValue[];
}

/** Позиции портфеля. */
export interface PortfolioPosition {
  /** FIGI-идентификатор инструмента. */
  figi: string;
  /** Тип инструмента. */
  instrumentType: string;
  /** Количество инструмента в портфеле в штуках. */
  quantity:
    | Quotation
    | undefined;
  /** Средневзвешенная цена позиции. Для пересчёта возможна задержка до одной секунды. */
  averagePositionPrice:
    | MoneyValue
    | undefined;
  /** Текущая рассчитанная доходность позиции. */
  expectedYield:
    | Quotation
    | undefined;
  /** Текущий НКД. */
  currentNkd:
    | MoneyValue
    | undefined;
  /**
   * Deprecated Средняя цена позиции в пунктах (для фьючерсов). Для пересчёта возможна задержка до одной секунды.
   *
   * @deprecated
   */
  averagePositionPricePt:
    | Quotation
    | undefined;
  /** Текущая цена за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. */
  currentPrice:
    | MoneyValue
    | undefined;
  /** Средняя цена позиции по методу FIFO. Для пересчёта возможна задержка до одной секунды. */
  averagePositionPriceFifo:
    | MoneyValue
    | undefined;
  /**
   * Deprecated Количество лотов в портфеле.
   *
   * @deprecated
   */
  quantityLots:
    | Quotation
    | undefined;
  /** Заблокировано на бирже. */
  blocked: boolean;
  /** Количество бумаг, заблокированных выставленными заявками. */
  blockedLots:
    | Quotation
    | undefined;
  /** Уникальный идентификатор позиции. */
  positionUid: string;
  /** Уникальный идентификатор инструмента. */
  instrumentUid: string;
  /** Вариационная маржа. */
  varMargin:
    | MoneyValue
    | undefined;
  /** Текущая рассчитанная доходность позиции. */
  expectedYieldFifo:
    | Quotation
    | undefined;
  /** Рассчитанная доходность портфеля за день */
  dailyYield: MoneyValue | undefined;
}

export interface VirtualPortfolioPosition {
  /** Уникальный идентификатор позиции. */
  positionUid: string;
  /** Уникальный идентификатор инструмента. */
  instrumentUid: string;
  /** FIGI-идентификатор инструмента. */
  figi: string;
  /** Тип инструмента. */
  instrumentType: string;
  /** Количество инструмента в портфеле в штуках. */
  quantity:
    | Quotation
    | undefined;
  /** Средневзвешенная цена позиции. Для пересчёта возможна задержка до одной секунды. */
  averagePositionPrice:
    | MoneyValue
    | undefined;
  /** Текущая рассчитанная доходность позиции. */
  expectedYield:
    | Quotation
    | undefined;
  /** Текущая рассчитанная доходность позиции. */
  expectedYieldFifo:
    | Quotation
    | undefined;
  /** Дата, до которой нужно продать виртуальные бумаги. После этой даты виртуальная позиция «сгораетт». */
  expireDate:
    | Date
    | undefined;
  /** Текущая цена за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. */
  currentPrice:
    | MoneyValue
    | undefined;
  /** Средняя цена позиции по методу FIFO. Для пересчёта возможна задержка до одной секунды. */
  averagePositionPriceFifo:
    | MoneyValue
    | undefined;
  /** Рассчитанная доходность портфеля за день */
  dailyYield: MoneyValue | undefined;
}

/** Баланс позиции ценной бумаги. */
export interface PositionsSecurities {
  /** FIGI-идентификатор бумаги. */
  figi: string;
  /** Количество бумаг, заблокированных выставленными заявками. */
  blocked: number;
  /** Текущий незаблокированный баланс. */
  balance: number;
  /** Уникальный идентификатор позиции. */
  positionUid: string;
  /** Уникальный идентификатор инструмента. */
  instrumentUid: string;
  /** Заблокировано на бирже. */
  exchangeBlocked: boolean;
  /** Тип инструмента. */
  instrumentType: string;
}

/** Баланс фьючерса. */
export interface PositionsFutures {
  /** FIGI-идентификатор фьючерса. */
  figi: string;
  /** Количество бумаг, заблокированных выставленными заявками. */
  blocked: number;
  /** Текущий незаблокированный баланс. */
  balance: number;
  /** Уникальный идентификатор позиции. */
  positionUid: string;
  /** Уникальный идентификатор  инструмента. */
  instrumentUid: string;
}

/** Баланс опциона. */
export interface PositionsOptions {
  /** Уникальный идентификатор позиции опциона. */
  positionUid: string;
  /** Уникальный идентификатор  инструмента. */
  instrumentUid: string;
  /** Количество бумаг, заблокированных выставленными заявками. */
  blocked: number;
  /** Текущий незаблокированный баланс. */
  balance: number;
}

export interface BrokerReportRequest {
  generateBrokerReportRequest?: GenerateBrokerReportRequest | undefined;
  getBrokerReportRequest?: GetBrokerReportRequest | undefined;
}

export interface BrokerReportResponse {
  generateBrokerReportResponse?: GenerateBrokerReportResponse | undefined;
  getBrokerReportResponse?: GetBrokerReportResponse | undefined;
}

export interface GenerateBrokerReportRequest {
  /** Идентификатор счёта клиента. */
  accountId: string;
  /** Начало периода по UTC. */
  from:
    | Date
    | undefined;
  /** Окончание периода по UTC. */
  to: Date | undefined;
}

export interface GenerateBrokerReportResponse {
  /** Идентификатор задачи формирования брокерского отчёта. */
  taskId: string;
}

export interface GetBrokerReportRequest {
  /** Идентификатор задачи формирования брокерского отчёта. */
  taskId: string;
  /** Номер страницы отчёта, начинается с 1. Значение по умолчанию — 0. */
  page?: number | undefined;
}

export interface GetBrokerReportResponse {
  brokerReport: BrokerReport[];
  /** Количество записей в отчёте. */
  itemsCount: number;
  /** Количество страниц с данными отчёта, начинается с 0. */
  pagesCount: number;
  /** Текущая страница, начинается с 0. */
  page: number;
}

export interface BrokerReport {
  /** Номер сделки. */
  tradeId: string;
  /** Номер поручения. */
  orderId: string;
  /** FIGI-идентификаторинструмента. */
  figi: string;
  /** Признак исполнения. */
  executeSign: string;
  /** Дата и время заключения по UTC. */
  tradeDatetime:
    | Date
    | undefined;
  /** Торговая площадка. */
  exchange: string;
  /** Режим торгов. */
  classCode: string;
  /** Вид сделки. */
  direction: string;
  /** Сокращённое наименование актива. */
  name: string;
  /** Код актива. */
  ticker: string;
  /** Цена за единицу. */
  price:
    | MoneyValue
    | undefined;
  /** Количество. */
  quantity: number;
  /** Сумма без НКД. */
  orderAmount:
    | MoneyValue
    | undefined;
  /** НКД. */
  aciValue:
    | Quotation
    | undefined;
  /** Сумма сделки. */
  totalOrderAmount:
    | MoneyValue
    | undefined;
  /** Комиссия брокера. */
  brokerCommission:
    | MoneyValue
    | undefined;
  /** Комиссия биржи. */
  exchangeCommission:
    | MoneyValue
    | undefined;
  /** Комиссия клирингового центра. */
  exchangeClearingCommission:
    | MoneyValue
    | undefined;
  /** Ставка РЕПО, %. */
  repoRate:
    | Quotation
    | undefined;
  /** Контрагент или брокерарокер. */
  party: string;
  /** Дата расчётов по UTC. */
  clearValueDate:
    | Date
    | undefined;
  /** Дата поставки по UTC. */
  secValueDate:
    | Date
    | undefined;
  /** Статус брокера. */
  brokerStatus: string;
  /** Тип договора. */
  separateAgreementType: string;
  /** Номер договора. */
  separateAgreementNumber: string;
  /** Дата договора. */
  separateAgreementDate: string;
  /** Тип расчёта по сделке. */
  deliveryType: string;
}

export interface GetDividendsForeignIssuerRequest {
  /** Объект запроса формирования отчёта. */
  generateDivForeignIssuerReport?:
    | GenerateDividendsForeignIssuerReportRequest
    | undefined;
  /** Объект запроса сформированного отчёта. */
  getDivForeignIssuerReport?: GetDividendsForeignIssuerReportRequest | undefined;
}

export interface GetDividendsForeignIssuerResponse {
  /** Объект результата задачи запуска формирования отчёта. */
  generateDivForeignIssuerReportResponse?:
    | GenerateDividendsForeignIssuerReportResponse
    | undefined;
  /** Отчёт «Справка о доходах за пределами РФ». */
  divForeignIssuerReport?: GetDividendsForeignIssuerReportResponse | undefined;
}

/** Объект запроса формирования отчёта «Справка о доходах за пределами РФ». */
export interface GenerateDividendsForeignIssuerReportRequest {
  /** Идентификатор счёта клиента. */
  accountId: string;
  /** Начало периода по UTC. */
  from:
    | Date
    | undefined;
  /** Окончание периода по UTC. Как правило, можно сформировать отчёт по дату на несколько дней меньше текущей. Начало и окончание периода должны быть в рамках одного календарного года. */
  to: Date | undefined;
}

/** Объект запроса сформированного отчёта «Справка о доходах за пределами РФ». */
export interface GetDividendsForeignIssuerReportRequest {
  /** Идентификатор задачи формирования отчёта. */
  taskId: string;
  /** Номер страницы отчета (начинается с 0), значение по умолчанию: 0. */
  page?: number | undefined;
}

/** Объект результата задачи запуска формирования отчёта «Справка о доходах за пределами РФ». */
export interface GenerateDividendsForeignIssuerReportResponse {
  /** Идентификатор задачи формирования отчёта. */
  taskId: string;
}

export interface GetDividendsForeignIssuerReportResponse {
  dividendsForeignIssuerReport: DividendsForeignIssuerReport[];
  /** Количество записей в отчёте. */
  itemsCount: number;
  /** Количество страниц с данными отчёта, начинается с 0. */
  pagesCount: number;
  /** Текущая страница, начинается с 0. */
  page: number;
}

/** Отчёт «Справка о доходах за пределами РФ». */
export interface DividendsForeignIssuerReport {
  /** Дата фиксации реестра. */
  recordDate:
    | Date
    | undefined;
  /** Дата выплаты. */
  paymentDate:
    | Date
    | undefined;
  /** Наименование ценной бумаги. */
  securityName: string;
  /** ISIN-идентификатор ценной бумаги. */
  isin: string;
  /** Страна эмитента. Для депозитарных расписок указывается страна эмитента базового актива. */
  issuerCountry: string;
  /** Количество ценных бумаг. */
  quantity: number;
  /** Выплаты на одну бумагу */
  dividend:
    | Quotation
    | undefined;
  /** Комиссия внешних платёжных агентов. */
  externalCommission:
    | Quotation
    | undefined;
  /** Сумма до удержания налога. */
  dividendGross:
    | Quotation
    | undefined;
  /** Сумма налога, удержанного агентом. */
  tax:
    | Quotation
    | undefined;
  /** Итоговая сумма выплаты. */
  dividendAmount:
    | Quotation
    | undefined;
  /** Валюта. */
  currency: string;
}

/** Запрос установки stream-соединения. */
export interface PortfolioStreamRequest {
  /** Массив идентификаторов счётов пользователя. */
  accounts: string[];
  /** Запрос настройки пинга. */
  pingSettings: PingDelaySettings | undefined;
}

/** Информация по позициям и доходностям портфелей. */
export interface PortfolioStreamResponse {
  /** Объект результата подписки. */
  subscriptions?:
    | PortfolioSubscriptionResult
    | undefined;
  /** Объект стриминга портфеля. */
  portfolio?:
    | PortfolioResponse
    | undefined;
  /** Проверка активности стрима. */
  ping?: Ping | undefined;
}

/** Объект результата подписки. */
export interface PortfolioSubscriptionResult {
  /** Массив счетов клиента. */
  accounts: AccountSubscriptionStatus[];
  /** Уникальный идентификатор запроса, подробнее: [tracking_id](https://russianinvestments.github.io/investAPI/grpc#tracking-id). */
  trackingId: string;
  /** Идентификатор открытого соединения */
  streamId: string;
}

/** Счёт клиента. */
export interface AccountSubscriptionStatus {
  /** Идентификатор счёта. */
  accountId: string;
  /** Результат подписки. */
  subscriptionStatus: PortfolioSubscriptionStatus;
}

/** Запрос списка операций по счёту с пагинацией. */
export interface GetOperationsByCursorRequest {
  /** Идентификатор счёта клиента, обязательный параметр. Остальные параметры опциональны. */
  accountId: string;
  /** Идентификатор инструмента — FIGI или UID инструмента. */
  instrumentId?:
    | string
    | undefined;
  /** Начало периода по UTC. */
  from?:
    | Date
    | undefined;
  /** Окончание периода по UTC. */
  to?:
    | Date
    | undefined;
  /** Идентификатор элемента, с которого начать формировать ответ. */
  cursor?:
    | string
    | undefined;
  /** Лимит количества операций. По умолчанию — `100`, максимальное значение — `1000`. */
  limit?:
    | number
    | undefined;
  /** Тип операции. Принимает значение из списка `OperationType`. */
  operationTypes: OperationType[];
  /** Статус запрашиваемых операций. Возможные значения указаны в `OperationState`. */
  state?:
    | OperationState
    | undefined;
  /** Флаг возврата комиссии. По умолчанию — `false`. */
  withoutCommissions?:
    | boolean
    | undefined;
  /** Флаг получения ответа без массива сделок. */
  withoutTrades?:
    | boolean
    | undefined;
  /** Флаг показа overnight операций. */
  withoutOvernights?: boolean | undefined;
}

/** Список операций по счёту с пагинацией. */
export interface GetOperationsByCursorResponse {
  /** Признак, есть ли следующий элемент. */
  hasNext: boolean;
  /** Следующий курсор. */
  nextCursor: string;
  /** Список операций. */
  items: OperationItem[];
}

/** Данные об операции. */
export interface OperationItem {
  /** Курсор. */
  cursor: string;
  /** Номер счёта клиента. */
  brokerAccountId: string;
  /** Идентификатор операции, может меняться с течением времени. */
  id: string;
  /** Идентификатор родительской операции. Может измениться, если изменился ID родительской операции. */
  parentOperationId: string;
  /** Название операции. */
  name: string;
  /** Дата поручения. */
  date:
    | Date
    | undefined;
  /** Тип операции. */
  type: OperationType;
  /** Описание операции. */
  description: string;
  /** Статус поручения. */
  state: OperationState;
  /** Уникальный идентификатор инструмента. */
  instrumentUid: string;
  /** FIGI. */
  figi: string;
  /** Тип инструмента. */
  instrumentType: string;
  /** Тип инструмента. */
  instrumentKind: InstrumentType;
  /** Уникальный идентификатор позиции. */
  positionUid: string;
  /** Сумма операции. */
  payment:
    | MoneyValue
    | undefined;
  /** Цена операции за 1 инструмент. */
  price:
    | MoneyValue
    | undefined;
  /** Комиссия. */
  commission:
    | MoneyValue
    | undefined;
  /** Доходность. */
  yield:
    | MoneyValue
    | undefined;
  /** Относительная доходность. */
  yieldRelative:
    | Quotation
    | undefined;
  /** Накопленный купонный доход. */
  accruedInt:
    | MoneyValue
    | undefined;
  /** Количество единиц инструмента. */
  quantity: number;
  /** Неисполненный остаток по сделке. */
  quantityRest: number;
  /** Исполненный остаток. */
  quantityDone: number;
  /** Дата и время снятия заявки. */
  cancelDateTime:
    | Date
    | undefined;
  /** Причина отмены операции. */
  cancelReason: string;
  /** Массив сделок. */
  tradesInfo:
    | OperationItemTrades
    | undefined;
  /** Идентификатор актива. */
  assetUid: string;
  /** Массив дочерних операций. */
  childOperations: ChildOperationItem[];
}

/** Массив с информацией о сделках. */
export interface OperationItemTrades {
  trades: OperationItemTrade[];
}

/** Сделка по операции. */
export interface OperationItemTrade {
  /** Номер сделки. */
  num: string;
  /** Дата сделки. */
  date:
    | Date
    | undefined;
  /** Количество в единицах. */
  quantity: number;
  /** Цена. */
  price:
    | MoneyValue
    | undefined;
  /** Доходность. */
  yield:
    | MoneyValue
    | undefined;
  /** Относительная доходность. */
  yieldRelative: Quotation | undefined;
}

/** Запрос установки stream-соединения позиций. */
export interface PositionsStreamRequest {
  /** Массив идентификаторов счётов пользователя. */
  accounts: string[];
  /** Получение состояния позиций на момент подключения. */
  withInitialPositions: boolean;
  /** Запрос настройки пинга. */
  pingSettings: PingDelaySettings | undefined;
}

/** Информация по изменению позиций портфеля. */
export interface PositionsStreamResponse {
  /** Объект результата подписки. */
  subscriptions?:
    | PositionsSubscriptionResult
    | undefined;
  /** Объект стриминга позиций. */
  position?:
    | PositionData
    | undefined;
  /** Проверка активности стрима. */
  ping?:
    | Ping
    | undefined;
  /** Текущие позиции. */
  initialPositions?: PositionsResponse | undefined;
}

/** Объект результата подписки. */
export interface PositionsSubscriptionResult {
  /** Массив счетов клиента. */
  accounts: PositionsSubscriptionStatus[];
  /** Уникальный идентификатор запроса, подробнее: [tracking_id](https://russianinvestments.github.io/investAPI/grpc#tracking-id). */
  trackingId: string;
  /** Идентификатор открытого соединения */
  streamId: string;
}

/** Счёт клиента. */
export interface PositionsSubscriptionStatus {
  /** Идентификатор счёта. */
  accountId: string;
  /** Результат подписки. */
  subscriptionStatus: PositionsAccountSubscriptionStatus;
}

/** Данные о позиции портфеля. */
export interface PositionData {
  /** Идентификатор счёта. */
  accountId: string;
  /** Массив валютных позиций портфеля. */
  money: PositionsMoney[];
  /** Список ценно-бумажных позиций портфеля. */
  securities: PositionsSecurities[];
  /** Список фьючерсов портфеля. */
  futures: PositionsFutures[];
  /** Список опционов портфеля. */
  options: PositionsOptions[];
  /** Дата и время операции в формате UTC. */
  date: Date | undefined;
}

/** Валютная позиция портфеля. */
export interface PositionsMoney {
  /** Доступное количество валютный позиций. */
  availableValue:
    | MoneyValue
    | undefined;
  /** Заблокированное количество валютных позиций. */
  blockedValue: MoneyValue | undefined;
}

export interface ChildOperationItem {
  /** Уникальный идентификатор инструмента. */
  instrumentUid: string;
  /** Сумма операции. */
  payment: MoneyValue | undefined;
}

function createBaseOperationsRequest(): OperationsRequest {
  return { accountId: "", from: undefined, to: undefined, state: undefined, figi: undefined };
}

export const OperationsRequest: OperationsUtils.MessageFns<OperationsRequest> = {
  encode(message: OperationsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== "") {
      writer.uint32(10).string(message.accountId);
    }
    if (message.from !== undefined) {
      Timestamp.encode(toTimestamp(message.from), writer.uint32(18).fork()).join();
    }
    if (message.to !== undefined) {
      Timestamp.encode(toTimestamp(message.to), writer.uint32(26).fork()).join();
    }
    if (message.state !== undefined) {
      writer.uint32(32).int32(message.state);
    }
    if (message.figi !== undefined) {
      writer.uint32(42).string(message.figi);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperationsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.from = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.to = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.figi = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<OperationsRequest>): OperationsRequest {
    return OperationsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OperationsRequest>): OperationsRequest {
    const message = createBaseOperationsRequest();
    message.accountId = object.accountId ?? "";
    message.from = object.from ?? undefined;
    message.to = object.to ?? undefined;
    message.state = object.state ?? undefined;
    message.figi = object.figi ?? undefined;
    return message;
  },
};

function createBaseOperationsResponse(): OperationsResponse {
  return { operations: [] };
}

export const OperationsResponse: OperationsUtils.MessageFns<OperationsResponse> = {
  encode(message: OperationsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.operations) {
      Operation.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperationsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.operations.push(Operation.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<OperationsResponse>): OperationsResponse {
    return OperationsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OperationsResponse>): OperationsResponse {
    const message = createBaseOperationsResponse();
    message.operations = object.operations?.map((e) => Operation.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOperation(): Operation {
  return {
    id: "",
    parentOperationId: "",
    currency: "",
    payment: undefined,
    price: undefined,
    state: 0,
    quantity: 0,
    quantityRest: 0,
    figi: "",
    instrumentType: "",
    date: undefined,
    type: "",
    operationType: 0,
    trades: [],
    assetUid: "",
    positionUid: "",
    instrumentUid: "",
    childOperations: [],
  };
}

export const Operation: OperationsUtils.MessageFns<Operation> = {
  encode(message: Operation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.parentOperationId !== "") {
      writer.uint32(18).string(message.parentOperationId);
    }
    if (message.currency !== "") {
      writer.uint32(26).string(message.currency);
    }
    if (message.payment !== undefined) {
      MoneyValue.encode(message.payment, writer.uint32(34).fork()).join();
    }
    if (message.price !== undefined) {
      MoneyValue.encode(message.price, writer.uint32(42).fork()).join();
    }
    if (message.state !== 0) {
      writer.uint32(48).int32(message.state);
    }
    if (message.quantity !== 0) {
      writer.uint32(56).int64(message.quantity);
    }
    if (message.quantityRest !== 0) {
      writer.uint32(64).int64(message.quantityRest);
    }
    if (message.figi !== "") {
      writer.uint32(74).string(message.figi);
    }
    if (message.instrumentType !== "") {
      writer.uint32(82).string(message.instrumentType);
    }
    if (message.date !== undefined) {
      Timestamp.encode(toTimestamp(message.date), writer.uint32(90).fork()).join();
    }
    if (message.type !== "") {
      writer.uint32(98).string(message.type);
    }
    if (message.operationType !== 0) {
      writer.uint32(104).int32(message.operationType);
    }
    for (const v of message.trades) {
      OperationTrade.encode(v!, writer.uint32(114).fork()).join();
    }
    if (message.assetUid !== "") {
      writer.uint32(130).string(message.assetUid);
    }
    if (message.positionUid !== "") {
      writer.uint32(138).string(message.positionUid);
    }
    if (message.instrumentUid !== "") {
      writer.uint32(146).string(message.instrumentUid);
    }
    for (const v of message.childOperations) {
      ChildOperationItem.encode(v!, writer.uint32(154).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Operation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.parentOperationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.payment = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.price = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.quantity = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.quantityRest = longToNumber(reader.int64());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.figi = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.instrumentType = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.date = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.operationType = reader.int32() as any;
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.trades.push(OperationTrade.decode(reader, reader.uint32()));
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.assetUid = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.positionUid = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.instrumentUid = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.childOperations.push(ChildOperationItem.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Operation>): Operation {
    return Operation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Operation>): Operation {
    const message = createBaseOperation();
    message.id = object.id ?? "";
    message.parentOperationId = object.parentOperationId ?? "";
    message.currency = object.currency ?? "";
    message.payment = (object.payment !== undefined && object.payment !== null)
      ? MoneyValue.fromPartial(object.payment)
      : undefined;
    message.price = (object.price !== undefined && object.price !== null)
      ? MoneyValue.fromPartial(object.price)
      : undefined;
    message.state = object.state ?? 0;
    message.quantity = object.quantity ?? 0;
    message.quantityRest = object.quantityRest ?? 0;
    message.figi = object.figi ?? "";
    message.instrumentType = object.instrumentType ?? "";
    message.date = object.date ?? undefined;
    message.type = object.type ?? "";
    message.operationType = object.operationType ?? 0;
    message.trades = object.trades?.map((e) => OperationTrade.fromPartial(e)) || [];
    message.assetUid = object.assetUid ?? "";
    message.positionUid = object.positionUid ?? "";
    message.instrumentUid = object.instrumentUid ?? "";
    message.childOperations = object.childOperations?.map((e) => ChildOperationItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOperationTrade(): OperationTrade {
  return { tradeId: "", dateTime: undefined, quantity: 0, price: undefined };
}

export const OperationTrade: OperationsUtils.MessageFns<OperationTrade> = {
  encode(message: OperationTrade, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tradeId !== "") {
      writer.uint32(10).string(message.tradeId);
    }
    if (message.dateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.dateTime), writer.uint32(18).fork()).join();
    }
    if (message.quantity !== 0) {
      writer.uint32(24).int64(message.quantity);
    }
    if (message.price !== undefined) {
      MoneyValue.encode(message.price, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperationTrade {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationTrade();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tradeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.dateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.quantity = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.price = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<OperationTrade>): OperationTrade {
    return OperationTrade.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OperationTrade>): OperationTrade {
    const message = createBaseOperationTrade();
    message.tradeId = object.tradeId ?? "";
    message.dateTime = object.dateTime ?? undefined;
    message.quantity = object.quantity ?? 0;
    message.price = (object.price !== undefined && object.price !== null)
      ? MoneyValue.fromPartial(object.price)
      : undefined;
    return message;
  },
};

function createBasePortfolioRequest(): PortfolioRequest {
  return { accountId: "", currency: undefined };
}

export const PortfolioRequest: OperationsUtils.MessageFns<PortfolioRequest> = {
  encode(message: PortfolioRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== "") {
      writer.uint32(10).string(message.accountId);
    }
    if (message.currency !== undefined) {
      writer.uint32(16).int32(message.currency);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PortfolioRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePortfolioRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.currency = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PortfolioRequest>): PortfolioRequest {
    return PortfolioRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PortfolioRequest>): PortfolioRequest {
    const message = createBasePortfolioRequest();
    message.accountId = object.accountId ?? "";
    message.currency = object.currency ?? undefined;
    return message;
  },
};

function createBasePortfolioResponse(): PortfolioResponse {
  return {
    totalAmountShares: undefined,
    totalAmountBonds: undefined,
    totalAmountEtf: undefined,
    totalAmountCurrencies: undefined,
    totalAmountFutures: undefined,
    expectedYield: undefined,
    positions: [],
    accountId: "",
    totalAmountOptions: undefined,
    totalAmountSp: undefined,
    totalAmountPortfolio: undefined,
    virtualPositions: [],
    dailyYield: undefined,
    dailyYieldRelative: undefined,
  };
}

export const PortfolioResponse: OperationsUtils.MessageFns<PortfolioResponse> = {
  encode(message: PortfolioResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalAmountShares !== undefined) {
      MoneyValue.encode(message.totalAmountShares, writer.uint32(10).fork()).join();
    }
    if (message.totalAmountBonds !== undefined) {
      MoneyValue.encode(message.totalAmountBonds, writer.uint32(18).fork()).join();
    }
    if (message.totalAmountEtf !== undefined) {
      MoneyValue.encode(message.totalAmountEtf, writer.uint32(26).fork()).join();
    }
    if (message.totalAmountCurrencies !== undefined) {
      MoneyValue.encode(message.totalAmountCurrencies, writer.uint32(34).fork()).join();
    }
    if (message.totalAmountFutures !== undefined) {
      MoneyValue.encode(message.totalAmountFutures, writer.uint32(42).fork()).join();
    }
    if (message.expectedYield !== undefined) {
      Quotation.encode(message.expectedYield, writer.uint32(50).fork()).join();
    }
    for (const v of message.positions) {
      PortfolioPosition.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.accountId !== "") {
      writer.uint32(66).string(message.accountId);
    }
    if (message.totalAmountOptions !== undefined) {
      MoneyValue.encode(message.totalAmountOptions, writer.uint32(74).fork()).join();
    }
    if (message.totalAmountSp !== undefined) {
      MoneyValue.encode(message.totalAmountSp, writer.uint32(82).fork()).join();
    }
    if (message.totalAmountPortfolio !== undefined) {
      MoneyValue.encode(message.totalAmountPortfolio, writer.uint32(90).fork()).join();
    }
    for (const v of message.virtualPositions) {
      VirtualPortfolioPosition.encode(v!, writer.uint32(98).fork()).join();
    }
    if (message.dailyYield !== undefined) {
      MoneyValue.encode(message.dailyYield, writer.uint32(122).fork()).join();
    }
    if (message.dailyYieldRelative !== undefined) {
      Quotation.encode(message.dailyYieldRelative, writer.uint32(130).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PortfolioResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePortfolioResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.totalAmountShares = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.totalAmountBonds = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.totalAmountEtf = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.totalAmountCurrencies = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.totalAmountFutures = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.expectedYield = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.positions.push(PortfolioPosition.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.accountId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.totalAmountOptions = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.totalAmountSp = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.totalAmountPortfolio = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.virtualPositions.push(VirtualPortfolioPosition.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.dailyYield = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.dailyYieldRelative = Quotation.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PortfolioResponse>): PortfolioResponse {
    return PortfolioResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PortfolioResponse>): PortfolioResponse {
    const message = createBasePortfolioResponse();
    message.totalAmountShares = (object.totalAmountShares !== undefined && object.totalAmountShares !== null)
      ? MoneyValue.fromPartial(object.totalAmountShares)
      : undefined;
    message.totalAmountBonds = (object.totalAmountBonds !== undefined && object.totalAmountBonds !== null)
      ? MoneyValue.fromPartial(object.totalAmountBonds)
      : undefined;
    message.totalAmountEtf = (object.totalAmountEtf !== undefined && object.totalAmountEtf !== null)
      ? MoneyValue.fromPartial(object.totalAmountEtf)
      : undefined;
    message.totalAmountCurrencies =
      (object.totalAmountCurrencies !== undefined && object.totalAmountCurrencies !== null)
        ? MoneyValue.fromPartial(object.totalAmountCurrencies)
        : undefined;
    message.totalAmountFutures = (object.totalAmountFutures !== undefined && object.totalAmountFutures !== null)
      ? MoneyValue.fromPartial(object.totalAmountFutures)
      : undefined;
    message.expectedYield = (object.expectedYield !== undefined && object.expectedYield !== null)
      ? Quotation.fromPartial(object.expectedYield)
      : undefined;
    message.positions = object.positions?.map((e) => PortfolioPosition.fromPartial(e)) || [];
    message.accountId = object.accountId ?? "";
    message.totalAmountOptions = (object.totalAmountOptions !== undefined && object.totalAmountOptions !== null)
      ? MoneyValue.fromPartial(object.totalAmountOptions)
      : undefined;
    message.totalAmountSp = (object.totalAmountSp !== undefined && object.totalAmountSp !== null)
      ? MoneyValue.fromPartial(object.totalAmountSp)
      : undefined;
    message.totalAmountPortfolio = (object.totalAmountPortfolio !== undefined && object.totalAmountPortfolio !== null)
      ? MoneyValue.fromPartial(object.totalAmountPortfolio)
      : undefined;
    message.virtualPositions = object.virtualPositions?.map((e) => VirtualPortfolioPosition.fromPartial(e)) || [];
    message.dailyYield = (object.dailyYield !== undefined && object.dailyYield !== null)
      ? MoneyValue.fromPartial(object.dailyYield)
      : undefined;
    message.dailyYieldRelative = (object.dailyYieldRelative !== undefined && object.dailyYieldRelative !== null)
      ? Quotation.fromPartial(object.dailyYieldRelative)
      : undefined;
    return message;
  },
};

function createBasePositionsRequest(): PositionsRequest {
  return { accountId: "" };
}

export const PositionsRequest: OperationsUtils.MessageFns<PositionsRequest> = {
  encode(message: PositionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== "") {
      writer.uint32(10).string(message.accountId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PositionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePositionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PositionsRequest>): PositionsRequest {
    return PositionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PositionsRequest>): PositionsRequest {
    const message = createBasePositionsRequest();
    message.accountId = object.accountId ?? "";
    return message;
  },
};

function createBasePositionsResponse(): PositionsResponse {
  return {
    money: [],
    blocked: [],
    securities: [],
    limitsLoadingInProgress: false,
    futures: [],
    options: [],
    accountId: "",
  };
}

export const PositionsResponse: OperationsUtils.MessageFns<PositionsResponse> = {
  encode(message: PositionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.money) {
      MoneyValue.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.blocked) {
      MoneyValue.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.securities) {
      PositionsSecurities.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.limitsLoadingInProgress !== false) {
      writer.uint32(32).bool(message.limitsLoadingInProgress);
    }
    for (const v of message.futures) {
      PositionsFutures.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.options) {
      PositionsOptions.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.accountId !== "") {
      writer.uint32(122).string(message.accountId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PositionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePositionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.money.push(MoneyValue.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blocked.push(MoneyValue.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.securities.push(PositionsSecurities.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.limitsLoadingInProgress = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.futures.push(PositionsFutures.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.options.push(PositionsOptions.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.accountId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PositionsResponse>): PositionsResponse {
    return PositionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PositionsResponse>): PositionsResponse {
    const message = createBasePositionsResponse();
    message.money = object.money?.map((e) => MoneyValue.fromPartial(e)) || [];
    message.blocked = object.blocked?.map((e) => MoneyValue.fromPartial(e)) || [];
    message.securities = object.securities?.map((e) => PositionsSecurities.fromPartial(e)) || [];
    message.limitsLoadingInProgress = object.limitsLoadingInProgress ?? false;
    message.futures = object.futures?.map((e) => PositionsFutures.fromPartial(e)) || [];
    message.options = object.options?.map((e) => PositionsOptions.fromPartial(e)) || [];
    message.accountId = object.accountId ?? "";
    return message;
  },
};

function createBaseWithdrawLimitsRequest(): WithdrawLimitsRequest {
  return { accountId: "" };
}

export const WithdrawLimitsRequest: OperationsUtils.MessageFns<WithdrawLimitsRequest> = {
  encode(message: WithdrawLimitsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== "") {
      writer.uint32(10).string(message.accountId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WithdrawLimitsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWithdrawLimitsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<WithdrawLimitsRequest>): WithdrawLimitsRequest {
    return WithdrawLimitsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WithdrawLimitsRequest>): WithdrawLimitsRequest {
    const message = createBaseWithdrawLimitsRequest();
    message.accountId = object.accountId ?? "";
    return message;
  },
};

function createBaseWithdrawLimitsResponse(): WithdrawLimitsResponse {
  return { money: [], blocked: [], blockedGuarantee: [] };
}

export const WithdrawLimitsResponse: OperationsUtils.MessageFns<WithdrawLimitsResponse> = {
  encode(message: WithdrawLimitsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.money) {
      MoneyValue.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.blocked) {
      MoneyValue.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.blockedGuarantee) {
      MoneyValue.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WithdrawLimitsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWithdrawLimitsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.money.push(MoneyValue.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blocked.push(MoneyValue.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.blockedGuarantee.push(MoneyValue.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<WithdrawLimitsResponse>): WithdrawLimitsResponse {
    return WithdrawLimitsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WithdrawLimitsResponse>): WithdrawLimitsResponse {
    const message = createBaseWithdrawLimitsResponse();
    message.money = object.money?.map((e) => MoneyValue.fromPartial(e)) || [];
    message.blocked = object.blocked?.map((e) => MoneyValue.fromPartial(e)) || [];
    message.blockedGuarantee = object.blockedGuarantee?.map((e) => MoneyValue.fromPartial(e)) || [];
    return message;
  },
};

function createBasePortfolioPosition(): PortfolioPosition {
  return {
    figi: "",
    instrumentType: "",
    quantity: undefined,
    averagePositionPrice: undefined,
    expectedYield: undefined,
    currentNkd: undefined,
    averagePositionPricePt: undefined,
    currentPrice: undefined,
    averagePositionPriceFifo: undefined,
    quantityLots: undefined,
    blocked: false,
    blockedLots: undefined,
    positionUid: "",
    instrumentUid: "",
    varMargin: undefined,
    expectedYieldFifo: undefined,
    dailyYield: undefined,
  };
}

export const PortfolioPosition: OperationsUtils.MessageFns<PortfolioPosition> = {
  encode(message: PortfolioPosition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.figi !== "") {
      writer.uint32(10).string(message.figi);
    }
    if (message.instrumentType !== "") {
      writer.uint32(18).string(message.instrumentType);
    }
    if (message.quantity !== undefined) {
      Quotation.encode(message.quantity, writer.uint32(26).fork()).join();
    }
    if (message.averagePositionPrice !== undefined) {
      MoneyValue.encode(message.averagePositionPrice, writer.uint32(34).fork()).join();
    }
    if (message.expectedYield !== undefined) {
      Quotation.encode(message.expectedYield, writer.uint32(42).fork()).join();
    }
    if (message.currentNkd !== undefined) {
      MoneyValue.encode(message.currentNkd, writer.uint32(50).fork()).join();
    }
    if (message.averagePositionPricePt !== undefined) {
      Quotation.encode(message.averagePositionPricePt, writer.uint32(58).fork()).join();
    }
    if (message.currentPrice !== undefined) {
      MoneyValue.encode(message.currentPrice, writer.uint32(66).fork()).join();
    }
    if (message.averagePositionPriceFifo !== undefined) {
      MoneyValue.encode(message.averagePositionPriceFifo, writer.uint32(74).fork()).join();
    }
    if (message.quantityLots !== undefined) {
      Quotation.encode(message.quantityLots, writer.uint32(82).fork()).join();
    }
    if (message.blocked !== false) {
      writer.uint32(168).bool(message.blocked);
    }
    if (message.blockedLots !== undefined) {
      Quotation.encode(message.blockedLots, writer.uint32(178).fork()).join();
    }
    if (message.positionUid !== "") {
      writer.uint32(194).string(message.positionUid);
    }
    if (message.instrumentUid !== "") {
      writer.uint32(202).string(message.instrumentUid);
    }
    if (message.varMargin !== undefined) {
      MoneyValue.encode(message.varMargin, writer.uint32(210).fork()).join();
    }
    if (message.expectedYieldFifo !== undefined) {
      Quotation.encode(message.expectedYieldFifo, writer.uint32(218).fork()).join();
    }
    if (message.dailyYield !== undefined) {
      MoneyValue.encode(message.dailyYield, writer.uint32(250).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PortfolioPosition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePortfolioPosition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.figi = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.instrumentType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.quantity = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.averagePositionPrice = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.expectedYield = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.currentNkd = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.averagePositionPricePt = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.currentPrice = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.averagePositionPriceFifo = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.quantityLots = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.blocked = reader.bool();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.blockedLots = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.positionUid = reader.string();
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.instrumentUid = reader.string();
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.varMargin = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.expectedYieldFifo = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.dailyYield = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PortfolioPosition>): PortfolioPosition {
    return PortfolioPosition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PortfolioPosition>): PortfolioPosition {
    const message = createBasePortfolioPosition();
    message.figi = object.figi ?? "";
    message.instrumentType = object.instrumentType ?? "";
    message.quantity = (object.quantity !== undefined && object.quantity !== null)
      ? Quotation.fromPartial(object.quantity)
      : undefined;
    message.averagePositionPrice = (object.averagePositionPrice !== undefined && object.averagePositionPrice !== null)
      ? MoneyValue.fromPartial(object.averagePositionPrice)
      : undefined;
    message.expectedYield = (object.expectedYield !== undefined && object.expectedYield !== null)
      ? Quotation.fromPartial(object.expectedYield)
      : undefined;
    message.currentNkd = (object.currentNkd !== undefined && object.currentNkd !== null)
      ? MoneyValue.fromPartial(object.currentNkd)
      : undefined;
    message.averagePositionPricePt =
      (object.averagePositionPricePt !== undefined && object.averagePositionPricePt !== null)
        ? Quotation.fromPartial(object.averagePositionPricePt)
        : undefined;
    message.currentPrice = (object.currentPrice !== undefined && object.currentPrice !== null)
      ? MoneyValue.fromPartial(object.currentPrice)
      : undefined;
    message.averagePositionPriceFifo =
      (object.averagePositionPriceFifo !== undefined && object.averagePositionPriceFifo !== null)
        ? MoneyValue.fromPartial(object.averagePositionPriceFifo)
        : undefined;
    message.quantityLots = (object.quantityLots !== undefined && object.quantityLots !== null)
      ? Quotation.fromPartial(object.quantityLots)
      : undefined;
    message.blocked = object.blocked ?? false;
    message.blockedLots = (object.blockedLots !== undefined && object.blockedLots !== null)
      ? Quotation.fromPartial(object.blockedLots)
      : undefined;
    message.positionUid = object.positionUid ?? "";
    message.instrumentUid = object.instrumentUid ?? "";
    message.varMargin = (object.varMargin !== undefined && object.varMargin !== null)
      ? MoneyValue.fromPartial(object.varMargin)
      : undefined;
    message.expectedYieldFifo = (object.expectedYieldFifo !== undefined && object.expectedYieldFifo !== null)
      ? Quotation.fromPartial(object.expectedYieldFifo)
      : undefined;
    message.dailyYield = (object.dailyYield !== undefined && object.dailyYield !== null)
      ? MoneyValue.fromPartial(object.dailyYield)
      : undefined;
    return message;
  },
};

function createBaseVirtualPortfolioPosition(): VirtualPortfolioPosition {
  return {
    positionUid: "",
    instrumentUid: "",
    figi: "",
    instrumentType: "",
    quantity: undefined,
    averagePositionPrice: undefined,
    expectedYield: undefined,
    expectedYieldFifo: undefined,
    expireDate: undefined,
    currentPrice: undefined,
    averagePositionPriceFifo: undefined,
    dailyYield: undefined,
  };
}

export const VirtualPortfolioPosition: OperationsUtils.MessageFns<VirtualPortfolioPosition> = {
  encode(message: VirtualPortfolioPosition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.positionUid !== "") {
      writer.uint32(10).string(message.positionUid);
    }
    if (message.instrumentUid !== "") {
      writer.uint32(18).string(message.instrumentUid);
    }
    if (message.figi !== "") {
      writer.uint32(26).string(message.figi);
    }
    if (message.instrumentType !== "") {
      writer.uint32(34).string(message.instrumentType);
    }
    if (message.quantity !== undefined) {
      Quotation.encode(message.quantity, writer.uint32(42).fork()).join();
    }
    if (message.averagePositionPrice !== undefined) {
      MoneyValue.encode(message.averagePositionPrice, writer.uint32(50).fork()).join();
    }
    if (message.expectedYield !== undefined) {
      Quotation.encode(message.expectedYield, writer.uint32(58).fork()).join();
    }
    if (message.expectedYieldFifo !== undefined) {
      Quotation.encode(message.expectedYieldFifo, writer.uint32(66).fork()).join();
    }
    if (message.expireDate !== undefined) {
      Timestamp.encode(toTimestamp(message.expireDate), writer.uint32(74).fork()).join();
    }
    if (message.currentPrice !== undefined) {
      MoneyValue.encode(message.currentPrice, writer.uint32(82).fork()).join();
    }
    if (message.averagePositionPriceFifo !== undefined) {
      MoneyValue.encode(message.averagePositionPriceFifo, writer.uint32(90).fork()).join();
    }
    if (message.dailyYield !== undefined) {
      MoneyValue.encode(message.dailyYield, writer.uint32(250).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VirtualPortfolioPosition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVirtualPortfolioPosition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.positionUid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.instrumentUid = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.figi = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.instrumentType = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.quantity = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.averagePositionPrice = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.expectedYield = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.expectedYieldFifo = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.expireDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.currentPrice = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.averagePositionPriceFifo = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.dailyYield = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<VirtualPortfolioPosition>): VirtualPortfolioPosition {
    return VirtualPortfolioPosition.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<VirtualPortfolioPosition>): VirtualPortfolioPosition {
    const message = createBaseVirtualPortfolioPosition();
    message.positionUid = object.positionUid ?? "";
    message.instrumentUid = object.instrumentUid ?? "";
    message.figi = object.figi ?? "";
    message.instrumentType = object.instrumentType ?? "";
    message.quantity = (object.quantity !== undefined && object.quantity !== null)
      ? Quotation.fromPartial(object.quantity)
      : undefined;
    message.averagePositionPrice = (object.averagePositionPrice !== undefined && object.averagePositionPrice !== null)
      ? MoneyValue.fromPartial(object.averagePositionPrice)
      : undefined;
    message.expectedYield = (object.expectedYield !== undefined && object.expectedYield !== null)
      ? Quotation.fromPartial(object.expectedYield)
      : undefined;
    message.expectedYieldFifo = (object.expectedYieldFifo !== undefined && object.expectedYieldFifo !== null)
      ? Quotation.fromPartial(object.expectedYieldFifo)
      : undefined;
    message.expireDate = object.expireDate ?? undefined;
    message.currentPrice = (object.currentPrice !== undefined && object.currentPrice !== null)
      ? MoneyValue.fromPartial(object.currentPrice)
      : undefined;
    message.averagePositionPriceFifo =
      (object.averagePositionPriceFifo !== undefined && object.averagePositionPriceFifo !== null)
        ? MoneyValue.fromPartial(object.averagePositionPriceFifo)
        : undefined;
    message.dailyYield = (object.dailyYield !== undefined && object.dailyYield !== null)
      ? MoneyValue.fromPartial(object.dailyYield)
      : undefined;
    return message;
  },
};

function createBasePositionsSecurities(): PositionsSecurities {
  return {
    figi: "",
    blocked: 0,
    balance: 0,
    positionUid: "",
    instrumentUid: "",
    exchangeBlocked: false,
    instrumentType: "",
  };
}

export const PositionsSecurities: OperationsUtils.MessageFns<PositionsSecurities> = {
  encode(message: PositionsSecurities, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.figi !== "") {
      writer.uint32(10).string(message.figi);
    }
    if (message.blocked !== 0) {
      writer.uint32(16).int64(message.blocked);
    }
    if (message.balance !== 0) {
      writer.uint32(24).int64(message.balance);
    }
    if (message.positionUid !== "") {
      writer.uint32(34).string(message.positionUid);
    }
    if (message.instrumentUid !== "") {
      writer.uint32(42).string(message.instrumentUid);
    }
    if (message.exchangeBlocked !== false) {
      writer.uint32(88).bool(message.exchangeBlocked);
    }
    if (message.instrumentType !== "") {
      writer.uint32(130).string(message.instrumentType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PositionsSecurities {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePositionsSecurities();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.figi = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.blocked = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.balance = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.positionUid = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.instrumentUid = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.exchangeBlocked = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.instrumentType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PositionsSecurities>): PositionsSecurities {
    return PositionsSecurities.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PositionsSecurities>): PositionsSecurities {
    const message = createBasePositionsSecurities();
    message.figi = object.figi ?? "";
    message.blocked = object.blocked ?? 0;
    message.balance = object.balance ?? 0;
    message.positionUid = object.positionUid ?? "";
    message.instrumentUid = object.instrumentUid ?? "";
    message.exchangeBlocked = object.exchangeBlocked ?? false;
    message.instrumentType = object.instrumentType ?? "";
    return message;
  },
};

function createBasePositionsFutures(): PositionsFutures {
  return { figi: "", blocked: 0, balance: 0, positionUid: "", instrumentUid: "" };
}

export const PositionsFutures: OperationsUtils.MessageFns<PositionsFutures> = {
  encode(message: PositionsFutures, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.figi !== "") {
      writer.uint32(10).string(message.figi);
    }
    if (message.blocked !== 0) {
      writer.uint32(16).int64(message.blocked);
    }
    if (message.balance !== 0) {
      writer.uint32(24).int64(message.balance);
    }
    if (message.positionUid !== "") {
      writer.uint32(34).string(message.positionUid);
    }
    if (message.instrumentUid !== "") {
      writer.uint32(42).string(message.instrumentUid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PositionsFutures {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePositionsFutures();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.figi = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.blocked = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.balance = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.positionUid = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.instrumentUid = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PositionsFutures>): PositionsFutures {
    return PositionsFutures.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PositionsFutures>): PositionsFutures {
    const message = createBasePositionsFutures();
    message.figi = object.figi ?? "";
    message.blocked = object.blocked ?? 0;
    message.balance = object.balance ?? 0;
    message.positionUid = object.positionUid ?? "";
    message.instrumentUid = object.instrumentUid ?? "";
    return message;
  },
};

function createBasePositionsOptions(): PositionsOptions {
  return { positionUid: "", instrumentUid: "", blocked: 0, balance: 0 };
}

export const PositionsOptions: OperationsUtils.MessageFns<PositionsOptions> = {
  encode(message: PositionsOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.positionUid !== "") {
      writer.uint32(10).string(message.positionUid);
    }
    if (message.instrumentUid !== "") {
      writer.uint32(18).string(message.instrumentUid);
    }
    if (message.blocked !== 0) {
      writer.uint32(88).int64(message.blocked);
    }
    if (message.balance !== 0) {
      writer.uint32(168).int64(message.balance);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PositionsOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePositionsOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.positionUid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.instrumentUid = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.blocked = longToNumber(reader.int64());
          continue;
        }
        case 21: {
          if (tag !== 168) {
            break;
          }

          message.balance = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PositionsOptions>): PositionsOptions {
    return PositionsOptions.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PositionsOptions>): PositionsOptions {
    const message = createBasePositionsOptions();
    message.positionUid = object.positionUid ?? "";
    message.instrumentUid = object.instrumentUid ?? "";
    message.blocked = object.blocked ?? 0;
    message.balance = object.balance ?? 0;
    return message;
  },
};

function createBaseBrokerReportRequest(): BrokerReportRequest {
  return { generateBrokerReportRequest: undefined, getBrokerReportRequest: undefined };
}

export const BrokerReportRequest: OperationsUtils.MessageFns<BrokerReportRequest> = {
  encode(message: BrokerReportRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.generateBrokerReportRequest !== undefined) {
      GenerateBrokerReportRequest.encode(message.generateBrokerReportRequest, writer.uint32(10).fork()).join();
    }
    if (message.getBrokerReportRequest !== undefined) {
      GetBrokerReportRequest.encode(message.getBrokerReportRequest, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BrokerReportRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBrokerReportRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.generateBrokerReportRequest = GenerateBrokerReportRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.getBrokerReportRequest = GetBrokerReportRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<BrokerReportRequest>): BrokerReportRequest {
    return BrokerReportRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BrokerReportRequest>): BrokerReportRequest {
    const message = createBaseBrokerReportRequest();
    message.generateBrokerReportRequest =
      (object.generateBrokerReportRequest !== undefined && object.generateBrokerReportRequest !== null)
        ? GenerateBrokerReportRequest.fromPartial(object.generateBrokerReportRequest)
        : undefined;
    message.getBrokerReportRequest =
      (object.getBrokerReportRequest !== undefined && object.getBrokerReportRequest !== null)
        ? GetBrokerReportRequest.fromPartial(object.getBrokerReportRequest)
        : undefined;
    return message;
  },
};

function createBaseBrokerReportResponse(): BrokerReportResponse {
  return { generateBrokerReportResponse: undefined, getBrokerReportResponse: undefined };
}

export const BrokerReportResponse: OperationsUtils.MessageFns<BrokerReportResponse> = {
  encode(message: BrokerReportResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.generateBrokerReportResponse !== undefined) {
      GenerateBrokerReportResponse.encode(message.generateBrokerReportResponse, writer.uint32(10).fork()).join();
    }
    if (message.getBrokerReportResponse !== undefined) {
      GetBrokerReportResponse.encode(message.getBrokerReportResponse, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BrokerReportResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBrokerReportResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.generateBrokerReportResponse = GenerateBrokerReportResponse.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.getBrokerReportResponse = GetBrokerReportResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<BrokerReportResponse>): BrokerReportResponse {
    return BrokerReportResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BrokerReportResponse>): BrokerReportResponse {
    const message = createBaseBrokerReportResponse();
    message.generateBrokerReportResponse =
      (object.generateBrokerReportResponse !== undefined && object.generateBrokerReportResponse !== null)
        ? GenerateBrokerReportResponse.fromPartial(object.generateBrokerReportResponse)
        : undefined;
    message.getBrokerReportResponse =
      (object.getBrokerReportResponse !== undefined && object.getBrokerReportResponse !== null)
        ? GetBrokerReportResponse.fromPartial(object.getBrokerReportResponse)
        : undefined;
    return message;
  },
};

function createBaseGenerateBrokerReportRequest(): GenerateBrokerReportRequest {
  return { accountId: "", from: undefined, to: undefined };
}

export const GenerateBrokerReportRequest: OperationsUtils.MessageFns<GenerateBrokerReportRequest> = {
  encode(message: GenerateBrokerReportRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== "") {
      writer.uint32(10).string(message.accountId);
    }
    if (message.from !== undefined) {
      Timestamp.encode(toTimestamp(message.from), writer.uint32(18).fork()).join();
    }
    if (message.to !== undefined) {
      Timestamp.encode(toTimestamp(message.to), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateBrokerReportRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateBrokerReportRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.from = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.to = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GenerateBrokerReportRequest>): GenerateBrokerReportRequest {
    return GenerateBrokerReportRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateBrokerReportRequest>): GenerateBrokerReportRequest {
    const message = createBaseGenerateBrokerReportRequest();
    message.accountId = object.accountId ?? "";
    message.from = object.from ?? undefined;
    message.to = object.to ?? undefined;
    return message;
  },
};

function createBaseGenerateBrokerReportResponse(): GenerateBrokerReportResponse {
  return { taskId: "" };
}

export const GenerateBrokerReportResponse: OperationsUtils.MessageFns<GenerateBrokerReportResponse> = {
  encode(message: GenerateBrokerReportResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.taskId !== "") {
      writer.uint32(10).string(message.taskId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateBrokerReportResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateBrokerReportResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.taskId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GenerateBrokerReportResponse>): GenerateBrokerReportResponse {
    return GenerateBrokerReportResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GenerateBrokerReportResponse>): GenerateBrokerReportResponse {
    const message = createBaseGenerateBrokerReportResponse();
    message.taskId = object.taskId ?? "";
    return message;
  },
};

function createBaseGetBrokerReportRequest(): GetBrokerReportRequest {
  return { taskId: "", page: undefined };
}

export const GetBrokerReportRequest: OperationsUtils.MessageFns<GetBrokerReportRequest> = {
  encode(message: GetBrokerReportRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.taskId !== "") {
      writer.uint32(10).string(message.taskId);
    }
    if (message.page !== undefined) {
      writer.uint32(16).int32(message.page);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBrokerReportRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBrokerReportRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.taskId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetBrokerReportRequest>): GetBrokerReportRequest {
    return GetBrokerReportRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBrokerReportRequest>): GetBrokerReportRequest {
    const message = createBaseGetBrokerReportRequest();
    message.taskId = object.taskId ?? "";
    message.page = object.page ?? undefined;
    return message;
  },
};

function createBaseGetBrokerReportResponse(): GetBrokerReportResponse {
  return { brokerReport: [], itemsCount: 0, pagesCount: 0, page: 0 };
}

export const GetBrokerReportResponse: OperationsUtils.MessageFns<GetBrokerReportResponse> = {
  encode(message: GetBrokerReportResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.brokerReport) {
      BrokerReport.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.itemsCount !== 0) {
      writer.uint32(16).int32(message.itemsCount);
    }
    if (message.pagesCount !== 0) {
      writer.uint32(24).int32(message.pagesCount);
    }
    if (message.page !== 0) {
      writer.uint32(32).int32(message.page);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBrokerReportResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBrokerReportResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.brokerReport.push(BrokerReport.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.itemsCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pagesCount = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetBrokerReportResponse>): GetBrokerReportResponse {
    return GetBrokerReportResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBrokerReportResponse>): GetBrokerReportResponse {
    const message = createBaseGetBrokerReportResponse();
    message.brokerReport = object.brokerReport?.map((e) => BrokerReport.fromPartial(e)) || [];
    message.itemsCount = object.itemsCount ?? 0;
    message.pagesCount = object.pagesCount ?? 0;
    message.page = object.page ?? 0;
    return message;
  },
};

function createBaseBrokerReport(): BrokerReport {
  return {
    tradeId: "",
    orderId: "",
    figi: "",
    executeSign: "",
    tradeDatetime: undefined,
    exchange: "",
    classCode: "",
    direction: "",
    name: "",
    ticker: "",
    price: undefined,
    quantity: 0,
    orderAmount: undefined,
    aciValue: undefined,
    totalOrderAmount: undefined,
    brokerCommission: undefined,
    exchangeCommission: undefined,
    exchangeClearingCommission: undefined,
    repoRate: undefined,
    party: "",
    clearValueDate: undefined,
    secValueDate: undefined,
    brokerStatus: "",
    separateAgreementType: "",
    separateAgreementNumber: "",
    separateAgreementDate: "",
    deliveryType: "",
  };
}

export const BrokerReport: OperationsUtils.MessageFns<BrokerReport> = {
  encode(message: BrokerReport, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tradeId !== "") {
      writer.uint32(10).string(message.tradeId);
    }
    if (message.orderId !== "") {
      writer.uint32(18).string(message.orderId);
    }
    if (message.figi !== "") {
      writer.uint32(26).string(message.figi);
    }
    if (message.executeSign !== "") {
      writer.uint32(34).string(message.executeSign);
    }
    if (message.tradeDatetime !== undefined) {
      Timestamp.encode(toTimestamp(message.tradeDatetime), writer.uint32(42).fork()).join();
    }
    if (message.exchange !== "") {
      writer.uint32(50).string(message.exchange);
    }
    if (message.classCode !== "") {
      writer.uint32(58).string(message.classCode);
    }
    if (message.direction !== "") {
      writer.uint32(66).string(message.direction);
    }
    if (message.name !== "") {
      writer.uint32(74).string(message.name);
    }
    if (message.ticker !== "") {
      writer.uint32(82).string(message.ticker);
    }
    if (message.price !== undefined) {
      MoneyValue.encode(message.price, writer.uint32(90).fork()).join();
    }
    if (message.quantity !== 0) {
      writer.uint32(96).int64(message.quantity);
    }
    if (message.orderAmount !== undefined) {
      MoneyValue.encode(message.orderAmount, writer.uint32(106).fork()).join();
    }
    if (message.aciValue !== undefined) {
      Quotation.encode(message.aciValue, writer.uint32(114).fork()).join();
    }
    if (message.totalOrderAmount !== undefined) {
      MoneyValue.encode(message.totalOrderAmount, writer.uint32(122).fork()).join();
    }
    if (message.brokerCommission !== undefined) {
      MoneyValue.encode(message.brokerCommission, writer.uint32(130).fork()).join();
    }
    if (message.exchangeCommission !== undefined) {
      MoneyValue.encode(message.exchangeCommission, writer.uint32(138).fork()).join();
    }
    if (message.exchangeClearingCommission !== undefined) {
      MoneyValue.encode(message.exchangeClearingCommission, writer.uint32(146).fork()).join();
    }
    if (message.repoRate !== undefined) {
      Quotation.encode(message.repoRate, writer.uint32(154).fork()).join();
    }
    if (message.party !== "") {
      writer.uint32(162).string(message.party);
    }
    if (message.clearValueDate !== undefined) {
      Timestamp.encode(toTimestamp(message.clearValueDate), writer.uint32(170).fork()).join();
    }
    if (message.secValueDate !== undefined) {
      Timestamp.encode(toTimestamp(message.secValueDate), writer.uint32(178).fork()).join();
    }
    if (message.brokerStatus !== "") {
      writer.uint32(186).string(message.brokerStatus);
    }
    if (message.separateAgreementType !== "") {
      writer.uint32(194).string(message.separateAgreementType);
    }
    if (message.separateAgreementNumber !== "") {
      writer.uint32(202).string(message.separateAgreementNumber);
    }
    if (message.separateAgreementDate !== "") {
      writer.uint32(210).string(message.separateAgreementDate);
    }
    if (message.deliveryType !== "") {
      writer.uint32(218).string(message.deliveryType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BrokerReport {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBrokerReport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tradeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.figi = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.executeSign = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.tradeDatetime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.exchange = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.classCode = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.direction = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.ticker = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.price = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.quantity = longToNumber(reader.int64());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.orderAmount = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.aciValue = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.totalOrderAmount = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.brokerCommission = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.exchangeCommission = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.exchangeClearingCommission = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.repoRate = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.party = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.clearValueDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.secValueDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.brokerStatus = reader.string();
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.separateAgreementType = reader.string();
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.separateAgreementNumber = reader.string();
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.separateAgreementDate = reader.string();
          continue;
        }
        case 27: {
          if (tag !== 218) {
            break;
          }

          message.deliveryType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<BrokerReport>): BrokerReport {
    return BrokerReport.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<BrokerReport>): BrokerReport {
    const message = createBaseBrokerReport();
    message.tradeId = object.tradeId ?? "";
    message.orderId = object.orderId ?? "";
    message.figi = object.figi ?? "";
    message.executeSign = object.executeSign ?? "";
    message.tradeDatetime = object.tradeDatetime ?? undefined;
    message.exchange = object.exchange ?? "";
    message.classCode = object.classCode ?? "";
    message.direction = object.direction ?? "";
    message.name = object.name ?? "";
    message.ticker = object.ticker ?? "";
    message.price = (object.price !== undefined && object.price !== null)
      ? MoneyValue.fromPartial(object.price)
      : undefined;
    message.quantity = object.quantity ?? 0;
    message.orderAmount = (object.orderAmount !== undefined && object.orderAmount !== null)
      ? MoneyValue.fromPartial(object.orderAmount)
      : undefined;
    message.aciValue = (object.aciValue !== undefined && object.aciValue !== null)
      ? Quotation.fromPartial(object.aciValue)
      : undefined;
    message.totalOrderAmount = (object.totalOrderAmount !== undefined && object.totalOrderAmount !== null)
      ? MoneyValue.fromPartial(object.totalOrderAmount)
      : undefined;
    message.brokerCommission = (object.brokerCommission !== undefined && object.brokerCommission !== null)
      ? MoneyValue.fromPartial(object.brokerCommission)
      : undefined;
    message.exchangeCommission = (object.exchangeCommission !== undefined && object.exchangeCommission !== null)
      ? MoneyValue.fromPartial(object.exchangeCommission)
      : undefined;
    message.exchangeClearingCommission =
      (object.exchangeClearingCommission !== undefined && object.exchangeClearingCommission !== null)
        ? MoneyValue.fromPartial(object.exchangeClearingCommission)
        : undefined;
    message.repoRate = (object.repoRate !== undefined && object.repoRate !== null)
      ? Quotation.fromPartial(object.repoRate)
      : undefined;
    message.party = object.party ?? "";
    message.clearValueDate = object.clearValueDate ?? undefined;
    message.secValueDate = object.secValueDate ?? undefined;
    message.brokerStatus = object.brokerStatus ?? "";
    message.separateAgreementType = object.separateAgreementType ?? "";
    message.separateAgreementNumber = object.separateAgreementNumber ?? "";
    message.separateAgreementDate = object.separateAgreementDate ?? "";
    message.deliveryType = object.deliveryType ?? "";
    return message;
  },
};

function createBaseGetDividendsForeignIssuerRequest(): GetDividendsForeignIssuerRequest {
  return { generateDivForeignIssuerReport: undefined, getDivForeignIssuerReport: undefined };
}

export const GetDividendsForeignIssuerRequest: OperationsUtils.MessageFns<GetDividendsForeignIssuerRequest> = {
  encode(message: GetDividendsForeignIssuerRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.generateDivForeignIssuerReport !== undefined) {
      GenerateDividendsForeignIssuerReportRequest.encode(
        message.generateDivForeignIssuerReport,
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.getDivForeignIssuerReport !== undefined) {
      GetDividendsForeignIssuerReportRequest.encode(message.getDivForeignIssuerReport, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDividendsForeignIssuerRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDividendsForeignIssuerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.generateDivForeignIssuerReport = GenerateDividendsForeignIssuerReportRequest.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.getDivForeignIssuerReport = GetDividendsForeignIssuerReportRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetDividendsForeignIssuerRequest>): GetDividendsForeignIssuerRequest {
    return GetDividendsForeignIssuerRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDividendsForeignIssuerRequest>): GetDividendsForeignIssuerRequest {
    const message = createBaseGetDividendsForeignIssuerRequest();
    message.generateDivForeignIssuerReport =
      (object.generateDivForeignIssuerReport !== undefined && object.generateDivForeignIssuerReport !== null)
        ? GenerateDividendsForeignIssuerReportRequest.fromPartial(object.generateDivForeignIssuerReport)
        : undefined;
    message.getDivForeignIssuerReport =
      (object.getDivForeignIssuerReport !== undefined && object.getDivForeignIssuerReport !== null)
        ? GetDividendsForeignIssuerReportRequest.fromPartial(object.getDivForeignIssuerReport)
        : undefined;
    return message;
  },
};

function createBaseGetDividendsForeignIssuerResponse(): GetDividendsForeignIssuerResponse {
  return { generateDivForeignIssuerReportResponse: undefined, divForeignIssuerReport: undefined };
}

export const GetDividendsForeignIssuerResponse: OperationsUtils.MessageFns<GetDividendsForeignIssuerResponse> = {
  encode(message: GetDividendsForeignIssuerResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.generateDivForeignIssuerReportResponse !== undefined) {
      GenerateDividendsForeignIssuerReportResponse.encode(
        message.generateDivForeignIssuerReportResponse,
        writer.uint32(10).fork(),
      ).join();
    }
    if (message.divForeignIssuerReport !== undefined) {
      GetDividendsForeignIssuerReportResponse.encode(message.divForeignIssuerReport, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDividendsForeignIssuerResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDividendsForeignIssuerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.generateDivForeignIssuerReportResponse = GenerateDividendsForeignIssuerReportResponse.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.divForeignIssuerReport = GetDividendsForeignIssuerReportResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetDividendsForeignIssuerResponse>): GetDividendsForeignIssuerResponse {
    return GetDividendsForeignIssuerResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDividendsForeignIssuerResponse>): GetDividendsForeignIssuerResponse {
    const message = createBaseGetDividendsForeignIssuerResponse();
    message.generateDivForeignIssuerReportResponse =
      (object.generateDivForeignIssuerReportResponse !== undefined &&
          object.generateDivForeignIssuerReportResponse !== null)
        ? GenerateDividendsForeignIssuerReportResponse.fromPartial(object.generateDivForeignIssuerReportResponse)
        : undefined;
    message.divForeignIssuerReport =
      (object.divForeignIssuerReport !== undefined && object.divForeignIssuerReport !== null)
        ? GetDividendsForeignIssuerReportResponse.fromPartial(object.divForeignIssuerReport)
        : undefined;
    return message;
  },
};

function createBaseGenerateDividendsForeignIssuerReportRequest(): GenerateDividendsForeignIssuerReportRequest {
  return { accountId: "", from: undefined, to: undefined };
}

export const GenerateDividendsForeignIssuerReportRequest: OperationsUtils.MessageFns<GenerateDividendsForeignIssuerReportRequest> = {
  encode(
    message: GenerateDividendsForeignIssuerReportRequest,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.accountId !== "") {
      writer.uint32(10).string(message.accountId);
    }
    if (message.from !== undefined) {
      Timestamp.encode(toTimestamp(message.from), writer.uint32(18).fork()).join();
    }
    if (message.to !== undefined) {
      Timestamp.encode(toTimestamp(message.to), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateDividendsForeignIssuerReportRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateDividendsForeignIssuerReportRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.from = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.to = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GenerateDividendsForeignIssuerReportRequest>): GenerateDividendsForeignIssuerReportRequest {
    return GenerateDividendsForeignIssuerReportRequest.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GenerateDividendsForeignIssuerReportRequest>,
  ): GenerateDividendsForeignIssuerReportRequest {
    const message = createBaseGenerateDividendsForeignIssuerReportRequest();
    message.accountId = object.accountId ?? "";
    message.from = object.from ?? undefined;
    message.to = object.to ?? undefined;
    return message;
  },
};

function createBaseGetDividendsForeignIssuerReportRequest(): GetDividendsForeignIssuerReportRequest {
  return { taskId: "", page: undefined };
}

export const GetDividendsForeignIssuerReportRequest: OperationsUtils.MessageFns<GetDividendsForeignIssuerReportRequest> = {
  encode(message: GetDividendsForeignIssuerReportRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.taskId !== "") {
      writer.uint32(10).string(message.taskId);
    }
    if (message.page !== undefined) {
      writer.uint32(16).int32(message.page);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDividendsForeignIssuerReportRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDividendsForeignIssuerReportRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.taskId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetDividendsForeignIssuerReportRequest>): GetDividendsForeignIssuerReportRequest {
    return GetDividendsForeignIssuerReportRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDividendsForeignIssuerReportRequest>): GetDividendsForeignIssuerReportRequest {
    const message = createBaseGetDividendsForeignIssuerReportRequest();
    message.taskId = object.taskId ?? "";
    message.page = object.page ?? undefined;
    return message;
  },
};

function createBaseGenerateDividendsForeignIssuerReportResponse(): GenerateDividendsForeignIssuerReportResponse {
  return { taskId: "" };
}

export const GenerateDividendsForeignIssuerReportResponse: OperationsUtils.MessageFns<GenerateDividendsForeignIssuerReportResponse> = {
  encode(
    message: GenerateDividendsForeignIssuerReportResponse,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.taskId !== "") {
      writer.uint32(10).string(message.taskId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateDividendsForeignIssuerReportResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateDividendsForeignIssuerReportResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.taskId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(
    base?: DeepPartial<GenerateDividendsForeignIssuerReportResponse>,
  ): GenerateDividendsForeignIssuerReportResponse {
    return GenerateDividendsForeignIssuerReportResponse.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<GenerateDividendsForeignIssuerReportResponse>,
  ): GenerateDividendsForeignIssuerReportResponse {
    const message = createBaseGenerateDividendsForeignIssuerReportResponse();
    message.taskId = object.taskId ?? "";
    return message;
  },
};

function createBaseGetDividendsForeignIssuerReportResponse(): GetDividendsForeignIssuerReportResponse {
  return { dividendsForeignIssuerReport: [], itemsCount: 0, pagesCount: 0, page: 0 };
}

export const GetDividendsForeignIssuerReportResponse: OperationsUtils.MessageFns<GetDividendsForeignIssuerReportResponse> = {
  encode(message: GetDividendsForeignIssuerReportResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.dividendsForeignIssuerReport) {
      DividendsForeignIssuerReport.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.itemsCount !== 0) {
      writer.uint32(16).int32(message.itemsCount);
    }
    if (message.pagesCount !== 0) {
      writer.uint32(24).int32(message.pagesCount);
    }
    if (message.page !== 0) {
      writer.uint32(32).int32(message.page);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetDividendsForeignIssuerReportResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetDividendsForeignIssuerReportResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.dividendsForeignIssuerReport.push(DividendsForeignIssuerReport.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.itemsCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.pagesCount = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.page = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetDividendsForeignIssuerReportResponse>): GetDividendsForeignIssuerReportResponse {
    return GetDividendsForeignIssuerReportResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetDividendsForeignIssuerReportResponse>): GetDividendsForeignIssuerReportResponse {
    const message = createBaseGetDividendsForeignIssuerReportResponse();
    message.dividendsForeignIssuerReport =
      object.dividendsForeignIssuerReport?.map((e) => DividendsForeignIssuerReport.fromPartial(e)) || [];
    message.itemsCount = object.itemsCount ?? 0;
    message.pagesCount = object.pagesCount ?? 0;
    message.page = object.page ?? 0;
    return message;
  },
};

function createBaseDividendsForeignIssuerReport(): DividendsForeignIssuerReport {
  return {
    recordDate: undefined,
    paymentDate: undefined,
    securityName: "",
    isin: "",
    issuerCountry: "",
    quantity: 0,
    dividend: undefined,
    externalCommission: undefined,
    dividendGross: undefined,
    tax: undefined,
    dividendAmount: undefined,
    currency: "",
  };
}

export const DividendsForeignIssuerReport: OperationsUtils.MessageFns<DividendsForeignIssuerReport> = {
  encode(message: DividendsForeignIssuerReport, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.recordDate !== undefined) {
      Timestamp.encode(toTimestamp(message.recordDate), writer.uint32(10).fork()).join();
    }
    if (message.paymentDate !== undefined) {
      Timestamp.encode(toTimestamp(message.paymentDate), writer.uint32(18).fork()).join();
    }
    if (message.securityName !== "") {
      writer.uint32(26).string(message.securityName);
    }
    if (message.isin !== "") {
      writer.uint32(34).string(message.isin);
    }
    if (message.issuerCountry !== "") {
      writer.uint32(42).string(message.issuerCountry);
    }
    if (message.quantity !== 0) {
      writer.uint32(48).int64(message.quantity);
    }
    if (message.dividend !== undefined) {
      Quotation.encode(message.dividend, writer.uint32(58).fork()).join();
    }
    if (message.externalCommission !== undefined) {
      Quotation.encode(message.externalCommission, writer.uint32(66).fork()).join();
    }
    if (message.dividendGross !== undefined) {
      Quotation.encode(message.dividendGross, writer.uint32(74).fork()).join();
    }
    if (message.tax !== undefined) {
      Quotation.encode(message.tax, writer.uint32(82).fork()).join();
    }
    if (message.dividendAmount !== undefined) {
      Quotation.encode(message.dividendAmount, writer.uint32(90).fork()).join();
    }
    if (message.currency !== "") {
      writer.uint32(98).string(message.currency);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DividendsForeignIssuerReport {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDividendsForeignIssuerReport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.recordDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.paymentDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.securityName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.isin = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.issuerCountry = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.quantity = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.dividend = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.externalCommission = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.dividendGross = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.tax = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.dividendAmount = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<DividendsForeignIssuerReport>): DividendsForeignIssuerReport {
    return DividendsForeignIssuerReport.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DividendsForeignIssuerReport>): DividendsForeignIssuerReport {
    const message = createBaseDividendsForeignIssuerReport();
    message.recordDate = object.recordDate ?? undefined;
    message.paymentDate = object.paymentDate ?? undefined;
    message.securityName = object.securityName ?? "";
    message.isin = object.isin ?? "";
    message.issuerCountry = object.issuerCountry ?? "";
    message.quantity = object.quantity ?? 0;
    message.dividend = (object.dividend !== undefined && object.dividend !== null)
      ? Quotation.fromPartial(object.dividend)
      : undefined;
    message.externalCommission = (object.externalCommission !== undefined && object.externalCommission !== null)
      ? Quotation.fromPartial(object.externalCommission)
      : undefined;
    message.dividendGross = (object.dividendGross !== undefined && object.dividendGross !== null)
      ? Quotation.fromPartial(object.dividendGross)
      : undefined;
    message.tax = (object.tax !== undefined && object.tax !== null) ? Quotation.fromPartial(object.tax) : undefined;
    message.dividendAmount = (object.dividendAmount !== undefined && object.dividendAmount !== null)
      ? Quotation.fromPartial(object.dividendAmount)
      : undefined;
    message.currency = object.currency ?? "";
    return message;
  },
};

function createBasePortfolioStreamRequest(): PortfolioStreamRequest {
  return { accounts: [], pingSettings: undefined };
}

export const PortfolioStreamRequest: OperationsUtils.MessageFns<PortfolioStreamRequest> = {
  encode(message: PortfolioStreamRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.accounts) {
      writer.uint32(10).string(v!);
    }
    if (message.pingSettings !== undefined) {
      PingDelaySettings.encode(message.pingSettings, writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PortfolioStreamRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePortfolioStreamRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accounts.push(reader.string());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.pingSettings = PingDelaySettings.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PortfolioStreamRequest>): PortfolioStreamRequest {
    return PortfolioStreamRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PortfolioStreamRequest>): PortfolioStreamRequest {
    const message = createBasePortfolioStreamRequest();
    message.accounts = object.accounts?.map((e) => e) || [];
    message.pingSettings = (object.pingSettings !== undefined && object.pingSettings !== null)
      ? PingDelaySettings.fromPartial(object.pingSettings)
      : undefined;
    return message;
  },
};

function createBasePortfolioStreamResponse(): PortfolioStreamResponse {
  return { subscriptions: undefined, portfolio: undefined, ping: undefined };
}

export const PortfolioStreamResponse: OperationsUtils.MessageFns<PortfolioStreamResponse> = {
  encode(message: PortfolioStreamResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subscriptions !== undefined) {
      PortfolioSubscriptionResult.encode(message.subscriptions, writer.uint32(10).fork()).join();
    }
    if (message.portfolio !== undefined) {
      PortfolioResponse.encode(message.portfolio, writer.uint32(18).fork()).join();
    }
    if (message.ping !== undefined) {
      Ping.encode(message.ping, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PortfolioStreamResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePortfolioStreamResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subscriptions = PortfolioSubscriptionResult.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.portfolio = PortfolioResponse.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ping = Ping.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PortfolioStreamResponse>): PortfolioStreamResponse {
    return PortfolioStreamResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PortfolioStreamResponse>): PortfolioStreamResponse {
    const message = createBasePortfolioStreamResponse();
    message.subscriptions = (object.subscriptions !== undefined && object.subscriptions !== null)
      ? PortfolioSubscriptionResult.fromPartial(object.subscriptions)
      : undefined;
    message.portfolio = (object.portfolio !== undefined && object.portfolio !== null)
      ? PortfolioResponse.fromPartial(object.portfolio)
      : undefined;
    message.ping = (object.ping !== undefined && object.ping !== null) ? Ping.fromPartial(object.ping) : undefined;
    return message;
  },
};

function createBasePortfolioSubscriptionResult(): PortfolioSubscriptionResult {
  return { accounts: [], trackingId: "", streamId: "" };
}

export const PortfolioSubscriptionResult: OperationsUtils.MessageFns<PortfolioSubscriptionResult> = {
  encode(message: PortfolioSubscriptionResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.accounts) {
      AccountSubscriptionStatus.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.trackingId !== "") {
      writer.uint32(58).string(message.trackingId);
    }
    if (message.streamId !== "") {
      writer.uint32(66).string(message.streamId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PortfolioSubscriptionResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePortfolioSubscriptionResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accounts.push(AccountSubscriptionStatus.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.trackingId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.streamId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PortfolioSubscriptionResult>): PortfolioSubscriptionResult {
    return PortfolioSubscriptionResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PortfolioSubscriptionResult>): PortfolioSubscriptionResult {
    const message = createBasePortfolioSubscriptionResult();
    message.accounts = object.accounts?.map((e) => AccountSubscriptionStatus.fromPartial(e)) || [];
    message.trackingId = object.trackingId ?? "";
    message.streamId = object.streamId ?? "";
    return message;
  },
};

function createBaseAccountSubscriptionStatus(): AccountSubscriptionStatus {
  return { accountId: "", subscriptionStatus: 0 };
}

export const AccountSubscriptionStatus: OperationsUtils.MessageFns<AccountSubscriptionStatus> = {
  encode(message: AccountSubscriptionStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== "") {
      writer.uint32(10).string(message.accountId);
    }
    if (message.subscriptionStatus !== 0) {
      writer.uint32(48).int32(message.subscriptionStatus);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountSubscriptionStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountSubscriptionStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.subscriptionStatus = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<AccountSubscriptionStatus>): AccountSubscriptionStatus {
    return AccountSubscriptionStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AccountSubscriptionStatus>): AccountSubscriptionStatus {
    const message = createBaseAccountSubscriptionStatus();
    message.accountId = object.accountId ?? "";
    message.subscriptionStatus = object.subscriptionStatus ?? 0;
    return message;
  },
};

function createBaseGetOperationsByCursorRequest(): GetOperationsByCursorRequest {
  return {
    accountId: "",
    instrumentId: undefined,
    from: undefined,
    to: undefined,
    cursor: undefined,
    limit: undefined,
    operationTypes: [],
    state: undefined,
    withoutCommissions: undefined,
    withoutTrades: undefined,
    withoutOvernights: undefined,
  };
}

export const GetOperationsByCursorRequest: OperationsUtils.MessageFns<GetOperationsByCursorRequest> = {
  encode(message: GetOperationsByCursorRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== "") {
      writer.uint32(10).string(message.accountId);
    }
    if (message.instrumentId !== undefined) {
      writer.uint32(18).string(message.instrumentId);
    }
    if (message.from !== undefined) {
      Timestamp.encode(toTimestamp(message.from), writer.uint32(50).fork()).join();
    }
    if (message.to !== undefined) {
      Timestamp.encode(toTimestamp(message.to), writer.uint32(58).fork()).join();
    }
    if (message.cursor !== undefined) {
      writer.uint32(90).string(message.cursor);
    }
    if (message.limit !== undefined) {
      writer.uint32(96).int32(message.limit);
    }
    writer.uint32(106).fork();
    for (const v of message.operationTypes) {
      writer.int32(v);
    }
    writer.join();
    if (message.state !== undefined) {
      writer.uint32(112).int32(message.state);
    }
    if (message.withoutCommissions !== undefined) {
      writer.uint32(120).bool(message.withoutCommissions);
    }
    if (message.withoutTrades !== undefined) {
      writer.uint32(128).bool(message.withoutTrades);
    }
    if (message.withoutOvernights !== undefined) {
      writer.uint32(136).bool(message.withoutOvernights);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOperationsByCursorRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOperationsByCursorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.instrumentId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.from = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.to = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.cursor = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 13: {
          if (tag === 104) {
            message.operationTypes.push(reader.int32() as any);

            continue;
          }

          if (tag === 106) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.operationTypes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.withoutCommissions = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.withoutTrades = reader.bool();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.withoutOvernights = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetOperationsByCursorRequest>): GetOperationsByCursorRequest {
    return GetOperationsByCursorRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetOperationsByCursorRequest>): GetOperationsByCursorRequest {
    const message = createBaseGetOperationsByCursorRequest();
    message.accountId = object.accountId ?? "";
    message.instrumentId = object.instrumentId ?? undefined;
    message.from = object.from ?? undefined;
    message.to = object.to ?? undefined;
    message.cursor = object.cursor ?? undefined;
    message.limit = object.limit ?? undefined;
    message.operationTypes = object.operationTypes?.map((e) => e) || [];
    message.state = object.state ?? undefined;
    message.withoutCommissions = object.withoutCommissions ?? undefined;
    message.withoutTrades = object.withoutTrades ?? undefined;
    message.withoutOvernights = object.withoutOvernights ?? undefined;
    return message;
  },
};

function createBaseGetOperationsByCursorResponse(): GetOperationsByCursorResponse {
  return { hasNext: false, nextCursor: "", items: [] };
}

export const GetOperationsByCursorResponse: OperationsUtils.MessageFns<GetOperationsByCursorResponse> = {
  encode(message: GetOperationsByCursorResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hasNext !== false) {
      writer.uint32(8).bool(message.hasNext);
    }
    if (message.nextCursor !== "") {
      writer.uint32(18).string(message.nextCursor);
    }
    for (const v of message.items) {
      OperationItem.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOperationsByCursorResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOperationsByCursorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.hasNext = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextCursor = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.items.push(OperationItem.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetOperationsByCursorResponse>): GetOperationsByCursorResponse {
    return GetOperationsByCursorResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetOperationsByCursorResponse>): GetOperationsByCursorResponse {
    const message = createBaseGetOperationsByCursorResponse();
    message.hasNext = object.hasNext ?? false;
    message.nextCursor = object.nextCursor ?? "";
    message.items = object.items?.map((e) => OperationItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOperationItem(): OperationItem {
  return {
    cursor: "",
    brokerAccountId: "",
    id: "",
    parentOperationId: "",
    name: "",
    date: undefined,
    type: 0,
    description: "",
    state: 0,
    instrumentUid: "",
    figi: "",
    instrumentType: "",
    instrumentKind: 0,
    positionUid: "",
    payment: undefined,
    price: undefined,
    commission: undefined,
    yield: undefined,
    yieldRelative: undefined,
    accruedInt: undefined,
    quantity: 0,
    quantityRest: 0,
    quantityDone: 0,
    cancelDateTime: undefined,
    cancelReason: "",
    tradesInfo: undefined,
    assetUid: "",
    childOperations: [],
  };
}

export const OperationItem: OperationsUtils.MessageFns<OperationItem> = {
  encode(message: OperationItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cursor !== "") {
      writer.uint32(10).string(message.cursor);
    }
    if (message.brokerAccountId !== "") {
      writer.uint32(50).string(message.brokerAccountId);
    }
    if (message.id !== "") {
      writer.uint32(130).string(message.id);
    }
    if (message.parentOperationId !== "") {
      writer.uint32(138).string(message.parentOperationId);
    }
    if (message.name !== "") {
      writer.uint32(146).string(message.name);
    }
    if (message.date !== undefined) {
      Timestamp.encode(toTimestamp(message.date), writer.uint32(170).fork()).join();
    }
    if (message.type !== 0) {
      writer.uint32(176).int32(message.type);
    }
    if (message.description !== "") {
      writer.uint32(186).string(message.description);
    }
    if (message.state !== 0) {
      writer.uint32(192).int32(message.state);
    }
    if (message.instrumentUid !== "") {
      writer.uint32(250).string(message.instrumentUid);
    }
    if (message.figi !== "") {
      writer.uint32(258).string(message.figi);
    }
    if (message.instrumentType !== "") {
      writer.uint32(266).string(message.instrumentType);
    }
    if (message.instrumentKind !== 0) {
      writer.uint32(272).int32(message.instrumentKind);
    }
    if (message.positionUid !== "") {
      writer.uint32(282).string(message.positionUid);
    }
    if (message.payment !== undefined) {
      MoneyValue.encode(message.payment, writer.uint32(330).fork()).join();
    }
    if (message.price !== undefined) {
      MoneyValue.encode(message.price, writer.uint32(338).fork()).join();
    }
    if (message.commission !== undefined) {
      MoneyValue.encode(message.commission, writer.uint32(346).fork()).join();
    }
    if (message.yield !== undefined) {
      MoneyValue.encode(message.yield, writer.uint32(354).fork()).join();
    }
    if (message.yieldRelative !== undefined) {
      Quotation.encode(message.yieldRelative, writer.uint32(362).fork()).join();
    }
    if (message.accruedInt !== undefined) {
      MoneyValue.encode(message.accruedInt, writer.uint32(370).fork()).join();
    }
    if (message.quantity !== 0) {
      writer.uint32(408).int64(message.quantity);
    }
    if (message.quantityRest !== 0) {
      writer.uint32(416).int64(message.quantityRest);
    }
    if (message.quantityDone !== 0) {
      writer.uint32(424).int64(message.quantityDone);
    }
    if (message.cancelDateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.cancelDateTime), writer.uint32(450).fork()).join();
    }
    if (message.cancelReason !== "") {
      writer.uint32(458).string(message.cancelReason);
    }
    if (message.tradesInfo !== undefined) {
      OperationItemTrades.encode(message.tradesInfo, writer.uint32(490).fork()).join();
    }
    if (message.assetUid !== "") {
      writer.uint32(514).string(message.assetUid);
    }
    for (const v of message.childOperations) {
      ChildOperationItem.encode(v!, writer.uint32(522).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperationItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cursor = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.brokerAccountId = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.parentOperationId = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.date = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 31: {
          if (tag !== 250) {
            break;
          }

          message.instrumentUid = reader.string();
          continue;
        }
        case 32: {
          if (tag !== 258) {
            break;
          }

          message.figi = reader.string();
          continue;
        }
        case 33: {
          if (tag !== 266) {
            break;
          }

          message.instrumentType = reader.string();
          continue;
        }
        case 34: {
          if (tag !== 272) {
            break;
          }

          message.instrumentKind = reader.int32() as any;
          continue;
        }
        case 35: {
          if (tag !== 282) {
            break;
          }

          message.positionUid = reader.string();
          continue;
        }
        case 41: {
          if (tag !== 330) {
            break;
          }

          message.payment = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 42: {
          if (tag !== 338) {
            break;
          }

          message.price = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 43: {
          if (tag !== 346) {
            break;
          }

          message.commission = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 44: {
          if (tag !== 354) {
            break;
          }

          message.yield = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 45: {
          if (tag !== 362) {
            break;
          }

          message.yieldRelative = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 46: {
          if (tag !== 370) {
            break;
          }

          message.accruedInt = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 51: {
          if (tag !== 408) {
            break;
          }

          message.quantity = longToNumber(reader.int64());
          continue;
        }
        case 52: {
          if (tag !== 416) {
            break;
          }

          message.quantityRest = longToNumber(reader.int64());
          continue;
        }
        case 53: {
          if (tag !== 424) {
            break;
          }

          message.quantityDone = longToNumber(reader.int64());
          continue;
        }
        case 56: {
          if (tag !== 450) {
            break;
          }

          message.cancelDateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 57: {
          if (tag !== 458) {
            break;
          }

          message.cancelReason = reader.string();
          continue;
        }
        case 61: {
          if (tag !== 490) {
            break;
          }

          message.tradesInfo = OperationItemTrades.decode(reader, reader.uint32());
          continue;
        }
        case 64: {
          if (tag !== 514) {
            break;
          }

          message.assetUid = reader.string();
          continue;
        }
        case 65: {
          if (tag !== 522) {
            break;
          }

          message.childOperations.push(ChildOperationItem.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<OperationItem>): OperationItem {
    return OperationItem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OperationItem>): OperationItem {
    const message = createBaseOperationItem();
    message.cursor = object.cursor ?? "";
    message.brokerAccountId = object.brokerAccountId ?? "";
    message.id = object.id ?? "";
    message.parentOperationId = object.parentOperationId ?? "";
    message.name = object.name ?? "";
    message.date = object.date ?? undefined;
    message.type = object.type ?? 0;
    message.description = object.description ?? "";
    message.state = object.state ?? 0;
    message.instrumentUid = object.instrumentUid ?? "";
    message.figi = object.figi ?? "";
    message.instrumentType = object.instrumentType ?? "";
    message.instrumentKind = object.instrumentKind ?? 0;
    message.positionUid = object.positionUid ?? "";
    message.payment = (object.payment !== undefined && object.payment !== null)
      ? MoneyValue.fromPartial(object.payment)
      : undefined;
    message.price = (object.price !== undefined && object.price !== null)
      ? MoneyValue.fromPartial(object.price)
      : undefined;
    message.commission = (object.commission !== undefined && object.commission !== null)
      ? MoneyValue.fromPartial(object.commission)
      : undefined;
    message.yield = (object.yield !== undefined && object.yield !== null)
      ? MoneyValue.fromPartial(object.yield)
      : undefined;
    message.yieldRelative = (object.yieldRelative !== undefined && object.yieldRelative !== null)
      ? Quotation.fromPartial(object.yieldRelative)
      : undefined;
    message.accruedInt = (object.accruedInt !== undefined && object.accruedInt !== null)
      ? MoneyValue.fromPartial(object.accruedInt)
      : undefined;
    message.quantity = object.quantity ?? 0;
    message.quantityRest = object.quantityRest ?? 0;
    message.quantityDone = object.quantityDone ?? 0;
    message.cancelDateTime = object.cancelDateTime ?? undefined;
    message.cancelReason = object.cancelReason ?? "";
    message.tradesInfo = (object.tradesInfo !== undefined && object.tradesInfo !== null)
      ? OperationItemTrades.fromPartial(object.tradesInfo)
      : undefined;
    message.assetUid = object.assetUid ?? "";
    message.childOperations = object.childOperations?.map((e) => ChildOperationItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOperationItemTrades(): OperationItemTrades {
  return { trades: [] };
}

export const OperationItemTrades: OperationsUtils.MessageFns<OperationItemTrades> = {
  encode(message: OperationItemTrades, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.trades) {
      OperationItemTrade.encode(v!, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperationItemTrades {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationItemTrades();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.trades.push(OperationItemTrade.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<OperationItemTrades>): OperationItemTrades {
    return OperationItemTrades.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OperationItemTrades>): OperationItemTrades {
    const message = createBaseOperationItemTrades();
    message.trades = object.trades?.map((e) => OperationItemTrade.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOperationItemTrade(): OperationItemTrade {
  return { num: "", date: undefined, quantity: 0, price: undefined, yield: undefined, yieldRelative: undefined };
}

export const OperationItemTrade: OperationsUtils.MessageFns<OperationItemTrade> = {
  encode(message: OperationItemTrade, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.num !== "") {
      writer.uint32(10).string(message.num);
    }
    if (message.date !== undefined) {
      Timestamp.encode(toTimestamp(message.date), writer.uint32(50).fork()).join();
    }
    if (message.quantity !== 0) {
      writer.uint32(88).int64(message.quantity);
    }
    if (message.price !== undefined) {
      MoneyValue.encode(message.price, writer.uint32(130).fork()).join();
    }
    if (message.yield !== undefined) {
      MoneyValue.encode(message.yield, writer.uint32(170).fork()).join();
    }
    if (message.yieldRelative !== undefined) {
      Quotation.encode(message.yieldRelative, writer.uint32(178).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OperationItemTrade {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOperationItemTrade();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.num = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.date = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.quantity = longToNumber(reader.int64());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.price = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.yield = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.yieldRelative = Quotation.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<OperationItemTrade>): OperationItemTrade {
    return OperationItemTrade.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OperationItemTrade>): OperationItemTrade {
    const message = createBaseOperationItemTrade();
    message.num = object.num ?? "";
    message.date = object.date ?? undefined;
    message.quantity = object.quantity ?? 0;
    message.price = (object.price !== undefined && object.price !== null)
      ? MoneyValue.fromPartial(object.price)
      : undefined;
    message.yield = (object.yield !== undefined && object.yield !== null)
      ? MoneyValue.fromPartial(object.yield)
      : undefined;
    message.yieldRelative = (object.yieldRelative !== undefined && object.yieldRelative !== null)
      ? Quotation.fromPartial(object.yieldRelative)
      : undefined;
    return message;
  },
};

function createBasePositionsStreamRequest(): PositionsStreamRequest {
  return { accounts: [], withInitialPositions: false, pingSettings: undefined };
}

export const PositionsStreamRequest: OperationsUtils.MessageFns<PositionsStreamRequest> = {
  encode(message: PositionsStreamRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.accounts) {
      writer.uint32(10).string(v!);
    }
    if (message.withInitialPositions !== false) {
      writer.uint32(24).bool(message.withInitialPositions);
    }
    if (message.pingSettings !== undefined) {
      PingDelaySettings.encode(message.pingSettings, writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PositionsStreamRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePositionsStreamRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accounts.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.withInitialPositions = reader.bool();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.pingSettings = PingDelaySettings.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PositionsStreamRequest>): PositionsStreamRequest {
    return PositionsStreamRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PositionsStreamRequest>): PositionsStreamRequest {
    const message = createBasePositionsStreamRequest();
    message.accounts = object.accounts?.map((e) => e) || [];
    message.withInitialPositions = object.withInitialPositions ?? false;
    message.pingSettings = (object.pingSettings !== undefined && object.pingSettings !== null)
      ? PingDelaySettings.fromPartial(object.pingSettings)
      : undefined;
    return message;
  },
};

function createBasePositionsStreamResponse(): PositionsStreamResponse {
  return { subscriptions: undefined, position: undefined, ping: undefined, initialPositions: undefined };
}

export const PositionsStreamResponse: OperationsUtils.MessageFns<PositionsStreamResponse> = {
  encode(message: PositionsStreamResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subscriptions !== undefined) {
      PositionsSubscriptionResult.encode(message.subscriptions, writer.uint32(10).fork()).join();
    }
    if (message.position !== undefined) {
      PositionData.encode(message.position, writer.uint32(18).fork()).join();
    }
    if (message.ping !== undefined) {
      Ping.encode(message.ping, writer.uint32(26).fork()).join();
    }
    if (message.initialPositions !== undefined) {
      PositionsResponse.encode(message.initialPositions, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PositionsStreamResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePositionsStreamResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subscriptions = PositionsSubscriptionResult.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.position = PositionData.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ping = Ping.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.initialPositions = PositionsResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PositionsStreamResponse>): PositionsStreamResponse {
    return PositionsStreamResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PositionsStreamResponse>): PositionsStreamResponse {
    const message = createBasePositionsStreamResponse();
    message.subscriptions = (object.subscriptions !== undefined && object.subscriptions !== null)
      ? PositionsSubscriptionResult.fromPartial(object.subscriptions)
      : undefined;
    message.position = (object.position !== undefined && object.position !== null)
      ? PositionData.fromPartial(object.position)
      : undefined;
    message.ping = (object.ping !== undefined && object.ping !== null) ? Ping.fromPartial(object.ping) : undefined;
    message.initialPositions = (object.initialPositions !== undefined && object.initialPositions !== null)
      ? PositionsResponse.fromPartial(object.initialPositions)
      : undefined;
    return message;
  },
};

function createBasePositionsSubscriptionResult(): PositionsSubscriptionResult {
  return { accounts: [], trackingId: "", streamId: "" };
}

export const PositionsSubscriptionResult: OperationsUtils.MessageFns<PositionsSubscriptionResult> = {
  encode(message: PositionsSubscriptionResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.accounts) {
      PositionsSubscriptionStatus.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.trackingId !== "") {
      writer.uint32(58).string(message.trackingId);
    }
    if (message.streamId !== "") {
      writer.uint32(66).string(message.streamId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PositionsSubscriptionResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePositionsSubscriptionResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accounts.push(PositionsSubscriptionStatus.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.trackingId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.streamId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PositionsSubscriptionResult>): PositionsSubscriptionResult {
    return PositionsSubscriptionResult.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PositionsSubscriptionResult>): PositionsSubscriptionResult {
    const message = createBasePositionsSubscriptionResult();
    message.accounts = object.accounts?.map((e) => PositionsSubscriptionStatus.fromPartial(e)) || [];
    message.trackingId = object.trackingId ?? "";
    message.streamId = object.streamId ?? "";
    return message;
  },
};

function createBasePositionsSubscriptionStatus(): PositionsSubscriptionStatus {
  return { accountId: "", subscriptionStatus: 0 };
}

export const PositionsSubscriptionStatus: OperationsUtils.MessageFns<PositionsSubscriptionStatus> = {
  encode(message: PositionsSubscriptionStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== "") {
      writer.uint32(10).string(message.accountId);
    }
    if (message.subscriptionStatus !== 0) {
      writer.uint32(48).int32(message.subscriptionStatus);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PositionsSubscriptionStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePositionsSubscriptionStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.subscriptionStatus = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PositionsSubscriptionStatus>): PositionsSubscriptionStatus {
    return PositionsSubscriptionStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PositionsSubscriptionStatus>): PositionsSubscriptionStatus {
    const message = createBasePositionsSubscriptionStatus();
    message.accountId = object.accountId ?? "";
    message.subscriptionStatus = object.subscriptionStatus ?? 0;
    return message;
  },
};

function createBasePositionData(): PositionData {
  return { accountId: "", money: [], securities: [], futures: [], options: [], date: undefined };
}

export const PositionData: OperationsUtils.MessageFns<PositionData> = {
  encode(message: PositionData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== "") {
      writer.uint32(10).string(message.accountId);
    }
    for (const v of message.money) {
      PositionsMoney.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.securities) {
      PositionsSecurities.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.futures) {
      PositionsFutures.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.options) {
      PositionsOptions.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.date !== undefined) {
      Timestamp.encode(toTimestamp(message.date), writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PositionData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePositionData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.money.push(PositionsMoney.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.securities.push(PositionsSecurities.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.futures.push(PositionsFutures.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.options.push(PositionsOptions.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.date = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PositionData>): PositionData {
    return PositionData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PositionData>): PositionData {
    const message = createBasePositionData();
    message.accountId = object.accountId ?? "";
    message.money = object.money?.map((e) => PositionsMoney.fromPartial(e)) || [];
    message.securities = object.securities?.map((e) => PositionsSecurities.fromPartial(e)) || [];
    message.futures = object.futures?.map((e) => PositionsFutures.fromPartial(e)) || [];
    message.options = object.options?.map((e) => PositionsOptions.fromPartial(e)) || [];
    message.date = object.date ?? undefined;
    return message;
  },
};

function createBasePositionsMoney(): PositionsMoney {
  return { availableValue: undefined, blockedValue: undefined };
}

export const PositionsMoney: OperationsUtils.MessageFns<PositionsMoney> = {
  encode(message: PositionsMoney, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.availableValue !== undefined) {
      MoneyValue.encode(message.availableValue, writer.uint32(10).fork()).join();
    }
    if (message.blockedValue !== undefined) {
      MoneyValue.encode(message.blockedValue, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PositionsMoney {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePositionsMoney();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.availableValue = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.blockedValue = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PositionsMoney>): PositionsMoney {
    return PositionsMoney.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PositionsMoney>): PositionsMoney {
    const message = createBasePositionsMoney();
    message.availableValue = (object.availableValue !== undefined && object.availableValue !== null)
      ? MoneyValue.fromPartial(object.availableValue)
      : undefined;
    message.blockedValue = (object.blockedValue !== undefined && object.blockedValue !== null)
      ? MoneyValue.fromPartial(object.blockedValue)
      : undefined;
    return message;
  },
};

function createBaseChildOperationItem(): ChildOperationItem {
  return { instrumentUid: "", payment: undefined };
}

export const ChildOperationItem: OperationsUtils.MessageFns<ChildOperationItem> = {
  encode(message: ChildOperationItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instrumentUid !== "") {
      writer.uint32(10).string(message.instrumentUid);
    }
    if (message.payment !== undefined) {
      MoneyValue.encode(message.payment, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChildOperationItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChildOperationItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.instrumentUid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.payment = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ChildOperationItem>): ChildOperationItem {
    return ChildOperationItem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ChildOperationItem>): ChildOperationItem {
    const message = createBaseChildOperationItem();
    message.instrumentUid = object.instrumentUid ?? "";
    message.payment = (object.payment !== undefined && object.payment !== null)
      ? MoneyValue.fromPartial(object.payment)
      : undefined;
    return message;
  },
};

/**
 * С помощью методов сервиса можно получить:</br></br> **1**. Список операций по счёту.</br> **2**.
 * Портфель по счёту.</br> **3**. Позиции ценных бумаг на счёте.</br> **4**.
 * Доступный остаток для вывода средств.</br> **5**. Различные отчёты.
 */
export type OperationsServiceDefinition = typeof OperationsServiceDefinition;
export const OperationsServiceDefinition = {
  name: "OperationsService",
  fullName: "tinkoff.public.invest.api.contract.v1.OperationsService",
  methods: {
    /**
     * Получить список операций по счёту. При работе с методом учитывайте
     * [особенности взаимодействия](/investAPI/operations_problems).
     */
    getOperations: {
      name: "GetOperations",
      requestType: OperationsRequest,
      requestStream: false,
      responseType: OperationsResponse,
      responseStream: false,
      options: {},
    },
    /** Получить портфель по счёту. */
    getPortfolio: {
      name: "GetPortfolio",
      requestType: PortfolioRequest,
      requestStream: false,
      responseType: PortfolioResponse,
      responseStream: false,
      options: {},
    },
    /** Получить список позиций по счёту. */
    getPositions: {
      name: "GetPositions",
      requestType: PositionsRequest,
      requestStream: false,
      responseType: PositionsResponse,
      responseStream: false,
      options: {},
    },
    /** Получить доступный остаток для вывода средств. */
    getWithdrawLimits: {
      name: "GetWithdrawLimits",
      requestType: WithdrawLimitsRequest,
      requestStream: false,
      responseType: WithdrawLimitsResponse,
      responseStream: false,
      options: {},
    },
    /** Получить брокерский отчёт. */
    getBrokerReport: {
      name: "GetBrokerReport",
      requestType: BrokerReportRequest,
      requestStream: false,
      responseType: BrokerReportResponse,
      responseStream: false,
      options: {},
    },
    /** Получить отчёт «Справка о доходах за пределами РФ». */
    getDividendsForeignIssuer: {
      name: "GetDividendsForeignIssuer",
      requestType: GetDividendsForeignIssuerRequest,
      requestStream: false,
      responseType: GetDividendsForeignIssuerResponse,
      responseStream: false,
      options: {},
    },
    /**
     * Получить список операций по счёту с пагинацией. При работе с методом учитывайте
     * [особенности взаимодействия](/investAPI/operations_problems).
     */
    getOperationsByCursor: {
      name: "GetOperationsByCursor",
      requestType: GetOperationsByCursorRequest,
      requestStream: false,
      responseType: GetOperationsByCursorResponse,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface OperationsServiceImplementation<CallContextExt = {}> {
  /**
   * Получить список операций по счёту. При работе с методом учитывайте
   * [особенности взаимодействия](/investAPI/operations_problems).
   */
  getOperations(
    request: OperationsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<OperationsResponse>>;
  /** Получить портфель по счёту. */
  getPortfolio(
    request: PortfolioRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<PortfolioResponse>>;
  /** Получить список позиций по счёту. */
  getPositions(
    request: PositionsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<PositionsResponse>>;
  /** Получить доступный остаток для вывода средств. */
  getWithdrawLimits(
    request: WithdrawLimitsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<WithdrawLimitsResponse>>;
  /** Получить брокерский отчёт. */
  getBrokerReport(
    request: BrokerReportRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<BrokerReportResponse>>;
  /** Получить отчёт «Справка о доходах за пределами РФ». */
  getDividendsForeignIssuer(
    request: GetDividendsForeignIssuerRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetDividendsForeignIssuerResponse>>;
  /**
   * Получить список операций по счёту с пагинацией. При работе с методом учитывайте
   * [особенности взаимодействия](/investAPI/operations_problems).
   */
  getOperationsByCursor(
    request: GetOperationsByCursorRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetOperationsByCursorResponse>>;
}

export interface OperationsServiceClient<CallOptionsExt = {}> {
  /**
   * Получить список операций по счёту. При работе с методом учитывайте
   * [особенности взаимодействия](/investAPI/operations_problems).
   */
  getOperations(
    request: DeepPartial<OperationsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<OperationsResponse>;
  /** Получить портфель по счёту. */
  getPortfolio(
    request: DeepPartial<PortfolioRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<PortfolioResponse>;
  /** Получить список позиций по счёту. */
  getPositions(
    request: DeepPartial<PositionsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<PositionsResponse>;
  /** Получить доступный остаток для вывода средств. */
  getWithdrawLimits(
    request: DeepPartial<WithdrawLimitsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<WithdrawLimitsResponse>;
  /** Получить брокерский отчёт. */
  getBrokerReport(
    request: DeepPartial<BrokerReportRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<BrokerReportResponse>;
  /** Получить отчёт «Справка о доходах за пределами РФ». */
  getDividendsForeignIssuer(
    request: DeepPartial<GetDividendsForeignIssuerRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetDividendsForeignIssuerResponse>;
  /**
   * Получить список операций по счёту с пагинацией. При работе с методом учитывайте
   * [особенности взаимодействия](/investAPI/operations_problems).
   */
  getOperationsByCursor(
    request: DeepPartial<GetOperationsByCursorRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetOperationsByCursorResponse>;
}

export type OperationsStreamServiceDefinition = typeof OperationsStreamServiceDefinition;
export const OperationsStreamServiceDefinition = {
  name: "OperationsStreamService",
  fullName: "tinkoff.public.invest.api.contract.v1.OperationsStreamService",
  methods: {
    /** Server-side stream обновлений портфеля. */
    portfolioStream: {
      name: "PortfolioStream",
      requestType: PortfolioStreamRequest,
      requestStream: false,
      responseType: PortfolioStreamResponse,
      responseStream: true,
      options: {},
    },
    /** Server-side stream обновлений информации по изменению позиций портфеля. */
    positionsStream: {
      name: "PositionsStream",
      requestType: PositionsStreamRequest,
      requestStream: false,
      responseType: PositionsStreamResponse,
      responseStream: true,
      options: {},
    },
  },
} as const;

export interface OperationsStreamServiceImplementation<CallContextExt = {}> {
  /** Server-side stream обновлений портфеля. */
  portfolioStream(
    request: PortfolioStreamRequest,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<DeepPartial<PortfolioStreamResponse>>;
  /** Server-side stream обновлений информации по изменению позиций портфеля. */
  positionsStream(
    request: PositionsStreamRequest,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<DeepPartial<PositionsStreamResponse>>;
}

export interface OperationsStreamServiceClient<CallOptionsExt = {}> {
  /** Server-side stream обновлений портфеля. */
  portfolioStream(
    request: DeepPartial<PortfolioStreamRequest>,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<PortfolioStreamResponse>;
  /** Server-side stream обновлений информации по изменению позиций портфеля. */
  positionsStream(
    request: DeepPartial<PositionsStreamRequest>,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<PositionsStreamResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

type ServerStreamingMethodResult<Response> = { [Symbol.asyncIterator](): AsyncIterator<Response, void> };

export declare namespace OperationsUtils {
 export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
}
