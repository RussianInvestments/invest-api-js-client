// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v3.19.1
// source: orders.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import {
  ErrorDetail,
  MoneyValue,
  Ping,
  PriceType,
  Quotation,
  ResponseMetadata,
  ResultSubscriptionStatus,
} from "./common";
import { Timestamp } from "./google/protobuf/timestamp";

/** Направление операции. */
export enum OrderDirection {
  /** ORDER_DIRECTION_UNSPECIFIED - Значение не указано */
  ORDER_DIRECTION_UNSPECIFIED = 0,
  /** ORDER_DIRECTION_BUY - Покупка */
  ORDER_DIRECTION_BUY = 1,
  /** ORDER_DIRECTION_SELL - Продажа */
  ORDER_DIRECTION_SELL = 2,
  UNRECOGNIZED = -1,
}

/** Тип заявки. */
export enum OrderType {
  /** ORDER_TYPE_UNSPECIFIED - Значение не указано */
  ORDER_TYPE_UNSPECIFIED = 0,
  /** ORDER_TYPE_LIMIT - Лимитная */
  ORDER_TYPE_LIMIT = 1,
  /** ORDER_TYPE_MARKET - Рыночная */
  ORDER_TYPE_MARKET = 2,
  /** ORDER_TYPE_BESTPRICE - Лучшая цена */
  ORDER_TYPE_BESTPRICE = 3,
  UNRECOGNIZED = -1,
}

/** Текущий статус заявки (поручения) */
export enum OrderExecutionReportStatus {
  EXECUTION_REPORT_STATUS_UNSPECIFIED = 0,
  /** EXECUTION_REPORT_STATUS_FILL - Исполнена */
  EXECUTION_REPORT_STATUS_FILL = 1,
  /** EXECUTION_REPORT_STATUS_REJECTED - Отклонена */
  EXECUTION_REPORT_STATUS_REJECTED = 2,
  /** EXECUTION_REPORT_STATUS_CANCELLED - Отменена пользователем */
  EXECUTION_REPORT_STATUS_CANCELLED = 3,
  /** EXECUTION_REPORT_STATUS_NEW - Новая */
  EXECUTION_REPORT_STATUS_NEW = 4,
  /** EXECUTION_REPORT_STATUS_PARTIALLYFILL - Частично исполнена */
  EXECUTION_REPORT_STATUS_PARTIALLYFILL = 5,
  UNRECOGNIZED = -1,
}

/** Алгоритм исполнения заявки */
export enum TimeInForceType {
  /** TIME_IN_FORCE_UNSPECIFIED - Значение не определено см. TIME_IN_FORCE_DAY */
  TIME_IN_FORCE_UNSPECIFIED = 0,
  /** TIME_IN_FORCE_DAY - Заявка действует до конца торгового дня. Значение по умолчанию */
  TIME_IN_FORCE_DAY = 1,
  /** TIME_IN_FORCE_FILL_AND_KILL - Если в момент выставления возможно исполнение заявки(в т.ч. частичное), заявка будет исполнена или отменена сразу после выставления */
  TIME_IN_FORCE_FILL_AND_KILL = 2,
  /** TIME_IN_FORCE_FILL_OR_KILL - Если в момент выставления возможно полное исполнение заявки, заявка будет исполнена или отменена сразу после выставления, недоступно для срочного рынка и торговли по выходным */
  TIME_IN_FORCE_FILL_OR_KILL = 3,
  UNRECOGNIZED = -1,
}

/** Тип идентификатора заявки */
export enum OrderIdType {
  /** ORDER_ID_TYPE_UNSPECIFIED - Тип идентификатора не указан. */
  ORDER_ID_TYPE_UNSPECIFIED = 0,
  /** ORDER_ID_TYPE_EXCHANGE - Биржевой идентификатор */
  ORDER_ID_TYPE_EXCHANGE = 1,
  /** ORDER_ID_TYPE_REQUEST - Ключ идемпотентности, переданный клиентом */
  ORDER_ID_TYPE_REQUEST = 2,
  UNRECOGNIZED = -1,
}

/** Запрос установки соединения. */
export interface TradesStreamRequest {
  /** Идентификаторы счетов. */
  accounts: string[];
  /** Задержка пинг сообщений milliseconds 5000-180000, default 120000 */
  pingDelayMs?: number | undefined;
}

/** Информация о торговых поручениях. */
export interface TradesStreamResponse {
  /** Информация об исполнении торгового поручения. */
  orderTrades?:
    | OrderTrades
    | undefined;
  /** Проверка активности стрима. */
  ping?:
    | Ping
    | undefined;
  /** Ответ на запрос на подписку. */
  subscription?: SubscriptionResponse | undefined;
}

/** Информация об исполнении торгового поручения. */
export interface OrderTrades {
  /** Идентификатор торгового поручения. */
  orderId: string;
  /** Дата и время создания сообщения в часовом поясе UTC. */
  createdAt:
    | Date
    | undefined;
  /** Направление сделки. */
  direction: OrderDirection;
  /** Figi-идентификатор инструмента. */
  figi: string;
  /** Массив сделок. */
  trades: OrderTrade[];
  /** Идентификатор счёта. */
  accountId: string;
  /** UID идентификатор инструмента. */
  instrumentUid: string;
}

/** Информация о сделке. */
export interface OrderTrade {
  /** Дата и время совершения сделки в часовом поясе UTC. */
  dateTime:
    | Date
    | undefined;
  /** Цена за 1 инструмент, по которой совершена сделка. */
  price:
    | Quotation
    | undefined;
  /** Количество штук в сделке. */
  quantity: number;
  /** Идентификатор сделки. */
  tradeId: string;
}

/** Запрос выставления торгового поручения. */
export interface PostOrderRequest {
  /**
   * Deprecated Figi-идентификатор инструмента. Необходимо использовать instrument_id.
   *
   * @deprecated
   */
  figi?:
    | string
    | undefined;
  /** Количество лотов. */
  quantity: number;
  /** Цена за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Игнорируется для рыночных поручений. */
  price?:
    | Quotation
    | undefined;
  /** Направление операции. */
  direction: OrderDirection;
  /** Номер счёта. */
  accountId: string;
  /** Тип заявки. */
  orderType: OrderType;
  /** Идентификатор запроса выставления поручения для целей идемпотентности в формате UID. Максимальная длина 36 символов. */
  orderId: string;
  /** Идентификатор инструмента, принимает значения Figi или Instrument_uid. */
  instrumentId: string;
  /** Алгоритм исполнения поручения, применяется только к лимитной заявке. */
  timeInForce: TimeInForceType;
  /** Тип цены. */
  priceType: PriceType;
}

/** Информация о выставлении поручения. */
export interface PostOrderResponse {
  /** Биржевой идентификатор заявки. */
  orderId: string;
  /** Текущий статус заявки. */
  executionReportStatus: OrderExecutionReportStatus;
  /** Запрошено лотов. */
  lotsRequested: number;
  /** Исполнено лотов. */
  lotsExecuted: number;
  /** Начальная цена заявки. Произведение количества запрошенных лотов на цену. */
  initialOrderPrice:
    | MoneyValue
    | undefined;
  /** Исполненная средняя цена одного инструмента в заявке. */
  executedOrderPrice:
    | MoneyValue
    | undefined;
  /** Итоговая стоимость заявки, включающая все комиссии. */
  totalOrderAmount:
    | MoneyValue
    | undefined;
  /** Начальная комиссия. Комиссия рассчитанная при выставлении заявки. */
  initialCommission:
    | MoneyValue
    | undefined;
  /** Фактическая комиссия по итогам исполнения заявки. */
  executedCommission:
    | MoneyValue
    | undefined;
  /** Значение НКД (накопленного купонного дохода) на дату. Подробнее: [НКД при выставлении торговых поручений](https://russianinvestments.github.io/investAPI/head-orders#coupon) */
  aciValue:
    | MoneyValue
    | undefined;
  /** Figi-идентификатор инструмента. */
  figi: string;
  /** Направление сделки. */
  direction: OrderDirection;
  /** Начальная цена за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. */
  initialSecurityPrice:
    | MoneyValue
    | undefined;
  /** Тип заявки. */
  orderType: OrderType;
  /** Дополнительные данные об исполнении заявки. */
  message: string;
  /** Начальная цена заявки в пунктах (для фьючерсов). */
  initialOrderPricePt:
    | Quotation
    | undefined;
  /** UID идентификатор инструмента. */
  instrumentUid: string;
  /** Идентификатор ключа идемпотентности, переданный клиентом, в формате UID. Максимальная длина 36 символов. */
  orderRequestId: string;
  /** Метадата */
  responseMetadata: ResponseMetadata | undefined;
}

/** Запрос выставления асинхронного торгового поручения. */
export interface PostOrderAsyncRequest {
  /** Идентификатор инструмента, принимает значения Figi или Instrument_uid. */
  instrumentId: string;
  /** Количество лотов. */
  quantity: number;
  /** Цена за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. Игнорируется для рыночных поручений. */
  price?:
    | Quotation
    | undefined;
  /** Направление операции. */
  direction: OrderDirection;
  /** Номер счёта. */
  accountId: string;
  /** Тип заявки. */
  orderType: OrderType;
  /** Идентификатор запроса выставления поручения для целей идемпотентности в формате UID. Максимальная длина 36 символов. */
  orderId: string;
  /** Алгоритм исполнения поручения, применяется только к лимитной заявке. */
  timeInForce?:
    | TimeInForceType
    | undefined;
  /** Тип цены. */
  priceType?: PriceType | undefined;
}

/** Результат выставления асинхронного торгового поручения. */
export interface PostOrderAsyncResponse {
  /** Идентификатор ключа идемпотентности, переданный клиентом, в формате UID. Максимальная длина 36 символов. */
  orderRequestId: string;
  /** Текущий статус заявки. */
  executionReportStatus: OrderExecutionReportStatus;
  /** Идентификатор торгового поручения. */
  tradeIntentId?: string | undefined;
}

/** Запрос отмены торгового поручения. */
export interface CancelOrderRequest {
  /** Номер счёта. */
  accountId: string;
  /** Идентификатор заявки. */
  orderId: string;
  /** Тип идентификатора заявки. */
  orderIdType?: OrderIdType | undefined;
}

/** Результат отмены торгового поручения. */
export interface CancelOrderResponse {
  /** Дата и время отмены заявки в часовом поясе UTC. */
  time:
    | Date
    | undefined;
  /** Метадата */
  responseMetadata: ResponseMetadata | undefined;
}

/** Запрос получения статуса торгового поручения. */
export interface GetOrderStateRequest {
  /** Номер счёта. */
  accountId: string;
  /** Идентификатор заявки. */
  orderId: string;
  /** Тип цены. */
  priceType: PriceType;
  /** Тип идентификатора заявки. */
  orderIdType?: OrderIdType | undefined;
}

/** Запрос получения списка активных торговых поручений. */
export interface GetOrdersRequest {
  /** Номер счёта. */
  accountId: string;
}

/** Список активных торговых поручений. */
export interface GetOrdersResponse {
  /** Массив активных заявок. */
  orders: OrderState[];
}

/** Информация о торговом поручении. */
export interface OrderState {
  /** Биржевой идентификатор заявки. */
  orderId: string;
  /** Текущий статус заявки. */
  executionReportStatus: OrderExecutionReportStatus;
  /** Запрошено лотов. */
  lotsRequested: number;
  /** Исполнено лотов. */
  lotsExecuted: number;
  /** Начальная цена заявки. Произведение количества запрошенных лотов на цену. */
  initialOrderPrice:
    | MoneyValue
    | undefined;
  /** Исполненная цена заявки. Произведение средней цены покупки на количество лотов. */
  executedOrderPrice:
    | MoneyValue
    | undefined;
  /** Итоговая стоимость заявки, включающая все комиссии. */
  totalOrderAmount:
    | MoneyValue
    | undefined;
  /** Средняя цена позиции по сделке. */
  averagePositionPrice:
    | MoneyValue
    | undefined;
  /** Начальная комиссия. Комиссия, рассчитанная на момент подачи заявки. */
  initialCommission:
    | MoneyValue
    | undefined;
  /** Фактическая комиссия по итогам исполнения заявки. */
  executedCommission:
    | MoneyValue
    | undefined;
  /** Figi-идентификатор инструмента. */
  figi: string;
  /** Направление заявки. */
  direction: OrderDirection;
  /** Начальная цена за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. */
  initialSecurityPrice:
    | MoneyValue
    | undefined;
  /** Стадии выполнения заявки. */
  stages: OrderStage[];
  /** Сервисная комиссия. */
  serviceCommission:
    | MoneyValue
    | undefined;
  /** Валюта заявки. */
  currency: string;
  /** Тип заявки. */
  orderType: OrderType;
  /** Дата и время выставления заявки в часовом поясе UTC. */
  orderDate:
    | Date
    | undefined;
  /** UID идентификатор инструмента. */
  instrumentUid: string;
  /** Идентификатор ключа идемпотентности, переданный клиентом, в формате UID. Максимальная длина 36 символов. */
  orderRequestId: string;
}

/** Сделки в рамках торгового поручения. */
export interface OrderStage {
  /** Цена за 1 инструмент. Для получения стоимости лота требуется умножить на лотность инструмента. */
  price:
    | MoneyValue
    | undefined;
  /** Количество лотов. */
  quantity: number;
  /** Идентификатор сделки. */
  tradeId: string;
  /** Время исполнения сделки */
  executionTime: Date | undefined;
}

/** Запрос изменения выставленной заявки. */
export interface ReplaceOrderRequest {
  /** Номер счета. */
  accountId: string;
  /** Идентификатор заявки на бирже. */
  orderId: string;
  /** Новый идентификатор запроса выставления поручения для целей идемпотентности. Максимальная длина 36 символов. Перезатирает старый ключ. */
  idempotencyKey: string;
  /** Количество лотов. */
  quantity: number;
  /** Цена за 1 инструмент. */
  price?:
    | Quotation
    | undefined;
  /** Тип цены. */
  priceType?: PriceType | undefined;
}

/** Запрос на расчет количества доступных для покупки/продажи лотов. Если не указывать цену инструмента, то расчет произведется по текущум ценам в стакане: по лучшему предложению для покупки и по лучшему спросу для продажи. */
export interface GetMaxLotsRequest {
  /** Номер счета */
  accountId: string;
  /** Идентификатор инструмента, принимает значения Figi или instrument_uid */
  instrumentId: string;
  /** Цена инструмента */
  price?: Quotation | undefined;
}

/** Результат количество доступных для покупки/продажи лотов */
export interface GetMaxLotsResponse {
  /** Валюта инструмента */
  currency: string;
  /** Лимиты для покупок на собственные деньги */
  buyLimits:
    | GetMaxLotsResponse_BuyLimitsView
    | undefined;
  /** Лимиты для покупок с учетом маржинального кредитования */
  buyMarginLimits:
    | GetMaxLotsResponse_BuyLimitsView
    | undefined;
  /** Лимиты для продаж по собственной позиции */
  sellLimits:
    | GetMaxLotsResponse_SellLimitsView
    | undefined;
  /** Лимиты для продаж с учетом маржинального кредитования */
  sellMarginLimits: GetMaxLotsResponse_SellLimitsView | undefined;
}

export interface GetMaxLotsResponse_BuyLimitsView {
  /** Количество доступной валюты для покупки */
  buyMoneyAmount:
    | Quotation
    | undefined;
  /** Максимальное доступное количество лотов для покупки */
  buyMaxLots: number;
  /** Максимальное доступное количество лотов для покупки для заявки по рыночной цене на текущий момент */
  buyMaxMarketLots: number;
}

export interface GetMaxLotsResponse_SellLimitsView {
  /** Максимальное доступное количество лотов для продажи */
  sellMaxLots: number;
}

/** Запрос получения предварительной стоимости заявки */
export interface GetOrderPriceRequest {
  /** Номер счета */
  accountId: string;
  /** Идентификатор инструмента, принимает значения Figi или instrument_uid */
  instrumentId: string;
  /** Цена инструмента */
  price:
    | Quotation
    | undefined;
  /** Направление заявки */
  direction: OrderDirection;
  /** Количество лотов */
  quantity: number;
}

/** Предварительная стоимость заявки */
export interface GetOrderPriceResponse {
  /** Итоговая стоимость заявки */
  totalOrderAmount:
    | MoneyValue
    | undefined;
  /** Стоимость заявки без комиссий, НКД, ГО (для фьючерсов — стоимость контрактов) */
  initialOrderAmount:
    | MoneyValue
    | undefined;
  /** Запрошено лотов */
  lotsRequested: number;
  /** Общая комиссия */
  executedCommission:
    | MoneyValue
    | undefined;
  /** Общая комиссия в рублях */
  executedCommissionRub:
    | MoneyValue
    | undefined;
  /** Сервисная комиссия */
  serviceCommission:
    | MoneyValue
    | undefined;
  /** Комиссия за проведение сделки */
  dealCommission:
    | MoneyValue
    | undefined;
  /** Дополнительная информация по облигациям */
  extraBond?:
    | GetOrderPriceResponse_ExtraBond
    | undefined;
  /** Дополнительная информация по фьючерсам */
  extraFuture?: GetOrderPriceResponse_ExtraFuture | undefined;
}

export interface GetOrderPriceResponse_ExtraBond {
  /** Значение НКД (накопленного купонного дохода) на дату */
  aciValue:
    | MoneyValue
    | undefined;
  /** Курс конвертации для замещающих облигаций */
  nominalConversionRate: Quotation | undefined;
}

export interface GetOrderPriceResponse_ExtraFuture {
  /** Гарантийное обеспечение для фьючерса */
  initialMargin: MoneyValue | undefined;
}

/** Запрос установки стрим-соединения торговых поручений */
export interface OrderStateStreamRequest {
  /** Идентификаторы счетов. */
  accounts: string[];
  /** Задержка пинг сообщений milliseconds 5000-180000, default 120000 */
  pingDelayMs?: number | undefined;
}

/** Информация по подпискам */
export interface SubscriptionResponse {
  /** Уникальный идентификатор запроса, подробнее: [tracking_id](https://russianinvestments.github.io/investAPI/grpc#tracking-id). */
  trackingId: string;
  /** Статус подписки. */
  status: ResultSubscriptionStatus;
  /** Идентификатор открытого соединения */
  streamId: string;
  /** Идентификаторы счетов. */
  accounts: string[];
  error?: ErrorDetail | undefined;
}

/** Информация по заявкам */
export interface OrderStateStreamResponse {
  /** Информация об исполнении торгового поручения. */
  orderState?:
    | OrderStateStreamResponse_OrderState
    | undefined;
  /** Проверка активности стрима. */
  ping?:
    | Ping
    | undefined;
  /** Ответ на запрос на подписку. */
  subscription?: SubscriptionResponse | undefined;
}

/** Маркер */
export enum OrderStateStreamResponse_MarkerType {
  /** MARKER_UNKNOWN - не определено */
  MARKER_UNKNOWN = 0,
  /** MARKER_BROKER - сделки брокера */
  MARKER_BROKER = 1,
  /** MARKER_CHAT - исполнение поручение, полученного от клиента через каналы связи */
  MARKER_CHAT = 2,
  /** MARKER_PAPER - исполнение поручение, полученного от клиента в бумажной форме */
  MARKER_PAPER = 3,
  /** MARKER_MARGIN - принудительное закрытие позиций */
  MARKER_MARGIN = 4,
  /** MARKER_TKBNM - сделки по управлению ликвидностью */
  MARKER_TKBNM = 5,
  /** MARKER_SHORT - сделки РЕПО по привлечению у клиентов бумаг */
  MARKER_SHORT = 6,
  /** MARKER_SPECMM - перенос временно непокрытых позиций */
  MARKER_SPECMM = 7,
  MARKER_PO = 8,
  UNRECOGNIZED = -1,
}

/** Дополнительная информация по статусу заявки */
export enum OrderStateStreamResponse_StatusCauseInfo {
  /** CAUSE_UNSPECIFIED - Не определено */
  CAUSE_UNSPECIFIED = 0,
  /** CAUSE_CANCELLED_BY_CLIENT - Отменено клиентом */
  CAUSE_CANCELLED_BY_CLIENT = 15,
  /** CAUSE_CANCELLED_BY_EXCHANGE - Отменено биржей */
  CAUSE_CANCELLED_BY_EXCHANGE = 1,
  /** CAUSE_CANCELLED_NOT_ENOUGH_POSITION - Заявка не выставлена из-за нехватки средств */
  CAUSE_CANCELLED_NOT_ENOUGH_POSITION = 2,
  /** CAUSE_CANCELLED_BY_CLIENT_BLOCK - Отменено из-за блокировки клиента */
  CAUSE_CANCELLED_BY_CLIENT_BLOCK = 3,
  /** CAUSE_REJECTED_BY_BROKER - Отклонено брокером */
  CAUSE_REJECTED_BY_BROKER = 4,
  /** CAUSE_REJECTED_BY_EXCHANGE - Отклонено биржей */
  CAUSE_REJECTED_BY_EXCHANGE = 5,
  /** CAUSE_CANCELLED_BY_BROKER - Отменено брокером */
  CAUSE_CANCELLED_BY_BROKER = 6,
  UNRECOGNIZED = -1,
}

/** Заявка */
export interface OrderStateStreamResponse_OrderState {
  /** Биржевой идентификатор заявки */
  orderId: string;
  /** Идентификатор ключа идемпотентности, переданный клиентом, в формате UID. Максимальная длина 36 символов. */
  orderRequestId?:
    | string
    | undefined;
  /** Код клиента на бирже */
  clientCode: string;
  /** Дата создания заявки */
  createdAt:
    | Date
    | undefined;
  /** Статус заявки */
  executionReportStatus: OrderExecutionReportStatus;
  /** Дополнительная информация по статусу */
  statusInfo?:
    | OrderStateStreamResponse_StatusCauseInfo
    | undefined;
  /** Тикер инструмента */
  ticker: string;
  /** Класс-код (секция торгов) */
  classCode: string;
  /** Лотность инструмента заявки */
  lotSize: number;
  /** Направление заявки */
  direction: OrderDirection;
  /** Алгоритм исполнения поручения */
  timeInForce: TimeInForceType;
  /** Тип заявки */
  orderType: OrderType;
  /** Номер счета */
  accountId: string;
  /** Начальная цена заявки */
  initialOrderPrice:
    | MoneyValue
    | undefined;
  /** Цена выставления заявки */
  orderPrice:
    | MoneyValue
    | undefined;
  /** Предрассчитанная стоимость полной заявки */
  amount?:
    | MoneyValue
    | undefined;
  /** Исполненная средняя цена одного инструмента в заявке */
  executedOrderPrice:
    | MoneyValue
    | undefined;
  /** Валюта исполнения */
  currency: string;
  /** Запрошено лотов */
  lotsRequested: number;
  /** Исполнено лотов */
  lotsExecuted: number;
  /** Число неисполненных лотов по заявке */
  lotsLeft: number;
  /** Отмененные лоты */
  lotsCancelled: number;
  /** Спецсимвол */
  marker?:
    | OrderStateStreamResponse_MarkerType
    | undefined;
  /** Список сделок */
  trades: OrderTrade[];
  /** Время исполнения заявки */
  completionTime:
    | Date
    | undefined;
  /** Код биржи */
  exchange: string;
  /** UID идентификатор инструмента */
  instrumentUid: string;
}

function createBaseTradesStreamRequest(): TradesStreamRequest {
  return { accounts: [], pingDelayMs: undefined };
}

export const TradesStreamRequest: MessageFns<TradesStreamRequest> = {
  encode(message: TradesStreamRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.accounts) {
      writer.uint32(10).string(v!);
    }
    if (message.pingDelayMs !== undefined) {
      writer.uint32(120).int32(message.pingDelayMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TradesStreamRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTradesStreamRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accounts.push(reader.string());
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.pingDelayMs = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<TradesStreamRequest>): TradesStreamRequest {
    return TradesStreamRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TradesStreamRequest>): TradesStreamRequest {
    const message = createBaseTradesStreamRequest();
    message.accounts = object.accounts?.map((e) => e) || [];
    message.pingDelayMs = object.pingDelayMs ?? undefined;
    return message;
  },
};

function createBaseTradesStreamResponse(): TradesStreamResponse {
  return { orderTrades: undefined, ping: undefined, subscription: undefined };
}

export const TradesStreamResponse: MessageFns<TradesStreamResponse> = {
  encode(message: TradesStreamResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderTrades !== undefined) {
      OrderTrades.encode(message.orderTrades, writer.uint32(10).fork()).join();
    }
    if (message.ping !== undefined) {
      Ping.encode(message.ping, writer.uint32(18).fork()).join();
    }
    if (message.subscription !== undefined) {
      SubscriptionResponse.encode(message.subscription, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TradesStreamResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTradesStreamResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderTrades = OrderTrades.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ping = Ping.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.subscription = SubscriptionResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<TradesStreamResponse>): TradesStreamResponse {
    return TradesStreamResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TradesStreamResponse>): TradesStreamResponse {
    const message = createBaseTradesStreamResponse();
    message.orderTrades = (object.orderTrades !== undefined && object.orderTrades !== null)
      ? OrderTrades.fromPartial(object.orderTrades)
      : undefined;
    message.ping = (object.ping !== undefined && object.ping !== null) ? Ping.fromPartial(object.ping) : undefined;
    message.subscription = (object.subscription !== undefined && object.subscription !== null)
      ? SubscriptionResponse.fromPartial(object.subscription)
      : undefined;
    return message;
  },
};

function createBaseOrderTrades(): OrderTrades {
  return { orderId: "", createdAt: undefined, direction: 0, figi: "", trades: [], accountId: "", instrumentUid: "" };
}

export const OrderTrades: MessageFns<OrderTrades> = {
  encode(message: OrderTrades, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(18).fork()).join();
    }
    if (message.direction !== 0) {
      writer.uint32(24).int32(message.direction);
    }
    if (message.figi !== "") {
      writer.uint32(34).string(message.figi);
    }
    for (const v of message.trades) {
      OrderTrade.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.accountId !== "") {
      writer.uint32(50).string(message.accountId);
    }
    if (message.instrumentUid !== "") {
      writer.uint32(58).string(message.instrumentUid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderTrades {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderTrades();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.direction = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.figi = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.trades.push(OrderTrade.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.accountId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.instrumentUid = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<OrderTrades>): OrderTrades {
    return OrderTrades.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OrderTrades>): OrderTrades {
    const message = createBaseOrderTrades();
    message.orderId = object.orderId ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.direction = object.direction ?? 0;
    message.figi = object.figi ?? "";
    message.trades = object.trades?.map((e) => OrderTrade.fromPartial(e)) || [];
    message.accountId = object.accountId ?? "";
    message.instrumentUid = object.instrumentUid ?? "";
    return message;
  },
};

function createBaseOrderTrade(): OrderTrade {
  return { dateTime: undefined, price: undefined, quantity: 0, tradeId: "" };
}

export const OrderTrade: MessageFns<OrderTrade> = {
  encode(message: OrderTrade, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dateTime !== undefined) {
      Timestamp.encode(toTimestamp(message.dateTime), writer.uint32(10).fork()).join();
    }
    if (message.price !== undefined) {
      Quotation.encode(message.price, writer.uint32(18).fork()).join();
    }
    if (message.quantity !== 0) {
      writer.uint32(24).int64(message.quantity);
    }
    if (message.tradeId !== "") {
      writer.uint32(34).string(message.tradeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderTrade {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderTrade();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.dateTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.price = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.quantity = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.tradeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<OrderTrade>): OrderTrade {
    return OrderTrade.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OrderTrade>): OrderTrade {
    const message = createBaseOrderTrade();
    message.dateTime = object.dateTime ?? undefined;
    message.price = (object.price !== undefined && object.price !== null)
      ? Quotation.fromPartial(object.price)
      : undefined;
    message.quantity = object.quantity ?? 0;
    message.tradeId = object.tradeId ?? "";
    return message;
  },
};

function createBasePostOrderRequest(): PostOrderRequest {
  return {
    figi: undefined,
    quantity: 0,
    price: undefined,
    direction: 0,
    accountId: "",
    orderType: 0,
    orderId: "",
    instrumentId: "",
    timeInForce: 0,
    priceType: 0,
  };
}

export const PostOrderRequest: MessageFns<PostOrderRequest> = {
  encode(message: PostOrderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.figi !== undefined) {
      writer.uint32(10).string(message.figi);
    }
    if (message.quantity !== 0) {
      writer.uint32(16).int64(message.quantity);
    }
    if (message.price !== undefined) {
      Quotation.encode(message.price, writer.uint32(26).fork()).join();
    }
    if (message.direction !== 0) {
      writer.uint32(32).int32(message.direction);
    }
    if (message.accountId !== "") {
      writer.uint32(42).string(message.accountId);
    }
    if (message.orderType !== 0) {
      writer.uint32(48).int32(message.orderType);
    }
    if (message.orderId !== "") {
      writer.uint32(58).string(message.orderId);
    }
    if (message.instrumentId !== "") {
      writer.uint32(66).string(message.instrumentId);
    }
    if (message.timeInForce !== 0) {
      writer.uint32(72).int32(message.timeInForce);
    }
    if (message.priceType !== 0) {
      writer.uint32(80).int32(message.priceType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostOrderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.figi = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.quantity = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.price = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.direction = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.accountId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.orderType = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.instrumentId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.timeInForce = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.priceType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PostOrderRequest>): PostOrderRequest {
    return PostOrderRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PostOrderRequest>): PostOrderRequest {
    const message = createBasePostOrderRequest();
    message.figi = object.figi ?? undefined;
    message.quantity = object.quantity ?? 0;
    message.price = (object.price !== undefined && object.price !== null)
      ? Quotation.fromPartial(object.price)
      : undefined;
    message.direction = object.direction ?? 0;
    message.accountId = object.accountId ?? "";
    message.orderType = object.orderType ?? 0;
    message.orderId = object.orderId ?? "";
    message.instrumentId = object.instrumentId ?? "";
    message.timeInForce = object.timeInForce ?? 0;
    message.priceType = object.priceType ?? 0;
    return message;
  },
};

function createBasePostOrderResponse(): PostOrderResponse {
  return {
    orderId: "",
    executionReportStatus: 0,
    lotsRequested: 0,
    lotsExecuted: 0,
    initialOrderPrice: undefined,
    executedOrderPrice: undefined,
    totalOrderAmount: undefined,
    initialCommission: undefined,
    executedCommission: undefined,
    aciValue: undefined,
    figi: "",
    direction: 0,
    initialSecurityPrice: undefined,
    orderType: 0,
    message: "",
    initialOrderPricePt: undefined,
    instrumentUid: "",
    orderRequestId: "",
    responseMetadata: undefined,
  };
}

export const PostOrderResponse: MessageFns<PostOrderResponse> = {
  encode(message: PostOrderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.executionReportStatus !== 0) {
      writer.uint32(16).int32(message.executionReportStatus);
    }
    if (message.lotsRequested !== 0) {
      writer.uint32(24).int64(message.lotsRequested);
    }
    if (message.lotsExecuted !== 0) {
      writer.uint32(32).int64(message.lotsExecuted);
    }
    if (message.initialOrderPrice !== undefined) {
      MoneyValue.encode(message.initialOrderPrice, writer.uint32(42).fork()).join();
    }
    if (message.executedOrderPrice !== undefined) {
      MoneyValue.encode(message.executedOrderPrice, writer.uint32(50).fork()).join();
    }
    if (message.totalOrderAmount !== undefined) {
      MoneyValue.encode(message.totalOrderAmount, writer.uint32(58).fork()).join();
    }
    if (message.initialCommission !== undefined) {
      MoneyValue.encode(message.initialCommission, writer.uint32(66).fork()).join();
    }
    if (message.executedCommission !== undefined) {
      MoneyValue.encode(message.executedCommission, writer.uint32(74).fork()).join();
    }
    if (message.aciValue !== undefined) {
      MoneyValue.encode(message.aciValue, writer.uint32(82).fork()).join();
    }
    if (message.figi !== "") {
      writer.uint32(90).string(message.figi);
    }
    if (message.direction !== 0) {
      writer.uint32(96).int32(message.direction);
    }
    if (message.initialSecurityPrice !== undefined) {
      MoneyValue.encode(message.initialSecurityPrice, writer.uint32(106).fork()).join();
    }
    if (message.orderType !== 0) {
      writer.uint32(112).int32(message.orderType);
    }
    if (message.message !== "") {
      writer.uint32(122).string(message.message);
    }
    if (message.initialOrderPricePt !== undefined) {
      Quotation.encode(message.initialOrderPricePt, writer.uint32(130).fork()).join();
    }
    if (message.instrumentUid !== "") {
      writer.uint32(138).string(message.instrumentUid);
    }
    if (message.orderRequestId !== "") {
      writer.uint32(162).string(message.orderRequestId);
    }
    if (message.responseMetadata !== undefined) {
      ResponseMetadata.encode(message.responseMetadata, writer.uint32(2034).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostOrderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.executionReportStatus = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.lotsRequested = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.lotsExecuted = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.initialOrderPrice = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.executedOrderPrice = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.totalOrderAmount = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.initialCommission = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.executedCommission = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.aciValue = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.figi = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.direction = reader.int32() as any;
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.initialSecurityPrice = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.orderType = reader.int32() as any;
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.initialOrderPricePt = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.instrumentUid = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.orderRequestId = reader.string();
          continue;
        }
        case 254: {
          if (tag !== 2034) {
            break;
          }

          message.responseMetadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PostOrderResponse>): PostOrderResponse {
    return PostOrderResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PostOrderResponse>): PostOrderResponse {
    const message = createBasePostOrderResponse();
    message.orderId = object.orderId ?? "";
    message.executionReportStatus = object.executionReportStatus ?? 0;
    message.lotsRequested = object.lotsRequested ?? 0;
    message.lotsExecuted = object.lotsExecuted ?? 0;
    message.initialOrderPrice = (object.initialOrderPrice !== undefined && object.initialOrderPrice !== null)
      ? MoneyValue.fromPartial(object.initialOrderPrice)
      : undefined;
    message.executedOrderPrice = (object.executedOrderPrice !== undefined && object.executedOrderPrice !== null)
      ? MoneyValue.fromPartial(object.executedOrderPrice)
      : undefined;
    message.totalOrderAmount = (object.totalOrderAmount !== undefined && object.totalOrderAmount !== null)
      ? MoneyValue.fromPartial(object.totalOrderAmount)
      : undefined;
    message.initialCommission = (object.initialCommission !== undefined && object.initialCommission !== null)
      ? MoneyValue.fromPartial(object.initialCommission)
      : undefined;
    message.executedCommission = (object.executedCommission !== undefined && object.executedCommission !== null)
      ? MoneyValue.fromPartial(object.executedCommission)
      : undefined;
    message.aciValue = (object.aciValue !== undefined && object.aciValue !== null)
      ? MoneyValue.fromPartial(object.aciValue)
      : undefined;
    message.figi = object.figi ?? "";
    message.direction = object.direction ?? 0;
    message.initialSecurityPrice = (object.initialSecurityPrice !== undefined && object.initialSecurityPrice !== null)
      ? MoneyValue.fromPartial(object.initialSecurityPrice)
      : undefined;
    message.orderType = object.orderType ?? 0;
    message.message = object.message ?? "";
    message.initialOrderPricePt = (object.initialOrderPricePt !== undefined && object.initialOrderPricePt !== null)
      ? Quotation.fromPartial(object.initialOrderPricePt)
      : undefined;
    message.instrumentUid = object.instrumentUid ?? "";
    message.orderRequestId = object.orderRequestId ?? "";
    message.responseMetadata = (object.responseMetadata !== undefined && object.responseMetadata !== null)
      ? ResponseMetadata.fromPartial(object.responseMetadata)
      : undefined;
    return message;
  },
};

function createBasePostOrderAsyncRequest(): PostOrderAsyncRequest {
  return {
    instrumentId: "",
    quantity: 0,
    price: undefined,
    direction: 0,
    accountId: "",
    orderType: 0,
    orderId: "",
    timeInForce: undefined,
    priceType: undefined,
  };
}

export const PostOrderAsyncRequest: MessageFns<PostOrderAsyncRequest> = {
  encode(message: PostOrderAsyncRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instrumentId !== "") {
      writer.uint32(10).string(message.instrumentId);
    }
    if (message.quantity !== 0) {
      writer.uint32(16).int64(message.quantity);
    }
    if (message.price !== undefined) {
      Quotation.encode(message.price, writer.uint32(26).fork()).join();
    }
    if (message.direction !== 0) {
      writer.uint32(32).int32(message.direction);
    }
    if (message.accountId !== "") {
      writer.uint32(42).string(message.accountId);
    }
    if (message.orderType !== 0) {
      writer.uint32(48).int32(message.orderType);
    }
    if (message.orderId !== "") {
      writer.uint32(58).string(message.orderId);
    }
    if (message.timeInForce !== undefined) {
      writer.uint32(64).int32(message.timeInForce);
    }
    if (message.priceType !== undefined) {
      writer.uint32(72).int32(message.priceType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostOrderAsyncRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostOrderAsyncRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.instrumentId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.quantity = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.price = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.direction = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.accountId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.orderType = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.timeInForce = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.priceType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PostOrderAsyncRequest>): PostOrderAsyncRequest {
    return PostOrderAsyncRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PostOrderAsyncRequest>): PostOrderAsyncRequest {
    const message = createBasePostOrderAsyncRequest();
    message.instrumentId = object.instrumentId ?? "";
    message.quantity = object.quantity ?? 0;
    message.price = (object.price !== undefined && object.price !== null)
      ? Quotation.fromPartial(object.price)
      : undefined;
    message.direction = object.direction ?? 0;
    message.accountId = object.accountId ?? "";
    message.orderType = object.orderType ?? 0;
    message.orderId = object.orderId ?? "";
    message.timeInForce = object.timeInForce ?? undefined;
    message.priceType = object.priceType ?? undefined;
    return message;
  },
};

function createBasePostOrderAsyncResponse(): PostOrderAsyncResponse {
  return { orderRequestId: "", executionReportStatus: 0, tradeIntentId: undefined };
}

export const PostOrderAsyncResponse: MessageFns<PostOrderAsyncResponse> = {
  encode(message: PostOrderAsyncResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderRequestId !== "") {
      writer.uint32(10).string(message.orderRequestId);
    }
    if (message.executionReportStatus !== 0) {
      writer.uint32(16).int32(message.executionReportStatus);
    }
    if (message.tradeIntentId !== undefined) {
      writer.uint32(26).string(message.tradeIntentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PostOrderAsyncResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePostOrderAsyncResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderRequestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.executionReportStatus = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tradeIntentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<PostOrderAsyncResponse>): PostOrderAsyncResponse {
    return PostOrderAsyncResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PostOrderAsyncResponse>): PostOrderAsyncResponse {
    const message = createBasePostOrderAsyncResponse();
    message.orderRequestId = object.orderRequestId ?? "";
    message.executionReportStatus = object.executionReportStatus ?? 0;
    message.tradeIntentId = object.tradeIntentId ?? undefined;
    return message;
  },
};

function createBaseCancelOrderRequest(): CancelOrderRequest {
  return { accountId: "", orderId: "", orderIdType: undefined };
}

export const CancelOrderRequest: MessageFns<CancelOrderRequest> = {
  encode(message: CancelOrderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== "") {
      writer.uint32(10).string(message.accountId);
    }
    if (message.orderId !== "") {
      writer.uint32(18).string(message.orderId);
    }
    if (message.orderIdType !== undefined) {
      writer.uint32(24).int32(message.orderIdType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelOrderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.orderIdType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<CancelOrderRequest>): CancelOrderRequest {
    return CancelOrderRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CancelOrderRequest>): CancelOrderRequest {
    const message = createBaseCancelOrderRequest();
    message.accountId = object.accountId ?? "";
    message.orderId = object.orderId ?? "";
    message.orderIdType = object.orderIdType ?? undefined;
    return message;
  },
};

function createBaseCancelOrderResponse(): CancelOrderResponse {
  return { time: undefined, responseMetadata: undefined };
}

export const CancelOrderResponse: MessageFns<CancelOrderResponse> = {
  encode(message: CancelOrderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.time !== undefined) {
      Timestamp.encode(toTimestamp(message.time), writer.uint32(10).fork()).join();
    }
    if (message.responseMetadata !== undefined) {
      ResponseMetadata.encode(message.responseMetadata, writer.uint32(2034).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CancelOrderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCancelOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 254: {
          if (tag !== 2034) {
            break;
          }

          message.responseMetadata = ResponseMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<CancelOrderResponse>): CancelOrderResponse {
    return CancelOrderResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CancelOrderResponse>): CancelOrderResponse {
    const message = createBaseCancelOrderResponse();
    message.time = object.time ?? undefined;
    message.responseMetadata = (object.responseMetadata !== undefined && object.responseMetadata !== null)
      ? ResponseMetadata.fromPartial(object.responseMetadata)
      : undefined;
    return message;
  },
};

function createBaseGetOrderStateRequest(): GetOrderStateRequest {
  return { accountId: "", orderId: "", priceType: 0, orderIdType: undefined };
}

export const GetOrderStateRequest: MessageFns<GetOrderStateRequest> = {
  encode(message: GetOrderStateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== "") {
      writer.uint32(10).string(message.accountId);
    }
    if (message.orderId !== "") {
      writer.uint32(18).string(message.orderId);
    }
    if (message.priceType !== 0) {
      writer.uint32(24).int32(message.priceType);
    }
    if (message.orderIdType !== undefined) {
      writer.uint32(32).int32(message.orderIdType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOrderStateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrderStateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.priceType = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.orderIdType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetOrderStateRequest>): GetOrderStateRequest {
    return GetOrderStateRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetOrderStateRequest>): GetOrderStateRequest {
    const message = createBaseGetOrderStateRequest();
    message.accountId = object.accountId ?? "";
    message.orderId = object.orderId ?? "";
    message.priceType = object.priceType ?? 0;
    message.orderIdType = object.orderIdType ?? undefined;
    return message;
  },
};

function createBaseGetOrdersRequest(): GetOrdersRequest {
  return { accountId: "" };
}

export const GetOrdersRequest: MessageFns<GetOrdersRequest> = {
  encode(message: GetOrdersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== "") {
      writer.uint32(10).string(message.accountId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOrdersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrdersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetOrdersRequest>): GetOrdersRequest {
    return GetOrdersRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetOrdersRequest>): GetOrdersRequest {
    const message = createBaseGetOrdersRequest();
    message.accountId = object.accountId ?? "";
    return message;
  },
};

function createBaseGetOrdersResponse(): GetOrdersResponse {
  return { orders: [] };
}

export const GetOrdersResponse: MessageFns<GetOrdersResponse> = {
  encode(message: GetOrdersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.orders) {
      OrderState.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOrdersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrdersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orders.push(OrderState.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetOrdersResponse>): GetOrdersResponse {
    return GetOrdersResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetOrdersResponse>): GetOrdersResponse {
    const message = createBaseGetOrdersResponse();
    message.orders = object.orders?.map((e) => OrderState.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOrderState(): OrderState {
  return {
    orderId: "",
    executionReportStatus: 0,
    lotsRequested: 0,
    lotsExecuted: 0,
    initialOrderPrice: undefined,
    executedOrderPrice: undefined,
    totalOrderAmount: undefined,
    averagePositionPrice: undefined,
    initialCommission: undefined,
    executedCommission: undefined,
    figi: "",
    direction: 0,
    initialSecurityPrice: undefined,
    stages: [],
    serviceCommission: undefined,
    currency: "",
    orderType: 0,
    orderDate: undefined,
    instrumentUid: "",
    orderRequestId: "",
  };
}

export const OrderState: MessageFns<OrderState> = {
  encode(message: OrderState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.executionReportStatus !== 0) {
      writer.uint32(16).int32(message.executionReportStatus);
    }
    if (message.lotsRequested !== 0) {
      writer.uint32(24).int64(message.lotsRequested);
    }
    if (message.lotsExecuted !== 0) {
      writer.uint32(32).int64(message.lotsExecuted);
    }
    if (message.initialOrderPrice !== undefined) {
      MoneyValue.encode(message.initialOrderPrice, writer.uint32(42).fork()).join();
    }
    if (message.executedOrderPrice !== undefined) {
      MoneyValue.encode(message.executedOrderPrice, writer.uint32(50).fork()).join();
    }
    if (message.totalOrderAmount !== undefined) {
      MoneyValue.encode(message.totalOrderAmount, writer.uint32(58).fork()).join();
    }
    if (message.averagePositionPrice !== undefined) {
      MoneyValue.encode(message.averagePositionPrice, writer.uint32(66).fork()).join();
    }
    if (message.initialCommission !== undefined) {
      MoneyValue.encode(message.initialCommission, writer.uint32(74).fork()).join();
    }
    if (message.executedCommission !== undefined) {
      MoneyValue.encode(message.executedCommission, writer.uint32(82).fork()).join();
    }
    if (message.figi !== "") {
      writer.uint32(90).string(message.figi);
    }
    if (message.direction !== 0) {
      writer.uint32(96).int32(message.direction);
    }
    if (message.initialSecurityPrice !== undefined) {
      MoneyValue.encode(message.initialSecurityPrice, writer.uint32(106).fork()).join();
    }
    for (const v of message.stages) {
      OrderStage.encode(v!, writer.uint32(114).fork()).join();
    }
    if (message.serviceCommission !== undefined) {
      MoneyValue.encode(message.serviceCommission, writer.uint32(122).fork()).join();
    }
    if (message.currency !== "") {
      writer.uint32(130).string(message.currency);
    }
    if (message.orderType !== 0) {
      writer.uint32(136).int32(message.orderType);
    }
    if (message.orderDate !== undefined) {
      Timestamp.encode(toTimestamp(message.orderDate), writer.uint32(146).fork()).join();
    }
    if (message.instrumentUid !== "") {
      writer.uint32(154).string(message.instrumentUid);
    }
    if (message.orderRequestId !== "") {
      writer.uint32(162).string(message.orderRequestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.executionReportStatus = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.lotsRequested = longToNumber(reader.int64());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.lotsExecuted = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.initialOrderPrice = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.executedOrderPrice = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.totalOrderAmount = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.averagePositionPrice = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.initialCommission = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.executedCommission = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.figi = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.direction = reader.int32() as any;
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.initialSecurityPrice = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.stages.push(OrderStage.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.serviceCommission = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.orderType = reader.int32() as any;
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.orderDate = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.instrumentUid = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.orderRequestId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<OrderState>): OrderState {
    return OrderState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OrderState>): OrderState {
    const message = createBaseOrderState();
    message.orderId = object.orderId ?? "";
    message.executionReportStatus = object.executionReportStatus ?? 0;
    message.lotsRequested = object.lotsRequested ?? 0;
    message.lotsExecuted = object.lotsExecuted ?? 0;
    message.initialOrderPrice = (object.initialOrderPrice !== undefined && object.initialOrderPrice !== null)
      ? MoneyValue.fromPartial(object.initialOrderPrice)
      : undefined;
    message.executedOrderPrice = (object.executedOrderPrice !== undefined && object.executedOrderPrice !== null)
      ? MoneyValue.fromPartial(object.executedOrderPrice)
      : undefined;
    message.totalOrderAmount = (object.totalOrderAmount !== undefined && object.totalOrderAmount !== null)
      ? MoneyValue.fromPartial(object.totalOrderAmount)
      : undefined;
    message.averagePositionPrice = (object.averagePositionPrice !== undefined && object.averagePositionPrice !== null)
      ? MoneyValue.fromPartial(object.averagePositionPrice)
      : undefined;
    message.initialCommission = (object.initialCommission !== undefined && object.initialCommission !== null)
      ? MoneyValue.fromPartial(object.initialCommission)
      : undefined;
    message.executedCommission = (object.executedCommission !== undefined && object.executedCommission !== null)
      ? MoneyValue.fromPartial(object.executedCommission)
      : undefined;
    message.figi = object.figi ?? "";
    message.direction = object.direction ?? 0;
    message.initialSecurityPrice = (object.initialSecurityPrice !== undefined && object.initialSecurityPrice !== null)
      ? MoneyValue.fromPartial(object.initialSecurityPrice)
      : undefined;
    message.stages = object.stages?.map((e) => OrderStage.fromPartial(e)) || [];
    message.serviceCommission = (object.serviceCommission !== undefined && object.serviceCommission !== null)
      ? MoneyValue.fromPartial(object.serviceCommission)
      : undefined;
    message.currency = object.currency ?? "";
    message.orderType = object.orderType ?? 0;
    message.orderDate = object.orderDate ?? undefined;
    message.instrumentUid = object.instrumentUid ?? "";
    message.orderRequestId = object.orderRequestId ?? "";
    return message;
  },
};

function createBaseOrderStage(): OrderStage {
  return { price: undefined, quantity: 0, tradeId: "", executionTime: undefined };
}

export const OrderStage: MessageFns<OrderStage> = {
  encode(message: OrderStage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.price !== undefined) {
      MoneyValue.encode(message.price, writer.uint32(10).fork()).join();
    }
    if (message.quantity !== 0) {
      writer.uint32(16).int64(message.quantity);
    }
    if (message.tradeId !== "") {
      writer.uint32(26).string(message.tradeId);
    }
    if (message.executionTime !== undefined) {
      Timestamp.encode(toTimestamp(message.executionTime), writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderStage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderStage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.price = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.quantity = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.tradeId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.executionTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<OrderStage>): OrderStage {
    return OrderStage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OrderStage>): OrderStage {
    const message = createBaseOrderStage();
    message.price = (object.price !== undefined && object.price !== null)
      ? MoneyValue.fromPartial(object.price)
      : undefined;
    message.quantity = object.quantity ?? 0;
    message.tradeId = object.tradeId ?? "";
    message.executionTime = object.executionTime ?? undefined;
    return message;
  },
};

function createBaseReplaceOrderRequest(): ReplaceOrderRequest {
  return { accountId: "", orderId: "", idempotencyKey: "", quantity: 0, price: undefined, priceType: undefined };
}

export const ReplaceOrderRequest: MessageFns<ReplaceOrderRequest> = {
  encode(message: ReplaceOrderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== "") {
      writer.uint32(10).string(message.accountId);
    }
    if (message.orderId !== "") {
      writer.uint32(50).string(message.orderId);
    }
    if (message.idempotencyKey !== "") {
      writer.uint32(58).string(message.idempotencyKey);
    }
    if (message.quantity !== 0) {
      writer.uint32(88).int64(message.quantity);
    }
    if (message.price !== undefined) {
      Quotation.encode(message.price, writer.uint32(98).fork()).join();
    }
    if (message.priceType !== undefined) {
      writer.uint32(104).int32(message.priceType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReplaceOrderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReplaceOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.idempotencyKey = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.quantity = longToNumber(reader.int64());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.price = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.priceType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<ReplaceOrderRequest>): ReplaceOrderRequest {
    return ReplaceOrderRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReplaceOrderRequest>): ReplaceOrderRequest {
    const message = createBaseReplaceOrderRequest();
    message.accountId = object.accountId ?? "";
    message.orderId = object.orderId ?? "";
    message.idempotencyKey = object.idempotencyKey ?? "";
    message.quantity = object.quantity ?? 0;
    message.price = (object.price !== undefined && object.price !== null)
      ? Quotation.fromPartial(object.price)
      : undefined;
    message.priceType = object.priceType ?? undefined;
    return message;
  },
};

function createBaseGetMaxLotsRequest(): GetMaxLotsRequest {
  return { accountId: "", instrumentId: "", price: undefined };
}

export const GetMaxLotsRequest: MessageFns<GetMaxLotsRequest> = {
  encode(message: GetMaxLotsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== "") {
      writer.uint32(10).string(message.accountId);
    }
    if (message.instrumentId !== "") {
      writer.uint32(18).string(message.instrumentId);
    }
    if (message.price !== undefined) {
      Quotation.encode(message.price, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMaxLotsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMaxLotsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.instrumentId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.price = Quotation.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetMaxLotsRequest>): GetMaxLotsRequest {
    return GetMaxLotsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetMaxLotsRequest>): GetMaxLotsRequest {
    const message = createBaseGetMaxLotsRequest();
    message.accountId = object.accountId ?? "";
    message.instrumentId = object.instrumentId ?? "";
    message.price = (object.price !== undefined && object.price !== null)
      ? Quotation.fromPartial(object.price)
      : undefined;
    return message;
  },
};

function createBaseGetMaxLotsResponse(): GetMaxLotsResponse {
  return {
    currency: "",
    buyLimits: undefined,
    buyMarginLimits: undefined,
    sellLimits: undefined,
    sellMarginLimits: undefined,
  };
}

export const GetMaxLotsResponse: MessageFns<GetMaxLotsResponse> = {
  encode(message: GetMaxLotsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.currency !== "") {
      writer.uint32(10).string(message.currency);
    }
    if (message.buyLimits !== undefined) {
      GetMaxLotsResponse_BuyLimitsView.encode(message.buyLimits, writer.uint32(18).fork()).join();
    }
    if (message.buyMarginLimits !== undefined) {
      GetMaxLotsResponse_BuyLimitsView.encode(message.buyMarginLimits, writer.uint32(26).fork()).join();
    }
    if (message.sellLimits !== undefined) {
      GetMaxLotsResponse_SellLimitsView.encode(message.sellLimits, writer.uint32(34).fork()).join();
    }
    if (message.sellMarginLimits !== undefined) {
      GetMaxLotsResponse_SellLimitsView.encode(message.sellMarginLimits, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMaxLotsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMaxLotsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.buyLimits = GetMaxLotsResponse_BuyLimitsView.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.buyMarginLimits = GetMaxLotsResponse_BuyLimitsView.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sellLimits = GetMaxLotsResponse_SellLimitsView.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.sellMarginLimits = GetMaxLotsResponse_SellLimitsView.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetMaxLotsResponse>): GetMaxLotsResponse {
    return GetMaxLotsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetMaxLotsResponse>): GetMaxLotsResponse {
    const message = createBaseGetMaxLotsResponse();
    message.currency = object.currency ?? "";
    message.buyLimits = (object.buyLimits !== undefined && object.buyLimits !== null)
      ? GetMaxLotsResponse_BuyLimitsView.fromPartial(object.buyLimits)
      : undefined;
    message.buyMarginLimits = (object.buyMarginLimits !== undefined && object.buyMarginLimits !== null)
      ? GetMaxLotsResponse_BuyLimitsView.fromPartial(object.buyMarginLimits)
      : undefined;
    message.sellLimits = (object.sellLimits !== undefined && object.sellLimits !== null)
      ? GetMaxLotsResponse_SellLimitsView.fromPartial(object.sellLimits)
      : undefined;
    message.sellMarginLimits = (object.sellMarginLimits !== undefined && object.sellMarginLimits !== null)
      ? GetMaxLotsResponse_SellLimitsView.fromPartial(object.sellMarginLimits)
      : undefined;
    return message;
  },
};

function createBaseGetMaxLotsResponse_BuyLimitsView(): GetMaxLotsResponse_BuyLimitsView {
  return { buyMoneyAmount: undefined, buyMaxLots: 0, buyMaxMarketLots: 0 };
}

export const GetMaxLotsResponse_BuyLimitsView: MessageFns<GetMaxLotsResponse_BuyLimitsView> = {
  encode(message: GetMaxLotsResponse_BuyLimitsView, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.buyMoneyAmount !== undefined) {
      Quotation.encode(message.buyMoneyAmount, writer.uint32(10).fork()).join();
    }
    if (message.buyMaxLots !== 0) {
      writer.uint32(16).int64(message.buyMaxLots);
    }
    if (message.buyMaxMarketLots !== 0) {
      writer.uint32(24).int64(message.buyMaxMarketLots);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMaxLotsResponse_BuyLimitsView {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMaxLotsResponse_BuyLimitsView();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.buyMoneyAmount = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.buyMaxLots = longToNumber(reader.int64());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.buyMaxMarketLots = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetMaxLotsResponse_BuyLimitsView>): GetMaxLotsResponse_BuyLimitsView {
    return GetMaxLotsResponse_BuyLimitsView.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetMaxLotsResponse_BuyLimitsView>): GetMaxLotsResponse_BuyLimitsView {
    const message = createBaseGetMaxLotsResponse_BuyLimitsView();
    message.buyMoneyAmount = (object.buyMoneyAmount !== undefined && object.buyMoneyAmount !== null)
      ? Quotation.fromPartial(object.buyMoneyAmount)
      : undefined;
    message.buyMaxLots = object.buyMaxLots ?? 0;
    message.buyMaxMarketLots = object.buyMaxMarketLots ?? 0;
    return message;
  },
};

function createBaseGetMaxLotsResponse_SellLimitsView(): GetMaxLotsResponse_SellLimitsView {
  return { sellMaxLots: 0 };
}

export const GetMaxLotsResponse_SellLimitsView: MessageFns<GetMaxLotsResponse_SellLimitsView> = {
  encode(message: GetMaxLotsResponse_SellLimitsView, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sellMaxLots !== 0) {
      writer.uint32(8).int64(message.sellMaxLots);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMaxLotsResponse_SellLimitsView {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMaxLotsResponse_SellLimitsView();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.sellMaxLots = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetMaxLotsResponse_SellLimitsView>): GetMaxLotsResponse_SellLimitsView {
    return GetMaxLotsResponse_SellLimitsView.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetMaxLotsResponse_SellLimitsView>): GetMaxLotsResponse_SellLimitsView {
    const message = createBaseGetMaxLotsResponse_SellLimitsView();
    message.sellMaxLots = object.sellMaxLots ?? 0;
    return message;
  },
};

function createBaseGetOrderPriceRequest(): GetOrderPriceRequest {
  return { accountId: "", instrumentId: "", price: undefined, direction: 0, quantity: 0 };
}

export const GetOrderPriceRequest: MessageFns<GetOrderPriceRequest> = {
  encode(message: GetOrderPriceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountId !== "") {
      writer.uint32(10).string(message.accountId);
    }
    if (message.instrumentId !== "") {
      writer.uint32(18).string(message.instrumentId);
    }
    if (message.price !== undefined) {
      Quotation.encode(message.price, writer.uint32(26).fork()).join();
    }
    if (message.direction !== 0) {
      writer.uint32(96).int32(message.direction);
    }
    if (message.quantity !== 0) {
      writer.uint32(104).int64(message.quantity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOrderPriceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrderPriceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.instrumentId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.price = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.direction = reader.int32() as any;
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.quantity = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetOrderPriceRequest>): GetOrderPriceRequest {
    return GetOrderPriceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetOrderPriceRequest>): GetOrderPriceRequest {
    const message = createBaseGetOrderPriceRequest();
    message.accountId = object.accountId ?? "";
    message.instrumentId = object.instrumentId ?? "";
    message.price = (object.price !== undefined && object.price !== null)
      ? Quotation.fromPartial(object.price)
      : undefined;
    message.direction = object.direction ?? 0;
    message.quantity = object.quantity ?? 0;
    return message;
  },
};

function createBaseGetOrderPriceResponse(): GetOrderPriceResponse {
  return {
    totalOrderAmount: undefined,
    initialOrderAmount: undefined,
    lotsRequested: 0,
    executedCommission: undefined,
    executedCommissionRub: undefined,
    serviceCommission: undefined,
    dealCommission: undefined,
    extraBond: undefined,
    extraFuture: undefined,
  };
}

export const GetOrderPriceResponse: MessageFns<GetOrderPriceResponse> = {
  encode(message: GetOrderPriceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalOrderAmount !== undefined) {
      MoneyValue.encode(message.totalOrderAmount, writer.uint32(10).fork()).join();
    }
    if (message.initialOrderAmount !== undefined) {
      MoneyValue.encode(message.initialOrderAmount, writer.uint32(42).fork()).join();
    }
    if (message.lotsRequested !== 0) {
      writer.uint32(24).int64(message.lotsRequested);
    }
    if (message.executedCommission !== undefined) {
      MoneyValue.encode(message.executedCommission, writer.uint32(58).fork()).join();
    }
    if (message.executedCommissionRub !== undefined) {
      MoneyValue.encode(message.executedCommissionRub, writer.uint32(66).fork()).join();
    }
    if (message.serviceCommission !== undefined) {
      MoneyValue.encode(message.serviceCommission, writer.uint32(74).fork()).join();
    }
    if (message.dealCommission !== undefined) {
      MoneyValue.encode(message.dealCommission, writer.uint32(82).fork()).join();
    }
    if (message.extraBond !== undefined) {
      GetOrderPriceResponse_ExtraBond.encode(message.extraBond, writer.uint32(98).fork()).join();
    }
    if (message.extraFuture !== undefined) {
      GetOrderPriceResponse_ExtraFuture.encode(message.extraFuture, writer.uint32(106).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOrderPriceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrderPriceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.totalOrderAmount = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.initialOrderAmount = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.lotsRequested = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.executedCommission = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.executedCommissionRub = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.serviceCommission = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.dealCommission = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.extraBond = GetOrderPriceResponse_ExtraBond.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.extraFuture = GetOrderPriceResponse_ExtraFuture.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetOrderPriceResponse>): GetOrderPriceResponse {
    return GetOrderPriceResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetOrderPriceResponse>): GetOrderPriceResponse {
    const message = createBaseGetOrderPriceResponse();
    message.totalOrderAmount = (object.totalOrderAmount !== undefined && object.totalOrderAmount !== null)
      ? MoneyValue.fromPartial(object.totalOrderAmount)
      : undefined;
    message.initialOrderAmount = (object.initialOrderAmount !== undefined && object.initialOrderAmount !== null)
      ? MoneyValue.fromPartial(object.initialOrderAmount)
      : undefined;
    message.lotsRequested = object.lotsRequested ?? 0;
    message.executedCommission = (object.executedCommission !== undefined && object.executedCommission !== null)
      ? MoneyValue.fromPartial(object.executedCommission)
      : undefined;
    message.executedCommissionRub =
      (object.executedCommissionRub !== undefined && object.executedCommissionRub !== null)
        ? MoneyValue.fromPartial(object.executedCommissionRub)
        : undefined;
    message.serviceCommission = (object.serviceCommission !== undefined && object.serviceCommission !== null)
      ? MoneyValue.fromPartial(object.serviceCommission)
      : undefined;
    message.dealCommission = (object.dealCommission !== undefined && object.dealCommission !== null)
      ? MoneyValue.fromPartial(object.dealCommission)
      : undefined;
    message.extraBond = (object.extraBond !== undefined && object.extraBond !== null)
      ? GetOrderPriceResponse_ExtraBond.fromPartial(object.extraBond)
      : undefined;
    message.extraFuture = (object.extraFuture !== undefined && object.extraFuture !== null)
      ? GetOrderPriceResponse_ExtraFuture.fromPartial(object.extraFuture)
      : undefined;
    return message;
  },
};

function createBaseGetOrderPriceResponse_ExtraBond(): GetOrderPriceResponse_ExtraBond {
  return { aciValue: undefined, nominalConversionRate: undefined };
}

export const GetOrderPriceResponse_ExtraBond: MessageFns<GetOrderPriceResponse_ExtraBond> = {
  encode(message: GetOrderPriceResponse_ExtraBond, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.aciValue !== undefined) {
      MoneyValue.encode(message.aciValue, writer.uint32(18).fork()).join();
    }
    if (message.nominalConversionRate !== undefined) {
      Quotation.encode(message.nominalConversionRate, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOrderPriceResponse_ExtraBond {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrderPriceResponse_ExtraBond();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.aciValue = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nominalConversionRate = Quotation.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetOrderPriceResponse_ExtraBond>): GetOrderPriceResponse_ExtraBond {
    return GetOrderPriceResponse_ExtraBond.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetOrderPriceResponse_ExtraBond>): GetOrderPriceResponse_ExtraBond {
    const message = createBaseGetOrderPriceResponse_ExtraBond();
    message.aciValue = (object.aciValue !== undefined && object.aciValue !== null)
      ? MoneyValue.fromPartial(object.aciValue)
      : undefined;
    message.nominalConversionRate =
      (object.nominalConversionRate !== undefined && object.nominalConversionRate !== null)
        ? Quotation.fromPartial(object.nominalConversionRate)
        : undefined;
    return message;
  },
};

function createBaseGetOrderPriceResponse_ExtraFuture(): GetOrderPriceResponse_ExtraFuture {
  return { initialMargin: undefined };
}

export const GetOrderPriceResponse_ExtraFuture: MessageFns<GetOrderPriceResponse_ExtraFuture> = {
  encode(message: GetOrderPriceResponse_ExtraFuture, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.initialMargin !== undefined) {
      MoneyValue.encode(message.initialMargin, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOrderPriceResponse_ExtraFuture {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrderPriceResponse_ExtraFuture();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.initialMargin = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetOrderPriceResponse_ExtraFuture>): GetOrderPriceResponse_ExtraFuture {
    return GetOrderPriceResponse_ExtraFuture.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetOrderPriceResponse_ExtraFuture>): GetOrderPriceResponse_ExtraFuture {
    const message = createBaseGetOrderPriceResponse_ExtraFuture();
    message.initialMargin = (object.initialMargin !== undefined && object.initialMargin !== null)
      ? MoneyValue.fromPartial(object.initialMargin)
      : undefined;
    return message;
  },
};

function createBaseOrderStateStreamRequest(): OrderStateStreamRequest {
  return { accounts: [], pingDelayMs: undefined };
}

export const OrderStateStreamRequest: MessageFns<OrderStateStreamRequest> = {
  encode(message: OrderStateStreamRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.accounts) {
      writer.uint32(10).string(v!);
    }
    if (message.pingDelayMs !== undefined) {
      writer.uint32(120).int32(message.pingDelayMs);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderStateStreamRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderStateStreamRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accounts.push(reader.string());
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.pingDelayMs = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<OrderStateStreamRequest>): OrderStateStreamRequest {
    return OrderStateStreamRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OrderStateStreamRequest>): OrderStateStreamRequest {
    const message = createBaseOrderStateStreamRequest();
    message.accounts = object.accounts?.map((e) => e) || [];
    message.pingDelayMs = object.pingDelayMs ?? undefined;
    return message;
  },
};

function createBaseSubscriptionResponse(): SubscriptionResponse {
  return { trackingId: "", status: 0, streamId: "", accounts: [], error: undefined };
}

export const SubscriptionResponse: MessageFns<SubscriptionResponse> = {
  encode(message: SubscriptionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trackingId !== "") {
      writer.uint32(10).string(message.trackingId);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.streamId !== "") {
      writer.uint32(34).string(message.streamId);
    }
    for (const v of message.accounts) {
      writer.uint32(42).string(v!);
    }
    if (message.error !== undefined) {
      ErrorDetail.encode(message.error, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscriptionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscriptionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trackingId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.streamId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.accounts.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.error = ErrorDetail.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SubscriptionResponse>): SubscriptionResponse {
    return SubscriptionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubscriptionResponse>): SubscriptionResponse {
    const message = createBaseSubscriptionResponse();
    message.trackingId = object.trackingId ?? "";
    message.status = object.status ?? 0;
    message.streamId = object.streamId ?? "";
    message.accounts = object.accounts?.map((e) => e) || [];
    message.error = (object.error !== undefined && object.error !== null)
      ? ErrorDetail.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function createBaseOrderStateStreamResponse(): OrderStateStreamResponse {
  return { orderState: undefined, ping: undefined, subscription: undefined };
}

export const OrderStateStreamResponse: MessageFns<OrderStateStreamResponse> = {
  encode(message: OrderStateStreamResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderState !== undefined) {
      OrderStateStreamResponse_OrderState.encode(message.orderState, writer.uint32(10).fork()).join();
    }
    if (message.ping !== undefined) {
      Ping.encode(message.ping, writer.uint32(18).fork()).join();
    }
    if (message.subscription !== undefined) {
      SubscriptionResponse.encode(message.subscription, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderStateStreamResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderStateStreamResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderState = OrderStateStreamResponse_OrderState.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ping = Ping.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.subscription = SubscriptionResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<OrderStateStreamResponse>): OrderStateStreamResponse {
    return OrderStateStreamResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OrderStateStreamResponse>): OrderStateStreamResponse {
    const message = createBaseOrderStateStreamResponse();
    message.orderState = (object.orderState !== undefined && object.orderState !== null)
      ? OrderStateStreamResponse_OrderState.fromPartial(object.orderState)
      : undefined;
    message.ping = (object.ping !== undefined && object.ping !== null) ? Ping.fromPartial(object.ping) : undefined;
    message.subscription = (object.subscription !== undefined && object.subscription !== null)
      ? SubscriptionResponse.fromPartial(object.subscription)
      : undefined;
    return message;
  },
};

function createBaseOrderStateStreamResponse_OrderState(): OrderStateStreamResponse_OrderState {
  return {
    orderId: "",
    orderRequestId: undefined,
    clientCode: "",
    createdAt: undefined,
    executionReportStatus: 0,
    statusInfo: undefined,
    ticker: "",
    classCode: "",
    lotSize: 0,
    direction: 0,
    timeInForce: 0,
    orderType: 0,
    accountId: "",
    initialOrderPrice: undefined,
    orderPrice: undefined,
    amount: undefined,
    executedOrderPrice: undefined,
    currency: "",
    lotsRequested: 0,
    lotsExecuted: 0,
    lotsLeft: 0,
    lotsCancelled: 0,
    marker: undefined,
    trades: [],
    completionTime: undefined,
    exchange: "",
    instrumentUid: "",
  };
}

export const OrderStateStreamResponse_OrderState: MessageFns<OrderStateStreamResponse_OrderState> = {
  encode(message: OrderStateStreamResponse_OrderState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orderId !== "") {
      writer.uint32(10).string(message.orderId);
    }
    if (message.orderRequestId !== undefined) {
      writer.uint32(18).string(message.orderRequestId);
    }
    if (message.clientCode !== "") {
      writer.uint32(26).string(message.clientCode);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(34).fork()).join();
    }
    if (message.executionReportStatus !== 0) {
      writer.uint32(40).int32(message.executionReportStatus);
    }
    if (message.statusInfo !== undefined) {
      writer.uint32(48).int32(message.statusInfo);
    }
    if (message.ticker !== "") {
      writer.uint32(58).string(message.ticker);
    }
    if (message.classCode !== "") {
      writer.uint32(66).string(message.classCode);
    }
    if (message.lotSize !== 0) {
      writer.uint32(72).int32(message.lotSize);
    }
    if (message.direction !== 0) {
      writer.uint32(80).int32(message.direction);
    }
    if (message.timeInForce !== 0) {
      writer.uint32(88).int32(message.timeInForce);
    }
    if (message.orderType !== 0) {
      writer.uint32(96).int32(message.orderType);
    }
    if (message.accountId !== "") {
      writer.uint32(106).string(message.accountId);
    }
    if (message.initialOrderPrice !== undefined) {
      MoneyValue.encode(message.initialOrderPrice, writer.uint32(178).fork()).join();
    }
    if (message.orderPrice !== undefined) {
      MoneyValue.encode(message.orderPrice, writer.uint32(186).fork()).join();
    }
    if (message.amount !== undefined) {
      MoneyValue.encode(message.amount, writer.uint32(194).fork()).join();
    }
    if (message.executedOrderPrice !== undefined) {
      MoneyValue.encode(message.executedOrderPrice, writer.uint32(202).fork()).join();
    }
    if (message.currency !== "") {
      writer.uint32(210).string(message.currency);
    }
    if (message.lotsRequested !== 0) {
      writer.uint32(216).int64(message.lotsRequested);
    }
    if (message.lotsExecuted !== 0) {
      writer.uint32(224).int64(message.lotsExecuted);
    }
    if (message.lotsLeft !== 0) {
      writer.uint32(232).int64(message.lotsLeft);
    }
    if (message.lotsCancelled !== 0) {
      writer.uint32(240).int64(message.lotsCancelled);
    }
    if (message.marker !== undefined) {
      writer.uint32(248).int32(message.marker);
    }
    for (const v of message.trades) {
      OrderTrade.encode(v!, writer.uint32(266).fork()).join();
    }
    if (message.completionTime !== undefined) {
      Timestamp.encode(toTimestamp(message.completionTime), writer.uint32(282).fork()).join();
    }
    if (message.exchange !== "") {
      writer.uint32(290).string(message.exchange);
    }
    if (message.instrumentUid !== "") {
      writer.uint32(330).string(message.instrumentUid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderStateStreamResponse_OrderState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderStateStreamResponse_OrderState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.orderId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.orderRequestId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clientCode = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.executionReportStatus = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.statusInfo = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.ticker = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.classCode = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.lotSize = reader.int32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.direction = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.timeInForce = reader.int32() as any;
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.orderType = reader.int32() as any;
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.accountId = reader.string();
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.initialOrderPrice = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.orderPrice = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.amount = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 25: {
          if (tag !== 202) {
            break;
          }

          message.executedOrderPrice = MoneyValue.decode(reader, reader.uint32());
          continue;
        }
        case 26: {
          if (tag !== 210) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 27: {
          if (tag !== 216) {
            break;
          }

          message.lotsRequested = longToNumber(reader.int64());
          continue;
        }
        case 28: {
          if (tag !== 224) {
            break;
          }

          message.lotsExecuted = longToNumber(reader.int64());
          continue;
        }
        case 29: {
          if (tag !== 232) {
            break;
          }

          message.lotsLeft = longToNumber(reader.int64());
          continue;
        }
        case 30: {
          if (tag !== 240) {
            break;
          }

          message.lotsCancelled = longToNumber(reader.int64());
          continue;
        }
        case 31: {
          if (tag !== 248) {
            break;
          }

          message.marker = reader.int32() as any;
          continue;
        }
        case 33: {
          if (tag !== 266) {
            break;
          }

          message.trades.push(OrderTrade.decode(reader, reader.uint32()));
          continue;
        }
        case 35: {
          if (tag !== 282) {
            break;
          }

          message.completionTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 36: {
          if (tag !== 290) {
            break;
          }

          message.exchange = reader.string();
          continue;
        }
        case 41: {
          if (tag !== 330) {
            break;
          }

          message.instrumentUid = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<OrderStateStreamResponse_OrderState>): OrderStateStreamResponse_OrderState {
    return OrderStateStreamResponse_OrderState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OrderStateStreamResponse_OrderState>): OrderStateStreamResponse_OrderState {
    const message = createBaseOrderStateStreamResponse_OrderState();
    message.orderId = object.orderId ?? "";
    message.orderRequestId = object.orderRequestId ?? undefined;
    message.clientCode = object.clientCode ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.executionReportStatus = object.executionReportStatus ?? 0;
    message.statusInfo = object.statusInfo ?? undefined;
    message.ticker = object.ticker ?? "";
    message.classCode = object.classCode ?? "";
    message.lotSize = object.lotSize ?? 0;
    message.direction = object.direction ?? 0;
    message.timeInForce = object.timeInForce ?? 0;
    message.orderType = object.orderType ?? 0;
    message.accountId = object.accountId ?? "";
    message.initialOrderPrice = (object.initialOrderPrice !== undefined && object.initialOrderPrice !== null)
      ? MoneyValue.fromPartial(object.initialOrderPrice)
      : undefined;
    message.orderPrice = (object.orderPrice !== undefined && object.orderPrice !== null)
      ? MoneyValue.fromPartial(object.orderPrice)
      : undefined;
    message.amount = (object.amount !== undefined && object.amount !== null)
      ? MoneyValue.fromPartial(object.amount)
      : undefined;
    message.executedOrderPrice = (object.executedOrderPrice !== undefined && object.executedOrderPrice !== null)
      ? MoneyValue.fromPartial(object.executedOrderPrice)
      : undefined;
    message.currency = object.currency ?? "";
    message.lotsRequested = object.lotsRequested ?? 0;
    message.lotsExecuted = object.lotsExecuted ?? 0;
    message.lotsLeft = object.lotsLeft ?? 0;
    message.lotsCancelled = object.lotsCancelled ?? 0;
    message.marker = object.marker ?? undefined;
    message.trades = object.trades?.map((e) => OrderTrade.fromPartial(e)) || [];
    message.completionTime = object.completionTime ?? undefined;
    message.exchange = object.exchange ?? "";
    message.instrumentUid = object.instrumentUid ?? "";
    return message;
  },
};

export type OrdersStreamServiceDefinition = typeof OrdersStreamServiceDefinition;
export const OrdersStreamServiceDefinition = {
  name: "OrdersStreamService",
  fullName: "tinkoff.public.invest.api.contract.v1.OrdersStreamService",
  methods: {
    /** Stream сделок пользователя */
    tradesStream: {
      name: "TradesStream",
      requestType: TradesStreamRequest,
      requestStream: false,
      responseType: TradesStreamResponse,
      responseStream: true,
      options: {},
    },
    /** Stream поручений пользователя. Перед работой прочитайте [статью](https://russianinvestments.github.io/investAPI/orders_state_stream/). */
    orderStateStream: {
      name: "OrderStateStream",
      requestType: OrderStateStreamRequest,
      requestStream: false,
      responseType: OrderStateStreamResponse,
      responseStream: true,
      options: {},
    },
  },
} as const;

export interface OrdersStreamServiceImplementation<CallContextExt = {}> {
  /** Stream сделок пользователя */
  tradesStream(
    request: TradesStreamRequest,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<DeepPartial<TradesStreamResponse>>;
  /** Stream поручений пользователя. Перед работой прочитайте [статью](https://russianinvestments.github.io/investAPI/orders_state_stream/). */
  orderStateStream(
    request: OrderStateStreamRequest,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<DeepPartial<OrderStateStreamResponse>>;
}

export interface OrdersStreamServiceClient<CallOptionsExt = {}> {
  /** Stream сделок пользователя */
  tradesStream(
    request: DeepPartial<TradesStreamRequest>,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<TradesStreamResponse>;
  /** Stream поручений пользователя. Перед работой прочитайте [статью](https://russianinvestments.github.io/investAPI/orders_state_stream/). */
  orderStateStream(
    request: DeepPartial<OrderStateStreamRequest>,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<OrderStateStreamResponse>;
}

/**
 * Сервис предназначен для работы с торговыми поручениями:</br> **1**.
 * выставление;</br> **2**. отмена;</br> **3**. получение статуса;</br> **4**.
 * расчёт полной стоимости;</br> **5**. получение списка заявок.
 */
export type OrdersServiceDefinition = typeof OrdersServiceDefinition;
export const OrdersServiceDefinition = {
  name: "OrdersService",
  fullName: "tinkoff.public.invest.api.contract.v1.OrdersService",
  methods: {
    /** Метод выставления заявки. */
    postOrder: {
      name: "PostOrder",
      requestType: PostOrderRequest,
      requestStream: false,
      responseType: PostOrderResponse,
      responseStream: false,
      options: {},
    },
    /** Асинхронный метод выставления заявки. */
    postOrderAsync: {
      name: "PostOrderAsync",
      requestType: PostOrderAsyncRequest,
      requestStream: false,
      responseType: PostOrderAsyncResponse,
      responseStream: false,
      options: {},
    },
    /** Метод отмены биржевой заявки. */
    cancelOrder: {
      name: "CancelOrder",
      requestType: CancelOrderRequest,
      requestStream: false,
      responseType: CancelOrderResponse,
      responseStream: false,
      options: {},
    },
    /** Метод получения статуса торгового поручения. */
    getOrderState: {
      name: "GetOrderState",
      requestType: GetOrderStateRequest,
      requestStream: false,
      responseType: OrderState,
      responseStream: false,
      options: {},
    },
    /** Метод получения списка активных заявок по счёту. */
    getOrders: {
      name: "GetOrders",
      requestType: GetOrdersRequest,
      requestStream: false,
      responseType: GetOrdersResponse,
      responseStream: false,
      options: {},
    },
    /** Метод изменения выставленной заявки. */
    replaceOrder: {
      name: "ReplaceOrder",
      requestType: ReplaceOrderRequest,
      requestStream: false,
      responseType: PostOrderResponse,
      responseStream: false,
      options: {},
    },
    /** расчет количества доступных для покупки/продажи лотов */
    getMaxLots: {
      name: "GetMaxLots",
      requestType: GetMaxLotsRequest,
      requestStream: false,
      responseType: GetMaxLotsResponse,
      responseStream: false,
      options: {},
    },
    /** Метод получения предварительной стоимости для лимитной заявки */
    getOrderPrice: {
      name: "GetOrderPrice",
      requestType: GetOrderPriceRequest,
      requestStream: false,
      responseType: GetOrderPriceResponse,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface OrdersServiceImplementation<CallContextExt = {}> {
  /** Метод выставления заявки. */
  postOrder(request: PostOrderRequest, context: CallContext & CallContextExt): Promise<DeepPartial<PostOrderResponse>>;
  /** Асинхронный метод выставления заявки. */
  postOrderAsync(
    request: PostOrderAsyncRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<PostOrderAsyncResponse>>;
  /** Метод отмены биржевой заявки. */
  cancelOrder(
    request: CancelOrderRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<CancelOrderResponse>>;
  /** Метод получения статуса торгового поручения. */
  getOrderState(request: GetOrderStateRequest, context: CallContext & CallContextExt): Promise<DeepPartial<OrderState>>;
  /** Метод получения списка активных заявок по счёту. */
  getOrders(request: GetOrdersRequest, context: CallContext & CallContextExt): Promise<DeepPartial<GetOrdersResponse>>;
  /** Метод изменения выставленной заявки. */
  replaceOrder(
    request: ReplaceOrderRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<PostOrderResponse>>;
  /** расчет количества доступных для покупки/продажи лотов */
  getMaxLots(
    request: GetMaxLotsRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetMaxLotsResponse>>;
  /** Метод получения предварительной стоимости для лимитной заявки */
  getOrderPrice(
    request: GetOrderPriceRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetOrderPriceResponse>>;
}

export interface OrdersServiceClient<CallOptionsExt = {}> {
  /** Метод выставления заявки. */
  postOrder(request: DeepPartial<PostOrderRequest>, options?: CallOptions & CallOptionsExt): Promise<PostOrderResponse>;
  /** Асинхронный метод выставления заявки. */
  postOrderAsync(
    request: DeepPartial<PostOrderAsyncRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<PostOrderAsyncResponse>;
  /** Метод отмены биржевой заявки. */
  cancelOrder(
    request: DeepPartial<CancelOrderRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<CancelOrderResponse>;
  /** Метод получения статуса торгового поручения. */
  getOrderState(
    request: DeepPartial<GetOrderStateRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<OrderState>;
  /** Метод получения списка активных заявок по счёту. */
  getOrders(request: DeepPartial<GetOrdersRequest>, options?: CallOptions & CallOptionsExt): Promise<GetOrdersResponse>;
  /** Метод изменения выставленной заявки. */
  replaceOrder(
    request: DeepPartial<ReplaceOrderRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<PostOrderResponse>;
  /** расчет количества доступных для покупки/продажи лотов */
  getMaxLots(
    request: DeepPartial<GetMaxLotsRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetMaxLotsResponse>;
  /** Метод получения предварительной стоимости для лимитной заявки */
  getOrderPrice(
    request: DeepPartial<GetOrderPriceRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetOrderPriceResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

type ServerStreamingMethodResult<Response> = { [Symbol.asyncIterator](): AsyncIterator<Response, void> };

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
