// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v3.19.1
// source: marketdata.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { type CallContext, type CallOptions } from "nice-grpc-common";
import { InstrumentStatus, Ping, PingDelaySettings, PingRequest, Quotation, SecurityTradingStatus } from "./common";
import { Timestamp } from "./google/protobuf/timestamp";

/** Тип операции со списком подписок. */
export enum SubscriptionAction {
  /** SUBSCRIPTION_ACTION_UNSPECIFIED - Статус подписки не определён. */
  SUBSCRIPTION_ACTION_UNSPECIFIED = 0,
  /** SUBSCRIPTION_ACTION_SUBSCRIBE - Подписаться. */
  SUBSCRIPTION_ACTION_SUBSCRIBE = 1,
  /** SUBSCRIPTION_ACTION_UNSUBSCRIBE - Отписаться. */
  SUBSCRIPTION_ACTION_UNSUBSCRIBE = 2,
  UNRECOGNIZED = -1,
}

/** Интервал свечи. */
export enum SubscriptionInterval {
  /** SUBSCRIPTION_INTERVAL_UNSPECIFIED - Интервал свечи не определён. */
  SUBSCRIPTION_INTERVAL_UNSPECIFIED = 0,
  /** SUBSCRIPTION_INTERVAL_ONE_MINUTE - Минутные свечи. */
  SUBSCRIPTION_INTERVAL_ONE_MINUTE = 1,
  /** SUBSCRIPTION_INTERVAL_FIVE_MINUTES - Пятиминутные свечи. */
  SUBSCRIPTION_INTERVAL_FIVE_MINUTES = 2,
  /** SUBSCRIPTION_INTERVAL_FIFTEEN_MINUTES - Пятнадцатиминутные свечи. */
  SUBSCRIPTION_INTERVAL_FIFTEEN_MINUTES = 3,
  /** SUBSCRIPTION_INTERVAL_ONE_HOUR - Часовые свечи. */
  SUBSCRIPTION_INTERVAL_ONE_HOUR = 4,
  /** SUBSCRIPTION_INTERVAL_ONE_DAY - Дневные свечи. */
  SUBSCRIPTION_INTERVAL_ONE_DAY = 5,
  /** SUBSCRIPTION_INTERVAL_2_MIN - Двухминутные свечи. */
  SUBSCRIPTION_INTERVAL_2_MIN = 6,
  /** SUBSCRIPTION_INTERVAL_3_MIN - Трёхминутные свечи. */
  SUBSCRIPTION_INTERVAL_3_MIN = 7,
  /** SUBSCRIPTION_INTERVAL_10_MIN - Десятиминутные свечи. */
  SUBSCRIPTION_INTERVAL_10_MIN = 8,
  /** SUBSCRIPTION_INTERVAL_30_MIN - Тридцатиминутные свечи. */
  SUBSCRIPTION_INTERVAL_30_MIN = 9,
  /** SUBSCRIPTION_INTERVAL_2_HOUR - Двухчасовые свечи. */
  SUBSCRIPTION_INTERVAL_2_HOUR = 10,
  /** SUBSCRIPTION_INTERVAL_4_HOUR - Четырёхчасовые свечи. */
  SUBSCRIPTION_INTERVAL_4_HOUR = 11,
  /** SUBSCRIPTION_INTERVAL_WEEK - Недельные свечи. */
  SUBSCRIPTION_INTERVAL_WEEK = 12,
  /** SUBSCRIPTION_INTERVAL_MONTH - Месячные свечи. */
  SUBSCRIPTION_INTERVAL_MONTH = 13,
  UNRECOGNIZED = -1,
}

/** Результат подписки. */
export enum SubscriptionStatus {
  /** SUBSCRIPTION_STATUS_UNSPECIFIED - Статус подписки не определён. */
  SUBSCRIPTION_STATUS_UNSPECIFIED = 0,
  /** SUBSCRIPTION_STATUS_SUCCESS - Успешно. */
  SUBSCRIPTION_STATUS_SUCCESS = 1,
  /** SUBSCRIPTION_STATUS_INSTRUMENT_NOT_FOUND - Инструмент не найден. */
  SUBSCRIPTION_STATUS_INSTRUMENT_NOT_FOUND = 2,
  /** SUBSCRIPTION_STATUS_SUBSCRIPTION_ACTION_IS_INVALID - Некорректный статус подписки. [Список возможных значений](https://russianinvestments.github.io/investAPI/marketdata#subscriptionaction). */
  SUBSCRIPTION_STATUS_SUBSCRIPTION_ACTION_IS_INVALID = 3,
  /** SUBSCRIPTION_STATUS_DEPTH_IS_INVALID - Некорректная глубина стакана. Доступные значения — 1, 10, 20, 30, 40, 50. */
  SUBSCRIPTION_STATUS_DEPTH_IS_INVALID = 4,
  /** SUBSCRIPTION_STATUS_INTERVAL_IS_INVALID - Некорректный интервал свечей. [Список возможных значений](https://russianinvestments.github.io/investAPI/marketdata#subscriptioninterval). */
  SUBSCRIPTION_STATUS_INTERVAL_IS_INVALID = 5,
  /** SUBSCRIPTION_STATUS_LIMIT_IS_EXCEEDED - Превышен лимит на общее количество подписок в рамках стрима. [Лимитная политика](https://russianinvestments.github.io/investAPI/limits/). */
  SUBSCRIPTION_STATUS_LIMIT_IS_EXCEEDED = 6,
  /** SUBSCRIPTION_STATUS_INTERNAL_ERROR - Внутренняя ошибка сервиса. */
  SUBSCRIPTION_STATUS_INTERNAL_ERROR = 7,
  /** SUBSCRIPTION_STATUS_TOO_MANY_REQUESTS - Превышен лимит на количество запросов на подписки в течение установленного отрезка времени. */
  SUBSCRIPTION_STATUS_TOO_MANY_REQUESTS = 8,
  /** SUBSCRIPTION_STATUS_SUBSCRIPTION_NOT_FOUND - Активная подписка не найдена. Ошибка может возникнуть только при отписке от несуществующей подписки. */
  SUBSCRIPTION_STATUS_SUBSCRIPTION_NOT_FOUND = 9,
  /** SUBSCRIPTION_STATUS_SOURCE_IS_INVALID - Указан некорректный источник */
  SUBSCRIPTION_STATUS_SOURCE_IS_INVALID = 10,
  UNRECOGNIZED = -1,
}

/** Типы источников сделок. */
export enum TradeSourceType {
  /** TRADE_SOURCE_UNSPECIFIED - Тип источника сделки не определён. */
  TRADE_SOURCE_UNSPECIFIED = 0,
  /** TRADE_SOURCE_EXCHANGE - Биржевые сделки. */
  TRADE_SOURCE_EXCHANGE = 1,
  /** TRADE_SOURCE_DEALER - Сделки дилера. */
  TRADE_SOURCE_DEALER = 2,
  /** TRADE_SOURCE_ALL - Все сделки. */
  TRADE_SOURCE_ALL = 3,
  UNRECOGNIZED = -1,
}

/** Направление сделки. */
export enum TradeDirection {
  /** TRADE_DIRECTION_UNSPECIFIED - Направление сделки не определено. */
  TRADE_DIRECTION_UNSPECIFIED = 0,
  /** TRADE_DIRECTION_BUY - Покупка. */
  TRADE_DIRECTION_BUY = 1,
  /** TRADE_DIRECTION_SELL - Продажа. */
  TRADE_DIRECTION_SELL = 2,
  UNRECOGNIZED = -1,
}

/** Интервал свечей. Максимальное значение интервала приведено ориентировочно, может отличаться в большую сторону в зависимости от параметров запроса. */
export enum CandleInterval {
  /** CANDLE_INTERVAL_UNSPECIFIED - Интервал не определён. */
  CANDLE_INTERVAL_UNSPECIFIED = 0,
  /** CANDLE_INTERVAL_1_MIN - От 1 минуты до 1 дня (лимит 2400). */
  CANDLE_INTERVAL_1_MIN = 1,
  /** CANDLE_INTERVAL_5_MIN - От 5 минут до недели (лимит 2400). */
  CANDLE_INTERVAL_5_MIN = 2,
  /** CANDLE_INTERVAL_15_MIN - От 15 минут до 3 недель (лимит 2400). */
  CANDLE_INTERVAL_15_MIN = 3,
  /** CANDLE_INTERVAL_HOUR - От 1 часа до 3 месяцев (лимит 2400). */
  CANDLE_INTERVAL_HOUR = 4,
  /** CANDLE_INTERVAL_DAY - От 1 дня до 6 лет (лимит 2400). */
  CANDLE_INTERVAL_DAY = 5,
  /** CANDLE_INTERVAL_2_MIN - От 2 минут до 1 дня (лимит 1200). */
  CANDLE_INTERVAL_2_MIN = 6,
  /** CANDLE_INTERVAL_3_MIN - От 3 минут до 1 дня (лимит 750). */
  CANDLE_INTERVAL_3_MIN = 7,
  /** CANDLE_INTERVAL_10_MIN - От 10 минут до недели (лимит 1200). */
  CANDLE_INTERVAL_10_MIN = 8,
  /** CANDLE_INTERVAL_30_MIN - От 30 минут до 3 недель (лимит 1200). */
  CANDLE_INTERVAL_30_MIN = 9,
  /** CANDLE_INTERVAL_2_HOUR - От 2 часов до 3 месяцев (лимит 2400). */
  CANDLE_INTERVAL_2_HOUR = 10,
  /** CANDLE_INTERVAL_4_HOUR - От 4 часов до 3 месяцев (лимит 700). */
  CANDLE_INTERVAL_4_HOUR = 11,
  /** CANDLE_INTERVAL_WEEK - От 1 недели до 5 лет (лимит 300). */
  CANDLE_INTERVAL_WEEK = 12,
  /** CANDLE_INTERVAL_MONTH - От 1 месяца до 10 лет (лимит 120). */
  CANDLE_INTERVAL_MONTH = 13,
  UNRECOGNIZED = -1,
}

export enum CandleSource {
  /** CANDLE_SOURCE_UNSPECIFIED - Источник свечей не определён. */
  CANDLE_SOURCE_UNSPECIFIED = 0,
  /** CANDLE_SOURCE_EXCHANGE - Биржевые свечи. */
  CANDLE_SOURCE_EXCHANGE = 1,
  /** CANDLE_SOURCE_DEALER_WEEKEND - Свечи  дилера в результате торговли по выходным. */
  CANDLE_SOURCE_DEALER_WEEKEND = 2,
  UNRECOGNIZED = -1,
}

export enum OrderBookType {
  /** ORDERBOOK_TYPE_UNSPECIFIED - Не определён. */
  ORDERBOOK_TYPE_UNSPECIFIED = 0,
  /** ORDERBOOK_TYPE_EXCHANGE - Биржевой стакан. */
  ORDERBOOK_TYPE_EXCHANGE = 1,
  /** ORDERBOOK_TYPE_DEALER - Стакан дилера. */
  ORDERBOOK_TYPE_DEALER = 2,
  /** ORDERBOOK_TYPE_ALL - Стакан биржевой и дилера. */
  ORDERBOOK_TYPE_ALL = 3,
  UNRECOGNIZED = -1,
}

/** Тип последней цены */
export enum LastPriceType {
  /** LAST_PRICE_UNSPECIFIED - Не определен. */
  LAST_PRICE_UNSPECIFIED = 0,
  /** LAST_PRICE_EXCHANGE - Цена биржи. */
  LAST_PRICE_EXCHANGE = 1,
  /** LAST_PRICE_DEALER - Цена дилера */
  LAST_PRICE_DEALER = 2,
  UNRECOGNIZED = -1,
}

/** Запрос подписки или отписки на определённые биржевые данные. */
export interface MarketDataRequest {
  /** Запрос подписки на свечи. */
  subscribeCandlesRequest?:
    | SubscribeCandlesRequest
    | undefined;
  /** Запрос подписки на стаканы. */
  subscribeOrderBookRequest?:
    | SubscribeOrderBookRequest
    | undefined;
  /** Запрос подписки на ленту обезличенных сделок. */
  subscribeTradesRequest?:
    | SubscribeTradesRequest
    | undefined;
  /** Запрос подписки на торговые статусы инструментов. */
  subscribeInfoRequest?:
    | SubscribeInfoRequest
    | undefined;
  /** Запрос подписки на цены последних сделок. */
  subscribeLastPriceRequest?:
    | SubscribeLastPriceRequest
    | undefined;
  /** Запрос своих подписок. */
  getMySubscriptions?:
    | GetMySubscriptions
    | undefined;
  /** Запрос проверки активности соединения. */
  ping?:
    | PingRequest
    | undefined;
  /** Запрос настройки пинга. */
  pingSettings?: PingDelaySettings | undefined;
}

export interface MarketDataServerSideStreamRequest {
  /** Запрос подписки на свечи. */
  subscribeCandlesRequest:
    | SubscribeCandlesRequest
    | undefined;
  /** Запрос подписки на стаканы. */
  subscribeOrderBookRequest:
    | SubscribeOrderBookRequest
    | undefined;
  /** Запрос подписки на ленту обезличенных сделок. */
  subscribeTradesRequest:
    | SubscribeTradesRequest
    | undefined;
  /** Запрос подписки на торговые статусы инструментов. */
  subscribeInfoRequest:
    | SubscribeInfoRequest
    | undefined;
  /** Запрос подписки на цены последних сделок. */
  subscribeLastPriceRequest:
    | SubscribeLastPriceRequest
    | undefined;
  /** Запрос настройки пинга. */
  pingSettings: PingDelaySettings | undefined;
}

/** Пакет биржевой информации по подписке. */
export interface MarketDataResponse {
  /** Результат подписки на свечи. */
  subscribeCandlesResponse?:
    | SubscribeCandlesResponse
    | undefined;
  /** Результат подписки на стаканы. */
  subscribeOrderBookResponse?:
    | SubscribeOrderBookResponse
    | undefined;
  /** Результат подписки на поток обезличенных сделок. */
  subscribeTradesResponse?:
    | SubscribeTradesResponse
    | undefined;
  /** Результат подписки на торговые статусы инструментов. */
  subscribeInfoResponse?:
    | SubscribeInfoResponse
    | undefined;
  /** Свеча. */
  candle?:
    | Candle
    | undefined;
  /** Сделки. */
  trade?:
    | Trade
    | undefined;
  /** Стакан. */
  orderbook?:
    | OrderBook
    | undefined;
  /** Торговый статус. */
  tradingStatus?:
    | TradingStatus
    | undefined;
  /** Проверка активности стрима. */
  ping?:
    | Ping
    | undefined;
  /** Результат подписки на цены последние сделок по инструментам. */
  subscribeLastPriceResponse?:
    | SubscribeLastPriceResponse
    | undefined;
  /** Цена последней сделки. */
  lastPrice?: LastPrice | undefined;
}

/** subscribeCandles | Изменения статуса подписки на свечи. */
export interface SubscribeCandlesRequest {
  /** Изменение статуса подписки. */
  subscriptionAction: SubscriptionAction;
  /** Массив инструментов для подписки на свечи. */
  instruments: CandleInstrument[];
  /** Флаг ожидания закрытия временного интервала для отправки свечи. */
  waitingClose: boolean;
  /** Источник свечей. */
  candleSourceType?: GetCandlesRequest_CandleSource | undefined;
}

/** Запрос изменения статус подписки на свечи. */
export interface CandleInstrument {
  /**
   * Deprecated FIGI-идентификатор инструмента. Используйте `instrument_id`.
   *
   * @deprecated
   */
  figi: string;
  /** Интервал свечей. Двухчасовые и четырёхчасовые свечи в стриме отсчитываются с 0:00 по UTC. */
  interval: SubscriptionInterval;
  /** Идентификатор инструмента. Принимает значение `figi` или `instrument_uid`. */
  instrumentId: string;
}

/** Результат изменения статус подписки на свечи. */
export interface SubscribeCandlesResponse {
  /** Уникальный идентификатор запроса. [Подробнее](https://russianinvestments.github.io/investAPI/grpc#tracking-id). */
  trackingId: string;
  /** Массив статусов подписки на свечи. */
  candlesSubscriptions: CandleSubscription[];
}

/** Статус подписки на свечи. */
export interface CandleSubscription {
  /** FIGI-идентификатор инструмента. */
  figi: string;
  /** Интервал свечей. */
  interval: SubscriptionInterval;
  /** Статус подписки. */
  subscriptionStatus: SubscriptionStatus;
  /** UID инструмента. */
  instrumentUid: string;
  /** Флаг ожидания закрытия временного интервала для отправки свечи. */
  waitingClose: boolean;
  /** Идентификатор открытого соединения. */
  streamId: string;
  /** Идентификатор подписки в формате `UUID`. */
  subscriptionId: string;
  /** Источник свечей. */
  candleSourceType?: GetCandlesRequest_CandleSource | undefined;
}

/** Запрос на изменение статуса подписки на стаканы. */
export interface SubscribeOrderBookRequest {
  /** Изменение статуса подписки. */
  subscriptionAction: SubscriptionAction;
  /** Массив инструментов для подписки на стаканы. */
  instruments: OrderBookInstrument[];
}

/** Запрос подписки на стаканы. */
export interface OrderBookInstrument {
  /**
   * Deprecated FIGI-идентификатор инструмента. Используйте `instrument_id`.
   *
   * @deprecated
   */
  figi: string;
  /** Глубина стакана. */
  depth: number;
  /** Идентификатор инструмента. Принимает значение `figi` или `instrument_uid`. */
  instrumentId: string;
  /** Тип стакана. По умолчанию ORDERBOOK_TYPE_ALL - стакан биржевой и дилера. */
  orderBookType: OrderBookType;
}

/** Результат изменения статуса подписки на стаканы. */
export interface SubscribeOrderBookResponse {
  /** Уникальный идентификатор запроса. [Подробнее](https://russianinvestments.github.io/investAPI/grpc#tracking-id). */
  trackingId: string;
  /** Массив статусов подписки на стаканы. */
  orderBookSubscriptions: OrderBookSubscription[];
}

/** Статус подписки. */
export interface OrderBookSubscription {
  /** FIGI-идентификатор инструмента. */
  figi: string;
  /** Глубина стакана. */
  depth: number;
  /** Статус подписки. */
  subscriptionStatus: SubscriptionStatus;
  /** UID инструмента. */
  instrumentUid: string;
  /** Идентификатор открытого соединения. */
  streamId: string;
  /** Идентификатор подписки в формате `UUID`. */
  subscriptionId: string;
  /** Тип стакана. */
  orderBookType: OrderBookType;
}

/** Изменение статуса подписки на поток обезличенных сделок. */
export interface SubscribeTradesRequest {
  /** Изменение статуса подписки. */
  subscriptionAction: SubscriptionAction;
  /** Массив инструментов для подписки на поток обезличенных сделок. */
  instruments: TradeInstrument[];
  /** Тип источника сделок. По умолчанию TRADE_SOURCE_ALL - все сделки. */
  tradeSource: TradeSourceType;
}

/** Запрос подписки на поток обезличенных сделок. */
export interface TradeInstrument {
  /**
   * Deprecated FIGI-идентификатор инструмента. Используйте instrument_id`.
   *
   * @deprecated
   */
  figi: string;
  /** Идентификатор инструмента. Принимает значение `figi` или `instrument_uid`. */
  instrumentId: string;
}

/** Результат изменения статуса подписки на поток обезличенных сделок. */
export interface SubscribeTradesResponse {
  /** Уникальный идентификатор запроса. [Подробнее](https://russianinvestments.github.io/investAPI/grpc#tracking-id). */
  trackingId: string;
  /** Массив статусов подписки на поток сделок. */
  tradeSubscriptions: TradeSubscription[];
  /** Тип источника сделок. */
  tradeSource: TradeSourceType;
}

/** Статус подписки. */
export interface TradeSubscription {
  /** FIGI-идентификатор инструмента. */
  figi: string;
  /** Статус подписки. */
  subscriptionStatus: SubscriptionStatus;
  /** UID инструмента. */
  instrumentUid: string;
  /** Идентификатор открытого соединения. */
  streamId: string;
  /** Идентификатор подписки в формате UUID. */
  subscriptionId: string;
}

/** Изменение статуса подписки на торговый статус инструмента. */
export interface SubscribeInfoRequest {
  /** Изменение статуса подписки. */
  subscriptionAction: SubscriptionAction;
  /** Массив инструментов для подписки на торговый статус. */
  instruments: InfoInstrument[];
}

/** Запрос подписки на торговый статус. */
export interface InfoInstrument {
  /**
   * Deprecated FIGI-идентификатор инструмента. Используйте instrument_id`.
   *
   * @deprecated
   */
  figi: string;
  /** Идентификатор инструмента. Принимает значение `figi` или `instrument_uid`. */
  instrumentId: string;
}

/** Результат изменения статуса подписки на торговый статус. */
export interface SubscribeInfoResponse {
  /** Уникальный идентификатор запроса. [Подробнее](https://russianinvestments.github.io/investAPI/grpc#tracking-id). */
  trackingId: string;
  /** Массив статусов подписки на торговый статус. */
  infoSubscriptions: InfoSubscription[];
}

/** Статус подписки. */
export interface InfoSubscription {
  /** FIGI-идентификатор инструмента. */
  figi: string;
  /** Статус подписки. */
  subscriptionStatus: SubscriptionStatus;
  /** UID инструмента. */
  instrumentUid: string;
  /** Идентификатор открытого соединения. */
  streamId: string;
  /** Идентификатор подписки в формате UUID. */
  subscriptionId: string;
}

/** Изменение статуса подписки на цену последней сделки по инструменту. */
export interface SubscribeLastPriceRequest {
  /** Изменение статуса подписки. */
  subscriptionAction: SubscriptionAction;
  /** Массив инструментов для подписки на цену последней сделки. */
  instruments: LastPriceInstrument[];
}

/** Запрос подписки на последнюю цену. */
export interface LastPriceInstrument {
  /**
   * Deprecated FIGI-идентификатор инструмента. Используйте instrument_id`.
   *
   * @deprecated
   */
  figi: string;
  /** Идентификатор инструмента. Принимает значение `figi` или `instrument_uid`. */
  instrumentId: string;
}

/** Результат изменения статуса подписки на цену последней сделки. */
export interface SubscribeLastPriceResponse {
  /** Уникальный идентификатор запроса. [Подробнее](https://russianinvestments.github.io/investAPI/grpc#tracking-id). */
  trackingId: string;
  /** Массив статусов подписки на цену последней сделки. */
  lastPriceSubscriptions: LastPriceSubscription[];
}

/** Статус подписки на цену последней сделки. */
export interface LastPriceSubscription {
  /** FIGI-идентификатор инструмента. */
  figi: string;
  /** Статус подписки. */
  subscriptionStatus: SubscriptionStatus;
  /** UID инструмента. */
  instrumentUid: string;
  /** Идентификатор открытого соединения. */
  streamId: string;
  /** Идентификатор подписки в формате `UUID`. */
  subscriptionId: string;
}

/** Пакет свечей в рамках стрима. */
export interface Candle {
  /** FIGI-идентификатор инструмента. */
  figi: string;
  /** Интервал свечи. */
  interval: SubscriptionInterval;
  /** Цена открытия за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](https://russianinvestments.github.io/investAPI/faq_marketdata/#_15). */
  open:
    | Quotation
    | undefined;
  /** Максимальная цена за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](https://russianinvestments.github.io/investAPI/faq_marketdata/#_15). */
  high:
    | Quotation
    | undefined;
  /** Минимальная цена за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](https://russianinvestments.github.io/investAPI/faq_marketdata/#_15). */
  low:
    | Quotation
    | undefined;
  /** Цена закрытия за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](https://russianinvestments.github.io/investAPI/faq_marketdata/#_15). */
  close:
    | Quotation
    | undefined;
  /** Объём сделок в лотах. */
  volume: number;
  /** Время начала интервала свечи по UTC. */
  time:
    | Date
    | undefined;
  /** Время последней сделки, вошедшей в свечу по UTC. */
  lastTradeTs:
    | Date
    | undefined;
  /** UID инструмента. */
  instrumentUid: string;
  /** Источник свечей */
  candleSourceType: CandleSource;
}

/** Пакет стаканов в рамках стрима. */
export interface OrderBook {
  /** FIGI-идентификатор инструмента. */
  figi: string;
  /** Глубина стакана. */
  depth: number;
  /** Флаг консистентности стакана. **false** — не все заявки попали в стакан из-за сетевых задержек или нарушения порядка доставки. */
  isConsistent: boolean;
  /** Массив предложений. */
  bids: Order[];
  /** Массив спроса. */
  asks: Order[];
  /** Время формирования стакана в часовом поясе UTC по времени биржи. */
  time:
    | Date
    | undefined;
  /** Верхний лимит цены за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](https://russianinvestments.github.io/investAPI/faq_marketdata/#_15). */
  limitUp:
    | Quotation
    | undefined;
  /** Нижний лимит цены за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](https://russianinvestments.github.io/investAPI/faq_marketdata/#_15). */
  limitDown:
    | Quotation
    | undefined;
  /** UID инструмента. */
  instrumentUid: string;
  /** Тип стакана. */
  orderBookType: OrderBookType;
}

/** Массив предложений/спроса. */
export interface Order {
  /** Цена за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](https://russianinvestments.github.io/investAPI/faq_marketdata/#_15). */
  price:
    | Quotation
    | undefined;
  /** Количество в лотах. */
  quantity: number;
}

/** Информация о сделке. */
export interface Trade {
  /** FIGI-идентификатор инструмента. */
  figi: string;
  /** Направление сделки. */
  direction: TradeDirection;
  /** Цена за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](https://russianinvestments.github.io/investAPI/faq_marketdata/#_15). */
  price:
    | Quotation
    | undefined;
  /** Количество лотов. */
  quantity: number;
  /** Время сделки в часовом поясе UTC по времени биржи. */
  time:
    | Date
    | undefined;
  /** UID инструмента. */
  instrumentUid: string;
  /** Тип источника сделки. */
  tradeSource: TradeSourceType;
}

/** Пакет изменения торгового статуса. */
export interface TradingStatus {
  /** FIGI-идентификатор инструмента. */
  figi: string;
  /** Статус торговли инструментом. */
  tradingStatus: SecurityTradingStatus;
  /** Время изменения торгового статуса по UTC. */
  time:
    | Date
    | undefined;
  /** Признак доступности выставления лимитной заявки по инструменту. */
  limitOrderAvailableFlag: boolean;
  /** Признак доступности выставления рыночной заявки по инструменту. */
  marketOrderAvailableFlag: boolean;
  /** UID инструмента. */
  instrumentUid: string;
}

/** Запрос исторических свечей. */
export interface GetCandlesRequest {
  /**
   * Deprecated FIGI-идентификатор инструмента. Используйте `instrument_id`.
   *
   * @deprecated
   */
  figi?:
    | string
    | undefined;
  /** Начало запрашиваемого периода по UTC. */
  from:
    | Date
    | undefined;
  /** Окончание запрашиваемого периода по UTC. */
  to:
    | Date
    | undefined;
  /** Интервал запрошенных свечей. */
  interval: CandleInterval;
  /** Идентификатор инструмента. Принимает значение `figi` или `instrument_uid`. */
  instrumentId?:
    | string
    | undefined;
  /** Тип источника свечи. */
  candleSourceType?:
    | GetCandlesRequest_CandleSource
    | undefined;
  /** Максимальное количество свечей в ответе. */
  limit?: number | undefined;
}

export enum GetCandlesRequest_CandleSource {
  /** CANDLE_SOURCE_UNSPECIFIED - Все свечи. */
  CANDLE_SOURCE_UNSPECIFIED = 0,
  /** CANDLE_SOURCE_EXCHANGE - Биржевые свечи. */
  CANDLE_SOURCE_EXCHANGE = 1,
  /** CANDLE_SOURCE_INCLUDE_WEEKEND - Все свечи с учетом торговли по выходным. */
  CANDLE_SOURCE_INCLUDE_WEEKEND = 3,
  UNRECOGNIZED = -1,
}

/** Список свечей. */
export interface GetCandlesResponse {
  /** Массив свечей. */
  candles: HistoricCandle[];
}

/** Информация о свече. */
export interface HistoricCandle {
  /** Цена открытия за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](https://russianinvestments.github.io/investAPI/faq_marketdata/#_15). */
  open:
    | Quotation
    | undefined;
  /** Максимальная цена за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](https://russianinvestments.github.io/investAPI/faq_marketdata/#_15). */
  high:
    | Quotation
    | undefined;
  /** Минимальная цена за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](https://russianinvestments.github.io/investAPI/faq_marketdata/#_15). */
  low:
    | Quotation
    | undefined;
  /** Цена закрытия за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](https://russianinvestments.github.io/investAPI/faq_marketdata/#_15). */
  close:
    | Quotation
    | undefined;
  /** Объём торгов в лотах. */
  volume: number;
  /** Время свечи в часовом поясе UTC. */
  time:
    | Date
    | undefined;
  /** Признак завершённости свечи. **false** — свеча за текущие интервал ещё сформирована не полностью. */
  isComplete: boolean;
  /** Тип источника свечи */
  candleSourceType: CandleSource;
}

/** Запрос получения цен последних сделок. */
export interface GetLastPricesRequest {
  /**
   * Deprecated FIGI-идентификатор инструмента. Используйте `instrument_id`.
   *
   * @deprecated
   */
  figi: string[];
  /** Массив идентификаторов инструмента. Принимает значения `figi` или `instrument_uid`. */
  instrumentId: string[];
  /** Тип запрашиваемой последней цены. */
  lastPriceType: LastPriceType;
  /** Статус запрашиваемых инструментов. [Возможные значения](#instrumentstatus). */
  instrumentStatus?: InstrumentStatus | undefined;
}

/** Список цен последних сделок. */
export interface GetLastPricesResponse {
  /** Массив цен последних сделок. */
  lastPrices: LastPrice[];
}

/** Информация о цене последней сделки. */
export interface LastPrice {
  /** FIGI инструмента. */
  figi: string;
  /** Цена последней сделки за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](https://russianinvestments.github.io/investAPI/faq_marketdata/#_15). */
  price:
    | Quotation
    | undefined;
  /** Время получения последней цены в часовом поясе UTC по времени биржи. */
  time:
    | Date
    | undefined;
  /** UID инструмента. */
  instrumentUid: string;
  /** Тип последней цены. */
  lastPriceType: LastPriceType;
}

/** Запрос стакана. */
export interface GetOrderBookRequest {
  /**
   * Deprecated FIGI-идентификатор инструмента. Используйте `instrument_id`.
   *
   * @deprecated
   */
  figi?:
    | string
    | undefined;
  /** Глубина стакана. */
  depth: number;
  /** Идентификатор инструмента. Принимает значение `figi` или `instrument_uid`. */
  instrumentId?: string | undefined;
}

/** Информация о стакане. */
export interface GetOrderBookResponse {
  /** FIGI-идентификатор инструмента. */
  figi: string;
  /** Глубина стакана. */
  depth: number;
  /** Множество пар значений на покупку. */
  bids: Order[];
  /** Множество пар значений на продажу. */
  asks: Order[];
  /** Цена последней сделки за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](https://russianinvestments.github.io/investAPI/faq_marketdata/#_15). */
  lastPrice:
    | Quotation
    | undefined;
  /** Цена закрытия за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](https://russianinvestments.github.io/investAPI/faq_marketdata/#_15). */
  closePrice:
    | Quotation
    | undefined;
  /** Верхний лимит цены за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](https://russianinvestments.github.io/investAPI/faq_marketdata/#_15). */
  limitUp:
    | Quotation
    | undefined;
  /** Нижний лимит цены за 1 инструмент. Чтобы получить стоимость лота, нужно умножить на лотность инструмента. [Подробнее про перевод цен в валюту](https://russianinvestments.github.io/investAPI/faq_marketdata/#_15). */
  limitDown:
    | Quotation
    | undefined;
  /** Время получения цены последней сделки. */
  lastPriceTs:
    | Date
    | undefined;
  /** Время получения цены закрытия. */
  closePriceTs:
    | Date
    | undefined;
  /** Время формирования стакана на бирже. */
  orderbookTs:
    | Date
    | undefined;
  /** UID инструмента. */
  instrumentUid: string;
}

/** Запрос получения торгового статуса. */
export interface GetTradingStatusRequest {
  /**
   * Deprecated FIGI-идентификатор инструмента. Используйте `instrument_id`.
   *
   * @deprecated
   */
  figi?:
    | string
    | undefined;
  /** Идентификатор инструмента. Принимает значение `figi` или `instrument_uid`. */
  instrumentId?: string | undefined;
}

/** Запрос получения торгового статуса. */
export interface GetTradingStatusesRequest {
  /** Идентификатор инструмента. Принимает значение `figi` или `instrument_uid`. */
  instrumentId: string[];
}

/** Информация о торговом статусе. */
export interface GetTradingStatusesResponse {
  /** Массив информации о торговых статусах. */
  tradingStatuses: GetTradingStatusResponse[];
}

/** Информация о торговом статусе. */
export interface GetTradingStatusResponse {
  /** FIGI-идентификатор инструмента. */
  figi: string;
  /** Статус торговли инструментом. */
  tradingStatus: SecurityTradingStatus;
  /** Признак доступности выставления лимитной заявки по инструменту. */
  limitOrderAvailableFlag: boolean;
  /** Признак доступности выставления рыночной заявки по инструменту. */
  marketOrderAvailableFlag: boolean;
  /** Признак доступности торгов через API. */
  apiTradeAvailableFlag: boolean;
  /** UID инструмента. */
  instrumentUid: string;
  /** Признак доступности завяки по лучшей цене. */
  bestpriceOrderAvailableFlag: boolean;
  /** Признак доступности только заявки по лучшей цене. */
  onlyBestPrice: boolean;
}

/** Запрос обезличенных сделок за последний час. */
export interface GetLastTradesRequest {
  /**
   * Deprecated FIGI-идентификатор инструмента. Используйте `instrument_id`.
   *
   * @deprecated
   */
  figi?:
    | string
    | undefined;
  /** Начало запрашиваемого периода по UTC. */
  from:
    | Date
    | undefined;
  /** Окончание запрашиваемого периода по UTC. */
  to:
    | Date
    | undefined;
  /** Идентификатор инструмента. Принимает значение `figi` или `instrument_uid`. */
  instrumentId?:
    | string
    | undefined;
  /** Тип источника сделок. По умолчанию TRADE_SOURCE_ALL - все сделки. */
  tradeSource: TradeSourceType;
}

/** Обезличенных сделок за последний час. */
export interface GetLastTradesResponse {
  /** Массив сделок. */
  trades: Trade[];
}

/** Запрос активных подписок. Возвращает по одному сообщению на каждый тип активных подписок — `SubscribeLastPriceResponse`, `SubscribeInfoResponse`, `SubscribeTradesResponse`, `SubscribeOrderBookResponse`, `SubscribeCandlesResponse`. */
export interface GetMySubscriptions {
}

/** Запрос цен закрытия торговой сессии по инструментам. */
export interface GetClosePricesRequest {
  /** Массив по инструментам. */
  instruments: InstrumentClosePriceRequest[];
  /** Статус запрашиваемых инструментов. [Возможные значения](#instrumentstatus). */
  instrumentStatus?: InstrumentStatus | undefined;
}

/** Запрос цен закрытия торговой сессии по инструменту. */
export interface InstrumentClosePriceRequest {
  /** Идентификатор инструмента. Принимает значение `figi` или `instrument_uid`. */
  instrumentId: string;
}

/** Цены закрытия торговой сессии по инструментам. */
export interface GetClosePricesResponse {
  /** Массив по инструментам. */
  closePrices: InstrumentClosePriceResponse[];
}

/** Цена закрытия торговой сессии по инструменту. */
export interface InstrumentClosePriceResponse {
  /** FIGI инструмента. */
  figi: string;
  /** UID инструмента. */
  instrumentUid: string;
  /** Цена закрытия торговой сессии. */
  price:
    | Quotation
    | undefined;
  /** Цена последней сделки с вечерней сессии. Цена публикуется биржей по торговым дням и в нерабочие дни не обновляется. */
  eveningSessionPrice:
    | Quotation
    | undefined;
  /** Дата совершения торгов. */
  time: Date | undefined;
}

export interface GetTechAnalysisRequest {
  /** Тип технического индикатора. */
  indicatorType: GetTechAnalysisRequest_IndicatorType;
  /** UID инструмента. */
  instrumentUid: string;
  /** Начало запрашиваемого периода по UTC. */
  from:
    | Date
    | undefined;
  /** Окончание запрашиваемого периода по UTC. */
  to:
    | Date
    | undefined;
  /** Интервал, за который рассчитывается индикатор. */
  interval: GetTechAnalysisRequest_IndicatorInterval;
  /** Тип цены, который используется при расчёте индикатора. */
  typeOfPrice: GetTechAnalysisRequest_TypeOfPrice;
  /** Торговый период, за который рассчитывается индикатор. */
  length: number;
  /** Параметры отклонения. */
  deviation:
    | GetTechAnalysisRequest_Deviation
    | undefined;
  /** Параметры сглаживания. */
  smoothing: GetTechAnalysisRequest_Smoothing | undefined;
}

/** Интервал свечи. */
export enum GetTechAnalysisRequest_IndicatorInterval {
  /** INDICATOR_INTERVAL_UNSPECIFIED - Интервал не определён. */
  INDICATOR_INTERVAL_UNSPECIFIED = 0,
  /** INDICATOR_INTERVAL_ONE_MINUTE - 1 минута. */
  INDICATOR_INTERVAL_ONE_MINUTE = 1,
  /** INDICATOR_INTERVAL_FIVE_MINUTES - 5 минут. */
  INDICATOR_INTERVAL_FIVE_MINUTES = 2,
  /** INDICATOR_INTERVAL_FIFTEEN_MINUTES - 15 минут. */
  INDICATOR_INTERVAL_FIFTEEN_MINUTES = 3,
  /** INDICATOR_INTERVAL_ONE_HOUR - 1 час. */
  INDICATOR_INTERVAL_ONE_HOUR = 4,
  /** INDICATOR_INTERVAL_ONE_DAY - 1 день. */
  INDICATOR_INTERVAL_ONE_DAY = 5,
  /** INDICATOR_INTERVAL_2_MIN - 2 минуты. */
  INDICATOR_INTERVAL_2_MIN = 6,
  /** INDICATOR_INTERVAL_3_MIN - 3 минуты. */
  INDICATOR_INTERVAL_3_MIN = 7,
  /** INDICATOR_INTERVAL_10_MIN - 10 минут. */
  INDICATOR_INTERVAL_10_MIN = 8,
  /** INDICATOR_INTERVAL_30_MIN - 30 минут. */
  INDICATOR_INTERVAL_30_MIN = 9,
  /** INDICATOR_INTERVAL_2_HOUR - 2 часа. */
  INDICATOR_INTERVAL_2_HOUR = 10,
  /** INDICATOR_INTERVAL_4_HOUR - 4 часа. */
  INDICATOR_INTERVAL_4_HOUR = 11,
  /** INDICATOR_INTERVAL_WEEK - Неделя. */
  INDICATOR_INTERVAL_WEEK = 12,
  /** INDICATOR_INTERVAL_MONTH - Месяц. */
  INDICATOR_INTERVAL_MONTH = 13,
  UNRECOGNIZED = -1,
}

export enum GetTechAnalysisRequest_TypeOfPrice {
  /** TYPE_OF_PRICE_UNSPECIFIED - Не указано. */
  TYPE_OF_PRICE_UNSPECIFIED = 0,
  /** TYPE_OF_PRICE_CLOSE - Цена закрытия. */
  TYPE_OF_PRICE_CLOSE = 1,
  /** TYPE_OF_PRICE_OPEN - Цена открытия. */
  TYPE_OF_PRICE_OPEN = 2,
  /** TYPE_OF_PRICE_HIGH - Максимальное значение за выбранный интервал. */
  TYPE_OF_PRICE_HIGH = 3,
  /** TYPE_OF_PRICE_LOW - Минимальное значение за выбранный интервал. */
  TYPE_OF_PRICE_LOW = 4,
  /** TYPE_OF_PRICE_AVG - Среднее значение по показателям [ (close + open + high + low) / 4 ]. */
  TYPE_OF_PRICE_AVG = 5,
  UNRECOGNIZED = -1,
}

export enum GetTechAnalysisRequest_IndicatorType {
  /** INDICATOR_TYPE_UNSPECIFIED - Не определён. */
  INDICATOR_TYPE_UNSPECIFIED = 0,
  /** INDICATOR_TYPE_BB - Bollinger Bands — линия Боллинжера. */
  INDICATOR_TYPE_BB = 1,
  /** INDICATOR_TYPE_EMA - Exponential Moving Average — EMA, экспоненциальная скользящая средняя. */
  INDICATOR_TYPE_EMA = 2,
  /** INDICATOR_TYPE_RSI - Relative Strength Index — индекс относительной силы. */
  INDICATOR_TYPE_RSI = 3,
  /** INDICATOR_TYPE_MACD - Moving Average Convergence/Divergence — схождение/расхождение скользящих средних. */
  INDICATOR_TYPE_MACD = 4,
  /** INDICATOR_TYPE_SMA - Simple Moving Average — простое скользящее среднее. */
  INDICATOR_TYPE_SMA = 5,
  UNRECOGNIZED = -1,
}

export interface GetTechAnalysisRequest_Smoothing {
  /** Короткий период сглаживания для первой экспоненциальной скользящей средней (EMA). */
  fastLength: number;
  /** Длинный период сглаживания для второй экспоненциальной скользящей средней (EMA). */
  slowLength: number;
  /** Период сглаживания для третьей экспоненциальной скользящей средней (EMA) */
  signalSmoothing: number;
}

export interface GetTechAnalysisRequest_Deviation {
  /** Количество стандартных отклонений, на которые отступают верхняя и нижняя границы. */
  deviationMultiplier: Quotation | undefined;
}

export interface GetTechAnalysisResponse {
  /** Массив значений результатов технического анализа. */
  technicalIndicators: GetTechAnalysisResponse_TechAnalysisItem[];
}

export interface GetTechAnalysisResponse_TechAnalysisItem {
  /** Временная метка по UTC, для которой были рассчитаны значения индикатора. */
  timestamp:
    | Date
    | undefined;
  /** Значение простого скользящего среднего (средней линии). */
  middleBand?:
    | Quotation
    | undefined;
  /** Значение верхней линии Боллинджера. */
  upperBand?:
    | Quotation
    | undefined;
  /** Значение нижней линии Боллинджера. */
  lowerBand?:
    | Quotation
    | undefined;
  /** Значение сигнальной линии. */
  signal?:
    | Quotation
    | undefined;
  /** Значение линии MACD. */
  macd?: Quotation | undefined;
}

function createBaseMarketDataRequest(): MarketDataRequest {
  return {
    subscribeCandlesRequest: undefined,
    subscribeOrderBookRequest: undefined,
    subscribeTradesRequest: undefined,
    subscribeInfoRequest: undefined,
    subscribeLastPriceRequest: undefined,
    getMySubscriptions: undefined,
    ping: undefined,
    pingSettings: undefined,
  };
}

export const MarketDataRequest: MessageFns<MarketDataRequest> = {
  encode(message: MarketDataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subscribeCandlesRequest !== undefined) {
      SubscribeCandlesRequest.encode(message.subscribeCandlesRequest, writer.uint32(10).fork()).join();
    }
    if (message.subscribeOrderBookRequest !== undefined) {
      SubscribeOrderBookRequest.encode(message.subscribeOrderBookRequest, writer.uint32(18).fork()).join();
    }
    if (message.subscribeTradesRequest !== undefined) {
      SubscribeTradesRequest.encode(message.subscribeTradesRequest, writer.uint32(26).fork()).join();
    }
    if (message.subscribeInfoRequest !== undefined) {
      SubscribeInfoRequest.encode(message.subscribeInfoRequest, writer.uint32(34).fork()).join();
    }
    if (message.subscribeLastPriceRequest !== undefined) {
      SubscribeLastPriceRequest.encode(message.subscribeLastPriceRequest, writer.uint32(42).fork()).join();
    }
    if (message.getMySubscriptions !== undefined) {
      GetMySubscriptions.encode(message.getMySubscriptions, writer.uint32(50).fork()).join();
    }
    if (message.ping !== undefined) {
      PingRequest.encode(message.ping, writer.uint32(58).fork()).join();
    }
    if (message.pingSettings !== undefined) {
      PingDelaySettings.encode(message.pingSettings, writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MarketDataRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarketDataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subscribeCandlesRequest = SubscribeCandlesRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.subscribeOrderBookRequest = SubscribeOrderBookRequest.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.subscribeTradesRequest = SubscribeTradesRequest.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.subscribeInfoRequest = SubscribeInfoRequest.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.subscribeLastPriceRequest = SubscribeLastPriceRequest.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.getMySubscriptions = GetMySubscriptions.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.ping = PingRequest.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.pingSettings = PingDelaySettings.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<MarketDataRequest>): MarketDataRequest {
    return MarketDataRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MarketDataRequest>): MarketDataRequest {
    const message = createBaseMarketDataRequest();
    message.subscribeCandlesRequest =
      (object.subscribeCandlesRequest !== undefined && object.subscribeCandlesRequest !== null)
        ? SubscribeCandlesRequest.fromPartial(object.subscribeCandlesRequest)
        : undefined;
    message.subscribeOrderBookRequest =
      (object.subscribeOrderBookRequest !== undefined && object.subscribeOrderBookRequest !== null)
        ? SubscribeOrderBookRequest.fromPartial(object.subscribeOrderBookRequest)
        : undefined;
    message.subscribeTradesRequest =
      (object.subscribeTradesRequest !== undefined && object.subscribeTradesRequest !== null)
        ? SubscribeTradesRequest.fromPartial(object.subscribeTradesRequest)
        : undefined;
    message.subscribeInfoRequest = (object.subscribeInfoRequest !== undefined && object.subscribeInfoRequest !== null)
      ? SubscribeInfoRequest.fromPartial(object.subscribeInfoRequest)
      : undefined;
    message.subscribeLastPriceRequest =
      (object.subscribeLastPriceRequest !== undefined && object.subscribeLastPriceRequest !== null)
        ? SubscribeLastPriceRequest.fromPartial(object.subscribeLastPriceRequest)
        : undefined;
    message.getMySubscriptions = (object.getMySubscriptions !== undefined && object.getMySubscriptions !== null)
      ? GetMySubscriptions.fromPartial(object.getMySubscriptions)
      : undefined;
    message.ping = (object.ping !== undefined && object.ping !== null)
      ? PingRequest.fromPartial(object.ping)
      : undefined;
    message.pingSettings = (object.pingSettings !== undefined && object.pingSettings !== null)
      ? PingDelaySettings.fromPartial(object.pingSettings)
      : undefined;
    return message;
  },
};

function createBaseMarketDataServerSideStreamRequest(): MarketDataServerSideStreamRequest {
  return {
    subscribeCandlesRequest: undefined,
    subscribeOrderBookRequest: undefined,
    subscribeTradesRequest: undefined,
    subscribeInfoRequest: undefined,
    subscribeLastPriceRequest: undefined,
    pingSettings: undefined,
  };
}

export const MarketDataServerSideStreamRequest: MessageFns<MarketDataServerSideStreamRequest> = {
  encode(message: MarketDataServerSideStreamRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subscribeCandlesRequest !== undefined) {
      SubscribeCandlesRequest.encode(message.subscribeCandlesRequest, writer.uint32(10).fork()).join();
    }
    if (message.subscribeOrderBookRequest !== undefined) {
      SubscribeOrderBookRequest.encode(message.subscribeOrderBookRequest, writer.uint32(18).fork()).join();
    }
    if (message.subscribeTradesRequest !== undefined) {
      SubscribeTradesRequest.encode(message.subscribeTradesRequest, writer.uint32(26).fork()).join();
    }
    if (message.subscribeInfoRequest !== undefined) {
      SubscribeInfoRequest.encode(message.subscribeInfoRequest, writer.uint32(34).fork()).join();
    }
    if (message.subscribeLastPriceRequest !== undefined) {
      SubscribeLastPriceRequest.encode(message.subscribeLastPriceRequest, writer.uint32(42).fork()).join();
    }
    if (message.pingSettings !== undefined) {
      PingDelaySettings.encode(message.pingSettings, writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MarketDataServerSideStreamRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarketDataServerSideStreamRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subscribeCandlesRequest = SubscribeCandlesRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.subscribeOrderBookRequest = SubscribeOrderBookRequest.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.subscribeTradesRequest = SubscribeTradesRequest.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.subscribeInfoRequest = SubscribeInfoRequest.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.subscribeLastPriceRequest = SubscribeLastPriceRequest.decode(reader, reader.uint32());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.pingSettings = PingDelaySettings.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<MarketDataServerSideStreamRequest>): MarketDataServerSideStreamRequest {
    return MarketDataServerSideStreamRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MarketDataServerSideStreamRequest>): MarketDataServerSideStreamRequest {
    const message = createBaseMarketDataServerSideStreamRequest();
    message.subscribeCandlesRequest =
      (object.subscribeCandlesRequest !== undefined && object.subscribeCandlesRequest !== null)
        ? SubscribeCandlesRequest.fromPartial(object.subscribeCandlesRequest)
        : undefined;
    message.subscribeOrderBookRequest =
      (object.subscribeOrderBookRequest !== undefined && object.subscribeOrderBookRequest !== null)
        ? SubscribeOrderBookRequest.fromPartial(object.subscribeOrderBookRequest)
        : undefined;
    message.subscribeTradesRequest =
      (object.subscribeTradesRequest !== undefined && object.subscribeTradesRequest !== null)
        ? SubscribeTradesRequest.fromPartial(object.subscribeTradesRequest)
        : undefined;
    message.subscribeInfoRequest = (object.subscribeInfoRequest !== undefined && object.subscribeInfoRequest !== null)
      ? SubscribeInfoRequest.fromPartial(object.subscribeInfoRequest)
      : undefined;
    message.subscribeLastPriceRequest =
      (object.subscribeLastPriceRequest !== undefined && object.subscribeLastPriceRequest !== null)
        ? SubscribeLastPriceRequest.fromPartial(object.subscribeLastPriceRequest)
        : undefined;
    message.pingSettings = (object.pingSettings !== undefined && object.pingSettings !== null)
      ? PingDelaySettings.fromPartial(object.pingSettings)
      : undefined;
    return message;
  },
};

function createBaseMarketDataResponse(): MarketDataResponse {
  return {
    subscribeCandlesResponse: undefined,
    subscribeOrderBookResponse: undefined,
    subscribeTradesResponse: undefined,
    subscribeInfoResponse: undefined,
    candle: undefined,
    trade: undefined,
    orderbook: undefined,
    tradingStatus: undefined,
    ping: undefined,
    subscribeLastPriceResponse: undefined,
    lastPrice: undefined,
  };
}

export const MarketDataResponse: MessageFns<MarketDataResponse> = {
  encode(message: MarketDataResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subscribeCandlesResponse !== undefined) {
      SubscribeCandlesResponse.encode(message.subscribeCandlesResponse, writer.uint32(10).fork()).join();
    }
    if (message.subscribeOrderBookResponse !== undefined) {
      SubscribeOrderBookResponse.encode(message.subscribeOrderBookResponse, writer.uint32(18).fork()).join();
    }
    if (message.subscribeTradesResponse !== undefined) {
      SubscribeTradesResponse.encode(message.subscribeTradesResponse, writer.uint32(26).fork()).join();
    }
    if (message.subscribeInfoResponse !== undefined) {
      SubscribeInfoResponse.encode(message.subscribeInfoResponse, writer.uint32(34).fork()).join();
    }
    if (message.candle !== undefined) {
      Candle.encode(message.candle, writer.uint32(42).fork()).join();
    }
    if (message.trade !== undefined) {
      Trade.encode(message.trade, writer.uint32(50).fork()).join();
    }
    if (message.orderbook !== undefined) {
      OrderBook.encode(message.orderbook, writer.uint32(58).fork()).join();
    }
    if (message.tradingStatus !== undefined) {
      TradingStatus.encode(message.tradingStatus, writer.uint32(66).fork()).join();
    }
    if (message.ping !== undefined) {
      Ping.encode(message.ping, writer.uint32(74).fork()).join();
    }
    if (message.subscribeLastPriceResponse !== undefined) {
      SubscribeLastPriceResponse.encode(message.subscribeLastPriceResponse, writer.uint32(82).fork()).join();
    }
    if (message.lastPrice !== undefined) {
      LastPrice.encode(message.lastPrice, writer.uint32(90).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MarketDataResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarketDataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subscribeCandlesResponse = SubscribeCandlesResponse.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.subscribeOrderBookResponse = SubscribeOrderBookResponse.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.subscribeTradesResponse = SubscribeTradesResponse.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.subscribeInfoResponse = SubscribeInfoResponse.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.candle = Candle.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.trade = Trade.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.orderbook = OrderBook.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.tradingStatus = TradingStatus.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.ping = Ping.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.subscribeLastPriceResponse = SubscribeLastPriceResponse.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.lastPrice = LastPrice.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<MarketDataResponse>): MarketDataResponse {
    return MarketDataResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MarketDataResponse>): MarketDataResponse {
    const message = createBaseMarketDataResponse();
    message.subscribeCandlesResponse =
      (object.subscribeCandlesResponse !== undefined && object.subscribeCandlesResponse !== null)
        ? SubscribeCandlesResponse.fromPartial(object.subscribeCandlesResponse)
        : undefined;
    message.subscribeOrderBookResponse =
      (object.subscribeOrderBookResponse !== undefined && object.subscribeOrderBookResponse !== null)
        ? SubscribeOrderBookResponse.fromPartial(object.subscribeOrderBookResponse)
        : undefined;
    message.subscribeTradesResponse =
      (object.subscribeTradesResponse !== undefined && object.subscribeTradesResponse !== null)
        ? SubscribeTradesResponse.fromPartial(object.subscribeTradesResponse)
        : undefined;
    message.subscribeInfoResponse =
      (object.subscribeInfoResponse !== undefined && object.subscribeInfoResponse !== null)
        ? SubscribeInfoResponse.fromPartial(object.subscribeInfoResponse)
        : undefined;
    message.candle = (object.candle !== undefined && object.candle !== null)
      ? Candle.fromPartial(object.candle)
      : undefined;
    message.trade = (object.trade !== undefined && object.trade !== null) ? Trade.fromPartial(object.trade) : undefined;
    message.orderbook = (object.orderbook !== undefined && object.orderbook !== null)
      ? OrderBook.fromPartial(object.orderbook)
      : undefined;
    message.tradingStatus = (object.tradingStatus !== undefined && object.tradingStatus !== null)
      ? TradingStatus.fromPartial(object.tradingStatus)
      : undefined;
    message.ping = (object.ping !== undefined && object.ping !== null) ? Ping.fromPartial(object.ping) : undefined;
    message.subscribeLastPriceResponse =
      (object.subscribeLastPriceResponse !== undefined && object.subscribeLastPriceResponse !== null)
        ? SubscribeLastPriceResponse.fromPartial(object.subscribeLastPriceResponse)
        : undefined;
    message.lastPrice = (object.lastPrice !== undefined && object.lastPrice !== null)
      ? LastPrice.fromPartial(object.lastPrice)
      : undefined;
    return message;
  },
};

function createBaseSubscribeCandlesRequest(): SubscribeCandlesRequest {
  return { subscriptionAction: 0, instruments: [], waitingClose: false, candleSourceType: undefined };
}

export const SubscribeCandlesRequest: MessageFns<SubscribeCandlesRequest> = {
  encode(message: SubscribeCandlesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subscriptionAction !== 0) {
      writer.uint32(8).int32(message.subscriptionAction);
    }
    for (const v of message.instruments) {
      CandleInstrument.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.waitingClose !== false) {
      writer.uint32(24).bool(message.waitingClose);
    }
    if (message.candleSourceType !== undefined) {
      writer.uint32(72).int32(message.candleSourceType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscribeCandlesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeCandlesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.subscriptionAction = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.instruments.push(CandleInstrument.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.waitingClose = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.candleSourceType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SubscribeCandlesRequest>): SubscribeCandlesRequest {
    return SubscribeCandlesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubscribeCandlesRequest>): SubscribeCandlesRequest {
    const message = createBaseSubscribeCandlesRequest();
    message.subscriptionAction = object.subscriptionAction ?? 0;
    message.instruments = object.instruments?.map((e) => CandleInstrument.fromPartial(e)) || [];
    message.waitingClose = object.waitingClose ?? false;
    message.candleSourceType = object.candleSourceType ?? undefined;
    return message;
  },
};

function createBaseCandleInstrument(): CandleInstrument {
  return { figi: "", interval: 0, instrumentId: "" };
}

export const CandleInstrument: MessageFns<CandleInstrument> = {
  encode(message: CandleInstrument, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.figi !== "") {
      writer.uint32(10).string(message.figi);
    }
    if (message.interval !== 0) {
      writer.uint32(16).int32(message.interval);
    }
    if (message.instrumentId !== "") {
      writer.uint32(26).string(message.instrumentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CandleInstrument {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCandleInstrument();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.figi = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.interval = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.instrumentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<CandleInstrument>): CandleInstrument {
    return CandleInstrument.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CandleInstrument>): CandleInstrument {
    const message = createBaseCandleInstrument();
    message.figi = object.figi ?? "";
    message.interval = object.interval ?? 0;
    message.instrumentId = object.instrumentId ?? "";
    return message;
  },
};

function createBaseSubscribeCandlesResponse(): SubscribeCandlesResponse {
  return { trackingId: "", candlesSubscriptions: [] };
}

export const SubscribeCandlesResponse: MessageFns<SubscribeCandlesResponse> = {
  encode(message: SubscribeCandlesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trackingId !== "") {
      writer.uint32(10).string(message.trackingId);
    }
    for (const v of message.candlesSubscriptions) {
      CandleSubscription.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscribeCandlesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeCandlesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trackingId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.candlesSubscriptions.push(CandleSubscription.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SubscribeCandlesResponse>): SubscribeCandlesResponse {
    return SubscribeCandlesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubscribeCandlesResponse>): SubscribeCandlesResponse {
    const message = createBaseSubscribeCandlesResponse();
    message.trackingId = object.trackingId ?? "";
    message.candlesSubscriptions = object.candlesSubscriptions?.map((e) => CandleSubscription.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCandleSubscription(): CandleSubscription {
  return {
    figi: "",
    interval: 0,
    subscriptionStatus: 0,
    instrumentUid: "",
    waitingClose: false,
    streamId: "",
    subscriptionId: "",
    candleSourceType: undefined,
  };
}

export const CandleSubscription: MessageFns<CandleSubscription> = {
  encode(message: CandleSubscription, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.figi !== "") {
      writer.uint32(10).string(message.figi);
    }
    if (message.interval !== 0) {
      writer.uint32(16).int32(message.interval);
    }
    if (message.subscriptionStatus !== 0) {
      writer.uint32(24).int32(message.subscriptionStatus);
    }
    if (message.instrumentUid !== "") {
      writer.uint32(34).string(message.instrumentUid);
    }
    if (message.waitingClose !== false) {
      writer.uint32(40).bool(message.waitingClose);
    }
    if (message.streamId !== "") {
      writer.uint32(50).string(message.streamId);
    }
    if (message.subscriptionId !== "") {
      writer.uint32(58).string(message.subscriptionId);
    }
    if (message.candleSourceType !== undefined) {
      writer.uint32(72).int32(message.candleSourceType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CandleSubscription {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCandleSubscription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.figi = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.interval = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.subscriptionStatus = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.instrumentUid = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.waitingClose = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.streamId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.subscriptionId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.candleSourceType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<CandleSubscription>): CandleSubscription {
    return CandleSubscription.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CandleSubscription>): CandleSubscription {
    const message = createBaseCandleSubscription();
    message.figi = object.figi ?? "";
    message.interval = object.interval ?? 0;
    message.subscriptionStatus = object.subscriptionStatus ?? 0;
    message.instrumentUid = object.instrumentUid ?? "";
    message.waitingClose = object.waitingClose ?? false;
    message.streamId = object.streamId ?? "";
    message.subscriptionId = object.subscriptionId ?? "";
    message.candleSourceType = object.candleSourceType ?? undefined;
    return message;
  },
};

function createBaseSubscribeOrderBookRequest(): SubscribeOrderBookRequest {
  return { subscriptionAction: 0, instruments: [] };
}

export const SubscribeOrderBookRequest: MessageFns<SubscribeOrderBookRequest> = {
  encode(message: SubscribeOrderBookRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subscriptionAction !== 0) {
      writer.uint32(8).int32(message.subscriptionAction);
    }
    for (const v of message.instruments) {
      OrderBookInstrument.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscribeOrderBookRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeOrderBookRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.subscriptionAction = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.instruments.push(OrderBookInstrument.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SubscribeOrderBookRequest>): SubscribeOrderBookRequest {
    return SubscribeOrderBookRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubscribeOrderBookRequest>): SubscribeOrderBookRequest {
    const message = createBaseSubscribeOrderBookRequest();
    message.subscriptionAction = object.subscriptionAction ?? 0;
    message.instruments = object.instruments?.map((e) => OrderBookInstrument.fromPartial(e)) || [];
    return message;
  },
};

function createBaseOrderBookInstrument(): OrderBookInstrument {
  return { figi: "", depth: 0, instrumentId: "", orderBookType: 0 };
}

export const OrderBookInstrument: MessageFns<OrderBookInstrument> = {
  encode(message: OrderBookInstrument, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.figi !== "") {
      writer.uint32(10).string(message.figi);
    }
    if (message.depth !== 0) {
      writer.uint32(16).int32(message.depth);
    }
    if (message.instrumentId !== "") {
      writer.uint32(26).string(message.instrumentId);
    }
    if (message.orderBookType !== 0) {
      writer.uint32(32).int32(message.orderBookType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderBookInstrument {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderBookInstrument();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.figi = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.depth = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.instrumentId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.orderBookType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<OrderBookInstrument>): OrderBookInstrument {
    return OrderBookInstrument.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OrderBookInstrument>): OrderBookInstrument {
    const message = createBaseOrderBookInstrument();
    message.figi = object.figi ?? "";
    message.depth = object.depth ?? 0;
    message.instrumentId = object.instrumentId ?? "";
    message.orderBookType = object.orderBookType ?? 0;
    return message;
  },
};

function createBaseSubscribeOrderBookResponse(): SubscribeOrderBookResponse {
  return { trackingId: "", orderBookSubscriptions: [] };
}

export const SubscribeOrderBookResponse: MessageFns<SubscribeOrderBookResponse> = {
  encode(message: SubscribeOrderBookResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trackingId !== "") {
      writer.uint32(10).string(message.trackingId);
    }
    for (const v of message.orderBookSubscriptions) {
      OrderBookSubscription.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscribeOrderBookResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeOrderBookResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trackingId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.orderBookSubscriptions.push(OrderBookSubscription.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SubscribeOrderBookResponse>): SubscribeOrderBookResponse {
    return SubscribeOrderBookResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubscribeOrderBookResponse>): SubscribeOrderBookResponse {
    const message = createBaseSubscribeOrderBookResponse();
    message.trackingId = object.trackingId ?? "";
    message.orderBookSubscriptions = object.orderBookSubscriptions?.map((e) => OrderBookSubscription.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseOrderBookSubscription(): OrderBookSubscription {
  return {
    figi: "",
    depth: 0,
    subscriptionStatus: 0,
    instrumentUid: "",
    streamId: "",
    subscriptionId: "",
    orderBookType: 0,
  };
}

export const OrderBookSubscription: MessageFns<OrderBookSubscription> = {
  encode(message: OrderBookSubscription, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.figi !== "") {
      writer.uint32(10).string(message.figi);
    }
    if (message.depth !== 0) {
      writer.uint32(16).int32(message.depth);
    }
    if (message.subscriptionStatus !== 0) {
      writer.uint32(24).int32(message.subscriptionStatus);
    }
    if (message.instrumentUid !== "") {
      writer.uint32(34).string(message.instrumentUid);
    }
    if (message.streamId !== "") {
      writer.uint32(42).string(message.streamId);
    }
    if (message.subscriptionId !== "") {
      writer.uint32(50).string(message.subscriptionId);
    }
    if (message.orderBookType !== 0) {
      writer.uint32(56).int32(message.orderBookType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderBookSubscription {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderBookSubscription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.figi = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.depth = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.subscriptionStatus = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.instrumentUid = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.streamId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.subscriptionId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.orderBookType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<OrderBookSubscription>): OrderBookSubscription {
    return OrderBookSubscription.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OrderBookSubscription>): OrderBookSubscription {
    const message = createBaseOrderBookSubscription();
    message.figi = object.figi ?? "";
    message.depth = object.depth ?? 0;
    message.subscriptionStatus = object.subscriptionStatus ?? 0;
    message.instrumentUid = object.instrumentUid ?? "";
    message.streamId = object.streamId ?? "";
    message.subscriptionId = object.subscriptionId ?? "";
    message.orderBookType = object.orderBookType ?? 0;
    return message;
  },
};

function createBaseSubscribeTradesRequest(): SubscribeTradesRequest {
  return { subscriptionAction: 0, instruments: [], tradeSource: 0 };
}

export const SubscribeTradesRequest: MessageFns<SubscribeTradesRequest> = {
  encode(message: SubscribeTradesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subscriptionAction !== 0) {
      writer.uint32(8).int32(message.subscriptionAction);
    }
    for (const v of message.instruments) {
      TradeInstrument.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.tradeSource !== 0) {
      writer.uint32(24).int32(message.tradeSource);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscribeTradesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeTradesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.subscriptionAction = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.instruments.push(TradeInstrument.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.tradeSource = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SubscribeTradesRequest>): SubscribeTradesRequest {
    return SubscribeTradesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubscribeTradesRequest>): SubscribeTradesRequest {
    const message = createBaseSubscribeTradesRequest();
    message.subscriptionAction = object.subscriptionAction ?? 0;
    message.instruments = object.instruments?.map((e) => TradeInstrument.fromPartial(e)) || [];
    message.tradeSource = object.tradeSource ?? 0;
    return message;
  },
};

function createBaseTradeInstrument(): TradeInstrument {
  return { figi: "", instrumentId: "" };
}

export const TradeInstrument: MessageFns<TradeInstrument> = {
  encode(message: TradeInstrument, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.figi !== "") {
      writer.uint32(10).string(message.figi);
    }
    if (message.instrumentId !== "") {
      writer.uint32(18).string(message.instrumentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TradeInstrument {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTradeInstrument();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.figi = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.instrumentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<TradeInstrument>): TradeInstrument {
    return TradeInstrument.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TradeInstrument>): TradeInstrument {
    const message = createBaseTradeInstrument();
    message.figi = object.figi ?? "";
    message.instrumentId = object.instrumentId ?? "";
    return message;
  },
};

function createBaseSubscribeTradesResponse(): SubscribeTradesResponse {
  return { trackingId: "", tradeSubscriptions: [], tradeSource: 0 };
}

export const SubscribeTradesResponse: MessageFns<SubscribeTradesResponse> = {
  encode(message: SubscribeTradesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trackingId !== "") {
      writer.uint32(10).string(message.trackingId);
    }
    for (const v of message.tradeSubscriptions) {
      TradeSubscription.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.tradeSource !== 0) {
      writer.uint32(24).int32(message.tradeSource);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscribeTradesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeTradesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trackingId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tradeSubscriptions.push(TradeSubscription.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.tradeSource = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SubscribeTradesResponse>): SubscribeTradesResponse {
    return SubscribeTradesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubscribeTradesResponse>): SubscribeTradesResponse {
    const message = createBaseSubscribeTradesResponse();
    message.trackingId = object.trackingId ?? "";
    message.tradeSubscriptions = object.tradeSubscriptions?.map((e) => TradeSubscription.fromPartial(e)) || [];
    message.tradeSource = object.tradeSource ?? 0;
    return message;
  },
};

function createBaseTradeSubscription(): TradeSubscription {
  return { figi: "", subscriptionStatus: 0, instrumentUid: "", streamId: "", subscriptionId: "" };
}

export const TradeSubscription: MessageFns<TradeSubscription> = {
  encode(message: TradeSubscription, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.figi !== "") {
      writer.uint32(10).string(message.figi);
    }
    if (message.subscriptionStatus !== 0) {
      writer.uint32(16).int32(message.subscriptionStatus);
    }
    if (message.instrumentUid !== "") {
      writer.uint32(26).string(message.instrumentUid);
    }
    if (message.streamId !== "") {
      writer.uint32(34).string(message.streamId);
    }
    if (message.subscriptionId !== "") {
      writer.uint32(42).string(message.subscriptionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TradeSubscription {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTradeSubscription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.figi = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.subscriptionStatus = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.instrumentUid = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.streamId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.subscriptionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<TradeSubscription>): TradeSubscription {
    return TradeSubscription.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TradeSubscription>): TradeSubscription {
    const message = createBaseTradeSubscription();
    message.figi = object.figi ?? "";
    message.subscriptionStatus = object.subscriptionStatus ?? 0;
    message.instrumentUid = object.instrumentUid ?? "";
    message.streamId = object.streamId ?? "";
    message.subscriptionId = object.subscriptionId ?? "";
    return message;
  },
};

function createBaseSubscribeInfoRequest(): SubscribeInfoRequest {
  return { subscriptionAction: 0, instruments: [] };
}

export const SubscribeInfoRequest: MessageFns<SubscribeInfoRequest> = {
  encode(message: SubscribeInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subscriptionAction !== 0) {
      writer.uint32(8).int32(message.subscriptionAction);
    }
    for (const v of message.instruments) {
      InfoInstrument.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscribeInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.subscriptionAction = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.instruments.push(InfoInstrument.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SubscribeInfoRequest>): SubscribeInfoRequest {
    return SubscribeInfoRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubscribeInfoRequest>): SubscribeInfoRequest {
    const message = createBaseSubscribeInfoRequest();
    message.subscriptionAction = object.subscriptionAction ?? 0;
    message.instruments = object.instruments?.map((e) => InfoInstrument.fromPartial(e)) || [];
    return message;
  },
};

function createBaseInfoInstrument(): InfoInstrument {
  return { figi: "", instrumentId: "" };
}

export const InfoInstrument: MessageFns<InfoInstrument> = {
  encode(message: InfoInstrument, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.figi !== "") {
      writer.uint32(10).string(message.figi);
    }
    if (message.instrumentId !== "") {
      writer.uint32(18).string(message.instrumentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InfoInstrument {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInfoInstrument();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.figi = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.instrumentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<InfoInstrument>): InfoInstrument {
    return InfoInstrument.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InfoInstrument>): InfoInstrument {
    const message = createBaseInfoInstrument();
    message.figi = object.figi ?? "";
    message.instrumentId = object.instrumentId ?? "";
    return message;
  },
};

function createBaseSubscribeInfoResponse(): SubscribeInfoResponse {
  return { trackingId: "", infoSubscriptions: [] };
}

export const SubscribeInfoResponse: MessageFns<SubscribeInfoResponse> = {
  encode(message: SubscribeInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trackingId !== "") {
      writer.uint32(10).string(message.trackingId);
    }
    for (const v of message.infoSubscriptions) {
      InfoSubscription.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscribeInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trackingId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.infoSubscriptions.push(InfoSubscription.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SubscribeInfoResponse>): SubscribeInfoResponse {
    return SubscribeInfoResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubscribeInfoResponse>): SubscribeInfoResponse {
    const message = createBaseSubscribeInfoResponse();
    message.trackingId = object.trackingId ?? "";
    message.infoSubscriptions = object.infoSubscriptions?.map((e) => InfoSubscription.fromPartial(e)) || [];
    return message;
  },
};

function createBaseInfoSubscription(): InfoSubscription {
  return { figi: "", subscriptionStatus: 0, instrumentUid: "", streamId: "", subscriptionId: "" };
}

export const InfoSubscription: MessageFns<InfoSubscription> = {
  encode(message: InfoSubscription, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.figi !== "") {
      writer.uint32(10).string(message.figi);
    }
    if (message.subscriptionStatus !== 0) {
      writer.uint32(16).int32(message.subscriptionStatus);
    }
    if (message.instrumentUid !== "") {
      writer.uint32(26).string(message.instrumentUid);
    }
    if (message.streamId !== "") {
      writer.uint32(34).string(message.streamId);
    }
    if (message.subscriptionId !== "") {
      writer.uint32(42).string(message.subscriptionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InfoSubscription {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInfoSubscription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.figi = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.subscriptionStatus = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.instrumentUid = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.streamId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.subscriptionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<InfoSubscription>): InfoSubscription {
    return InfoSubscription.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InfoSubscription>): InfoSubscription {
    const message = createBaseInfoSubscription();
    message.figi = object.figi ?? "";
    message.subscriptionStatus = object.subscriptionStatus ?? 0;
    message.instrumentUid = object.instrumentUid ?? "";
    message.streamId = object.streamId ?? "";
    message.subscriptionId = object.subscriptionId ?? "";
    return message;
  },
};

function createBaseSubscribeLastPriceRequest(): SubscribeLastPriceRequest {
  return { subscriptionAction: 0, instruments: [] };
}

export const SubscribeLastPriceRequest: MessageFns<SubscribeLastPriceRequest> = {
  encode(message: SubscribeLastPriceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subscriptionAction !== 0) {
      writer.uint32(8).int32(message.subscriptionAction);
    }
    for (const v of message.instruments) {
      LastPriceInstrument.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscribeLastPriceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeLastPriceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.subscriptionAction = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.instruments.push(LastPriceInstrument.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SubscribeLastPriceRequest>): SubscribeLastPriceRequest {
    return SubscribeLastPriceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubscribeLastPriceRequest>): SubscribeLastPriceRequest {
    const message = createBaseSubscribeLastPriceRequest();
    message.subscriptionAction = object.subscriptionAction ?? 0;
    message.instruments = object.instruments?.map((e) => LastPriceInstrument.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLastPriceInstrument(): LastPriceInstrument {
  return { figi: "", instrumentId: "" };
}

export const LastPriceInstrument: MessageFns<LastPriceInstrument> = {
  encode(message: LastPriceInstrument, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.figi !== "") {
      writer.uint32(10).string(message.figi);
    }
    if (message.instrumentId !== "") {
      writer.uint32(18).string(message.instrumentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LastPriceInstrument {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLastPriceInstrument();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.figi = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.instrumentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<LastPriceInstrument>): LastPriceInstrument {
    return LastPriceInstrument.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LastPriceInstrument>): LastPriceInstrument {
    const message = createBaseLastPriceInstrument();
    message.figi = object.figi ?? "";
    message.instrumentId = object.instrumentId ?? "";
    return message;
  },
};

function createBaseSubscribeLastPriceResponse(): SubscribeLastPriceResponse {
  return { trackingId: "", lastPriceSubscriptions: [] };
}

export const SubscribeLastPriceResponse: MessageFns<SubscribeLastPriceResponse> = {
  encode(message: SubscribeLastPriceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trackingId !== "") {
      writer.uint32(10).string(message.trackingId);
    }
    for (const v of message.lastPriceSubscriptions) {
      LastPriceSubscription.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscribeLastPriceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribeLastPriceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trackingId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.lastPriceSubscriptions.push(LastPriceSubscription.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<SubscribeLastPriceResponse>): SubscribeLastPriceResponse {
    return SubscribeLastPriceResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubscribeLastPriceResponse>): SubscribeLastPriceResponse {
    const message = createBaseSubscribeLastPriceResponse();
    message.trackingId = object.trackingId ?? "";
    message.lastPriceSubscriptions = object.lastPriceSubscriptions?.map((e) => LastPriceSubscription.fromPartial(e)) ||
      [];
    return message;
  },
};

function createBaseLastPriceSubscription(): LastPriceSubscription {
  return { figi: "", subscriptionStatus: 0, instrumentUid: "", streamId: "", subscriptionId: "" };
}

export const LastPriceSubscription: MessageFns<LastPriceSubscription> = {
  encode(message: LastPriceSubscription, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.figi !== "") {
      writer.uint32(10).string(message.figi);
    }
    if (message.subscriptionStatus !== 0) {
      writer.uint32(16).int32(message.subscriptionStatus);
    }
    if (message.instrumentUid !== "") {
      writer.uint32(26).string(message.instrumentUid);
    }
    if (message.streamId !== "") {
      writer.uint32(34).string(message.streamId);
    }
    if (message.subscriptionId !== "") {
      writer.uint32(42).string(message.subscriptionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LastPriceSubscription {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLastPriceSubscription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.figi = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.subscriptionStatus = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.instrumentUid = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.streamId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.subscriptionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<LastPriceSubscription>): LastPriceSubscription {
    return LastPriceSubscription.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LastPriceSubscription>): LastPriceSubscription {
    const message = createBaseLastPriceSubscription();
    message.figi = object.figi ?? "";
    message.subscriptionStatus = object.subscriptionStatus ?? 0;
    message.instrumentUid = object.instrumentUid ?? "";
    message.streamId = object.streamId ?? "";
    message.subscriptionId = object.subscriptionId ?? "";
    return message;
  },
};

function createBaseCandle(): Candle {
  return {
    figi: "",
    interval: 0,
    open: undefined,
    high: undefined,
    low: undefined,
    close: undefined,
    volume: 0,
    time: undefined,
    lastTradeTs: undefined,
    instrumentUid: "",
    candleSourceType: 0,
  };
}

export const Candle: MessageFns<Candle> = {
  encode(message: Candle, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.figi !== "") {
      writer.uint32(10).string(message.figi);
    }
    if (message.interval !== 0) {
      writer.uint32(16).int32(message.interval);
    }
    if (message.open !== undefined) {
      Quotation.encode(message.open, writer.uint32(26).fork()).join();
    }
    if (message.high !== undefined) {
      Quotation.encode(message.high, writer.uint32(34).fork()).join();
    }
    if (message.low !== undefined) {
      Quotation.encode(message.low, writer.uint32(42).fork()).join();
    }
    if (message.close !== undefined) {
      Quotation.encode(message.close, writer.uint32(50).fork()).join();
    }
    if (message.volume !== 0) {
      writer.uint32(56).int64(message.volume);
    }
    if (message.time !== undefined) {
      Timestamp.encode(toTimestamp(message.time), writer.uint32(66).fork()).join();
    }
    if (message.lastTradeTs !== undefined) {
      Timestamp.encode(toTimestamp(message.lastTradeTs), writer.uint32(74).fork()).join();
    }
    if (message.instrumentUid !== "") {
      writer.uint32(82).string(message.instrumentUid);
    }
    if (message.candleSourceType !== 0) {
      writer.uint32(152).int32(message.candleSourceType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Candle {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCandle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.figi = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.interval = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.open = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.high = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.low = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.close = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.volume = longToNumber(reader.int64());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.lastTradeTs = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.instrumentUid = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.candleSourceType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Candle>): Candle {
    return Candle.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Candle>): Candle {
    const message = createBaseCandle();
    message.figi = object.figi ?? "";
    message.interval = object.interval ?? 0;
    message.open = (object.open !== undefined && object.open !== null) ? Quotation.fromPartial(object.open) : undefined;
    message.high = (object.high !== undefined && object.high !== null) ? Quotation.fromPartial(object.high) : undefined;
    message.low = (object.low !== undefined && object.low !== null) ? Quotation.fromPartial(object.low) : undefined;
    message.close = (object.close !== undefined && object.close !== null)
      ? Quotation.fromPartial(object.close)
      : undefined;
    message.volume = object.volume ?? 0;
    message.time = object.time ?? undefined;
    message.lastTradeTs = object.lastTradeTs ?? undefined;
    message.instrumentUid = object.instrumentUid ?? "";
    message.candleSourceType = object.candleSourceType ?? 0;
    return message;
  },
};

function createBaseOrderBook(): OrderBook {
  return {
    figi: "",
    depth: 0,
    isConsistent: false,
    bids: [],
    asks: [],
    time: undefined,
    limitUp: undefined,
    limitDown: undefined,
    instrumentUid: "",
    orderBookType: 0,
  };
}

export const OrderBook: MessageFns<OrderBook> = {
  encode(message: OrderBook, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.figi !== "") {
      writer.uint32(10).string(message.figi);
    }
    if (message.depth !== 0) {
      writer.uint32(16).int32(message.depth);
    }
    if (message.isConsistent !== false) {
      writer.uint32(24).bool(message.isConsistent);
    }
    for (const v of message.bids) {
      Order.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.asks) {
      Order.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.time !== undefined) {
      Timestamp.encode(toTimestamp(message.time), writer.uint32(50).fork()).join();
    }
    if (message.limitUp !== undefined) {
      Quotation.encode(message.limitUp, writer.uint32(58).fork()).join();
    }
    if (message.limitDown !== undefined) {
      Quotation.encode(message.limitDown, writer.uint32(66).fork()).join();
    }
    if (message.instrumentUid !== "") {
      writer.uint32(74).string(message.instrumentUid);
    }
    if (message.orderBookType !== 0) {
      writer.uint32(80).int32(message.orderBookType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderBook {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderBook();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.figi = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.depth = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isConsistent = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.bids.push(Order.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.asks.push(Order.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.limitUp = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.limitDown = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.instrumentUid = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.orderBookType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<OrderBook>): OrderBook {
    return OrderBook.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<OrderBook>): OrderBook {
    const message = createBaseOrderBook();
    message.figi = object.figi ?? "";
    message.depth = object.depth ?? 0;
    message.isConsistent = object.isConsistent ?? false;
    message.bids = object.bids?.map((e) => Order.fromPartial(e)) || [];
    message.asks = object.asks?.map((e) => Order.fromPartial(e)) || [];
    message.time = object.time ?? undefined;
    message.limitUp = (object.limitUp !== undefined && object.limitUp !== null)
      ? Quotation.fromPartial(object.limitUp)
      : undefined;
    message.limitDown = (object.limitDown !== undefined && object.limitDown !== null)
      ? Quotation.fromPartial(object.limitDown)
      : undefined;
    message.instrumentUid = object.instrumentUid ?? "";
    message.orderBookType = object.orderBookType ?? 0;
    return message;
  },
};

function createBaseOrder(): Order {
  return { price: undefined, quantity: 0 };
}

export const Order: MessageFns<Order> = {
  encode(message: Order, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.price !== undefined) {
      Quotation.encode(message.price, writer.uint32(10).fork()).join();
    }
    if (message.quantity !== 0) {
      writer.uint32(16).int64(message.quantity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Order {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.price = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.quantity = longToNumber(reader.int64());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Order>): Order {
    return Order.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Order>): Order {
    const message = createBaseOrder();
    message.price = (object.price !== undefined && object.price !== null)
      ? Quotation.fromPartial(object.price)
      : undefined;
    message.quantity = object.quantity ?? 0;
    return message;
  },
};

function createBaseTrade(): Trade {
  return { figi: "", direction: 0, price: undefined, quantity: 0, time: undefined, instrumentUid: "", tradeSource: 0 };
}

export const Trade: MessageFns<Trade> = {
  encode(message: Trade, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.figi !== "") {
      writer.uint32(10).string(message.figi);
    }
    if (message.direction !== 0) {
      writer.uint32(16).int32(message.direction);
    }
    if (message.price !== undefined) {
      Quotation.encode(message.price, writer.uint32(26).fork()).join();
    }
    if (message.quantity !== 0) {
      writer.uint32(32).int64(message.quantity);
    }
    if (message.time !== undefined) {
      Timestamp.encode(toTimestamp(message.time), writer.uint32(42).fork()).join();
    }
    if (message.instrumentUid !== "") {
      writer.uint32(50).string(message.instrumentUid);
    }
    if (message.tradeSource !== 0) {
      writer.uint32(56).int32(message.tradeSource);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Trade {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrade();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.figi = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.direction = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.price = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.quantity = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.instrumentUid = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.tradeSource = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<Trade>): Trade {
    return Trade.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Trade>): Trade {
    const message = createBaseTrade();
    message.figi = object.figi ?? "";
    message.direction = object.direction ?? 0;
    message.price = (object.price !== undefined && object.price !== null)
      ? Quotation.fromPartial(object.price)
      : undefined;
    message.quantity = object.quantity ?? 0;
    message.time = object.time ?? undefined;
    message.instrumentUid = object.instrumentUid ?? "";
    message.tradeSource = object.tradeSource ?? 0;
    return message;
  },
};

function createBaseTradingStatus(): TradingStatus {
  return {
    figi: "",
    tradingStatus: 0,
    time: undefined,
    limitOrderAvailableFlag: false,
    marketOrderAvailableFlag: false,
    instrumentUid: "",
  };
}

export const TradingStatus: MessageFns<TradingStatus> = {
  encode(message: TradingStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.figi !== "") {
      writer.uint32(10).string(message.figi);
    }
    if (message.tradingStatus !== 0) {
      writer.uint32(16).int32(message.tradingStatus);
    }
    if (message.time !== undefined) {
      Timestamp.encode(toTimestamp(message.time), writer.uint32(26).fork()).join();
    }
    if (message.limitOrderAvailableFlag !== false) {
      writer.uint32(32).bool(message.limitOrderAvailableFlag);
    }
    if (message.marketOrderAvailableFlag !== false) {
      writer.uint32(40).bool(message.marketOrderAvailableFlag);
    }
    if (message.instrumentUid !== "") {
      writer.uint32(50).string(message.instrumentUid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TradingStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTradingStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.figi = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.tradingStatus = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.limitOrderAvailableFlag = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.marketOrderAvailableFlag = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.instrumentUid = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<TradingStatus>): TradingStatus {
    return TradingStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TradingStatus>): TradingStatus {
    const message = createBaseTradingStatus();
    message.figi = object.figi ?? "";
    message.tradingStatus = object.tradingStatus ?? 0;
    message.time = object.time ?? undefined;
    message.limitOrderAvailableFlag = object.limitOrderAvailableFlag ?? false;
    message.marketOrderAvailableFlag = object.marketOrderAvailableFlag ?? false;
    message.instrumentUid = object.instrumentUid ?? "";
    return message;
  },
};

function createBaseGetCandlesRequest(): GetCandlesRequest {
  return {
    figi: undefined,
    from: undefined,
    to: undefined,
    interval: 0,
    instrumentId: undefined,
    candleSourceType: undefined,
    limit: undefined,
  };
}

export const GetCandlesRequest: MessageFns<GetCandlesRequest> = {
  encode(message: GetCandlesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.figi !== undefined) {
      writer.uint32(10).string(message.figi);
    }
    if (message.from !== undefined) {
      Timestamp.encode(toTimestamp(message.from), writer.uint32(18).fork()).join();
    }
    if (message.to !== undefined) {
      Timestamp.encode(toTimestamp(message.to), writer.uint32(26).fork()).join();
    }
    if (message.interval !== 0) {
      writer.uint32(32).int32(message.interval);
    }
    if (message.instrumentId !== undefined) {
      writer.uint32(42).string(message.instrumentId);
    }
    if (message.candleSourceType !== undefined) {
      writer.uint32(56).int32(message.candleSourceType);
    }
    if (message.limit !== undefined) {
      writer.uint32(80).int32(message.limit);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCandlesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCandlesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.figi = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.from = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.to = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.interval = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.instrumentId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.candleSourceType = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetCandlesRequest>): GetCandlesRequest {
    return GetCandlesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetCandlesRequest>): GetCandlesRequest {
    const message = createBaseGetCandlesRequest();
    message.figi = object.figi ?? undefined;
    message.from = object.from ?? undefined;
    message.to = object.to ?? undefined;
    message.interval = object.interval ?? 0;
    message.instrumentId = object.instrumentId ?? undefined;
    message.candleSourceType = object.candleSourceType ?? undefined;
    message.limit = object.limit ?? undefined;
    return message;
  },
};

function createBaseGetCandlesResponse(): GetCandlesResponse {
  return { candles: [] };
}

export const GetCandlesResponse: MessageFns<GetCandlesResponse> = {
  encode(message: GetCandlesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.candles) {
      HistoricCandle.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetCandlesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetCandlesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.candles.push(HistoricCandle.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetCandlesResponse>): GetCandlesResponse {
    return GetCandlesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetCandlesResponse>): GetCandlesResponse {
    const message = createBaseGetCandlesResponse();
    message.candles = object.candles?.map((e) => HistoricCandle.fromPartial(e)) || [];
    return message;
  },
};

function createBaseHistoricCandle(): HistoricCandle {
  return {
    open: undefined,
    high: undefined,
    low: undefined,
    close: undefined,
    volume: 0,
    time: undefined,
    isComplete: false,
    candleSourceType: 0,
  };
}

export const HistoricCandle: MessageFns<HistoricCandle> = {
  encode(message: HistoricCandle, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.open !== undefined) {
      Quotation.encode(message.open, writer.uint32(10).fork()).join();
    }
    if (message.high !== undefined) {
      Quotation.encode(message.high, writer.uint32(18).fork()).join();
    }
    if (message.low !== undefined) {
      Quotation.encode(message.low, writer.uint32(26).fork()).join();
    }
    if (message.close !== undefined) {
      Quotation.encode(message.close, writer.uint32(34).fork()).join();
    }
    if (message.volume !== 0) {
      writer.uint32(40).int64(message.volume);
    }
    if (message.time !== undefined) {
      Timestamp.encode(toTimestamp(message.time), writer.uint32(50).fork()).join();
    }
    if (message.isComplete !== false) {
      writer.uint32(56).bool(message.isComplete);
    }
    if (message.candleSourceType !== 0) {
      writer.uint32(72).int32(message.candleSourceType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HistoricCandle {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHistoricCandle();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.open = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.high = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.low = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.close = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.volume = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isComplete = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.candleSourceType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<HistoricCandle>): HistoricCandle {
    return HistoricCandle.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HistoricCandle>): HistoricCandle {
    const message = createBaseHistoricCandle();
    message.open = (object.open !== undefined && object.open !== null) ? Quotation.fromPartial(object.open) : undefined;
    message.high = (object.high !== undefined && object.high !== null) ? Quotation.fromPartial(object.high) : undefined;
    message.low = (object.low !== undefined && object.low !== null) ? Quotation.fromPartial(object.low) : undefined;
    message.close = (object.close !== undefined && object.close !== null)
      ? Quotation.fromPartial(object.close)
      : undefined;
    message.volume = object.volume ?? 0;
    message.time = object.time ?? undefined;
    message.isComplete = object.isComplete ?? false;
    message.candleSourceType = object.candleSourceType ?? 0;
    return message;
  },
};

function createBaseGetLastPricesRequest(): GetLastPricesRequest {
  return { figi: [], instrumentId: [], lastPriceType: 0, instrumentStatus: undefined };
}

export const GetLastPricesRequest: MessageFns<GetLastPricesRequest> = {
  encode(message: GetLastPricesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.figi) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.instrumentId) {
      writer.uint32(18).string(v!);
    }
    if (message.lastPriceType !== 0) {
      writer.uint32(24).int32(message.lastPriceType);
    }
    if (message.instrumentStatus !== undefined) {
      writer.uint32(72).int32(message.instrumentStatus);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLastPricesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLastPricesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.figi.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.instrumentId.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.lastPriceType = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.instrumentStatus = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetLastPricesRequest>): GetLastPricesRequest {
    return GetLastPricesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetLastPricesRequest>): GetLastPricesRequest {
    const message = createBaseGetLastPricesRequest();
    message.figi = object.figi?.map((e) => e) || [];
    message.instrumentId = object.instrumentId?.map((e) => e) || [];
    message.lastPriceType = object.lastPriceType ?? 0;
    message.instrumentStatus = object.instrumentStatus ?? undefined;
    return message;
  },
};

function createBaseGetLastPricesResponse(): GetLastPricesResponse {
  return { lastPrices: [] };
}

export const GetLastPricesResponse: MessageFns<GetLastPricesResponse> = {
  encode(message: GetLastPricesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.lastPrices) {
      LastPrice.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLastPricesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLastPricesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.lastPrices.push(LastPrice.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetLastPricesResponse>): GetLastPricesResponse {
    return GetLastPricesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetLastPricesResponse>): GetLastPricesResponse {
    const message = createBaseGetLastPricesResponse();
    message.lastPrices = object.lastPrices?.map((e) => LastPrice.fromPartial(e)) || [];
    return message;
  },
};

function createBaseLastPrice(): LastPrice {
  return { figi: "", price: undefined, time: undefined, instrumentUid: "", lastPriceType: 0 };
}

export const LastPrice: MessageFns<LastPrice> = {
  encode(message: LastPrice, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.figi !== "") {
      writer.uint32(10).string(message.figi);
    }
    if (message.price !== undefined) {
      Quotation.encode(message.price, writer.uint32(18).fork()).join();
    }
    if (message.time !== undefined) {
      Timestamp.encode(toTimestamp(message.time), writer.uint32(26).fork()).join();
    }
    if (message.instrumentUid !== "") {
      writer.uint32(90).string(message.instrumentUid);
    }
    if (message.lastPriceType !== 0) {
      writer.uint32(96).int32(message.lastPriceType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LastPrice {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLastPrice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.figi = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.price = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.instrumentUid = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.lastPriceType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<LastPrice>): LastPrice {
    return LastPrice.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LastPrice>): LastPrice {
    const message = createBaseLastPrice();
    message.figi = object.figi ?? "";
    message.price = (object.price !== undefined && object.price !== null)
      ? Quotation.fromPartial(object.price)
      : undefined;
    message.time = object.time ?? undefined;
    message.instrumentUid = object.instrumentUid ?? "";
    message.lastPriceType = object.lastPriceType ?? 0;
    return message;
  },
};

function createBaseGetOrderBookRequest(): GetOrderBookRequest {
  return { figi: undefined, depth: 0, instrumentId: undefined };
}

export const GetOrderBookRequest: MessageFns<GetOrderBookRequest> = {
  encode(message: GetOrderBookRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.figi !== undefined) {
      writer.uint32(10).string(message.figi);
    }
    if (message.depth !== 0) {
      writer.uint32(16).int32(message.depth);
    }
    if (message.instrumentId !== undefined) {
      writer.uint32(26).string(message.instrumentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOrderBookRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrderBookRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.figi = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.depth = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.instrumentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetOrderBookRequest>): GetOrderBookRequest {
    return GetOrderBookRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetOrderBookRequest>): GetOrderBookRequest {
    const message = createBaseGetOrderBookRequest();
    message.figi = object.figi ?? undefined;
    message.depth = object.depth ?? 0;
    message.instrumentId = object.instrumentId ?? undefined;
    return message;
  },
};

function createBaseGetOrderBookResponse(): GetOrderBookResponse {
  return {
    figi: "",
    depth: 0,
    bids: [],
    asks: [],
    lastPrice: undefined,
    closePrice: undefined,
    limitUp: undefined,
    limitDown: undefined,
    lastPriceTs: undefined,
    closePriceTs: undefined,
    orderbookTs: undefined,
    instrumentUid: "",
  };
}

export const GetOrderBookResponse: MessageFns<GetOrderBookResponse> = {
  encode(message: GetOrderBookResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.figi !== "") {
      writer.uint32(10).string(message.figi);
    }
    if (message.depth !== 0) {
      writer.uint32(16).int32(message.depth);
    }
    for (const v of message.bids) {
      Order.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.asks) {
      Order.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.lastPrice !== undefined) {
      Quotation.encode(message.lastPrice, writer.uint32(42).fork()).join();
    }
    if (message.closePrice !== undefined) {
      Quotation.encode(message.closePrice, writer.uint32(50).fork()).join();
    }
    if (message.limitUp !== undefined) {
      Quotation.encode(message.limitUp, writer.uint32(58).fork()).join();
    }
    if (message.limitDown !== undefined) {
      Quotation.encode(message.limitDown, writer.uint32(66).fork()).join();
    }
    if (message.lastPriceTs !== undefined) {
      Timestamp.encode(toTimestamp(message.lastPriceTs), writer.uint32(170).fork()).join();
    }
    if (message.closePriceTs !== undefined) {
      Timestamp.encode(toTimestamp(message.closePriceTs), writer.uint32(178).fork()).join();
    }
    if (message.orderbookTs !== undefined) {
      Timestamp.encode(toTimestamp(message.orderbookTs), writer.uint32(186).fork()).join();
    }
    if (message.instrumentUid !== "") {
      writer.uint32(74).string(message.instrumentUid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOrderBookResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrderBookResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.figi = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.depth = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bids.push(Order.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.asks.push(Order.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.lastPrice = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.closePrice = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.limitUp = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.limitDown = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.lastPriceTs = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.closePriceTs = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.orderbookTs = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.instrumentUid = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetOrderBookResponse>): GetOrderBookResponse {
    return GetOrderBookResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetOrderBookResponse>): GetOrderBookResponse {
    const message = createBaseGetOrderBookResponse();
    message.figi = object.figi ?? "";
    message.depth = object.depth ?? 0;
    message.bids = object.bids?.map((e) => Order.fromPartial(e)) || [];
    message.asks = object.asks?.map((e) => Order.fromPartial(e)) || [];
    message.lastPrice = (object.lastPrice !== undefined && object.lastPrice !== null)
      ? Quotation.fromPartial(object.lastPrice)
      : undefined;
    message.closePrice = (object.closePrice !== undefined && object.closePrice !== null)
      ? Quotation.fromPartial(object.closePrice)
      : undefined;
    message.limitUp = (object.limitUp !== undefined && object.limitUp !== null)
      ? Quotation.fromPartial(object.limitUp)
      : undefined;
    message.limitDown = (object.limitDown !== undefined && object.limitDown !== null)
      ? Quotation.fromPartial(object.limitDown)
      : undefined;
    message.lastPriceTs = object.lastPriceTs ?? undefined;
    message.closePriceTs = object.closePriceTs ?? undefined;
    message.orderbookTs = object.orderbookTs ?? undefined;
    message.instrumentUid = object.instrumentUid ?? "";
    return message;
  },
};

function createBaseGetTradingStatusRequest(): GetTradingStatusRequest {
  return { figi: undefined, instrumentId: undefined };
}

export const GetTradingStatusRequest: MessageFns<GetTradingStatusRequest> = {
  encode(message: GetTradingStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.figi !== undefined) {
      writer.uint32(10).string(message.figi);
    }
    if (message.instrumentId !== undefined) {
      writer.uint32(18).string(message.instrumentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTradingStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTradingStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.figi = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.instrumentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetTradingStatusRequest>): GetTradingStatusRequest {
    return GetTradingStatusRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTradingStatusRequest>): GetTradingStatusRequest {
    const message = createBaseGetTradingStatusRequest();
    message.figi = object.figi ?? undefined;
    message.instrumentId = object.instrumentId ?? undefined;
    return message;
  },
};

function createBaseGetTradingStatusesRequest(): GetTradingStatusesRequest {
  return { instrumentId: [] };
}

export const GetTradingStatusesRequest: MessageFns<GetTradingStatusesRequest> = {
  encode(message: GetTradingStatusesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.instrumentId) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTradingStatusesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTradingStatusesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.instrumentId.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetTradingStatusesRequest>): GetTradingStatusesRequest {
    return GetTradingStatusesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTradingStatusesRequest>): GetTradingStatusesRequest {
    const message = createBaseGetTradingStatusesRequest();
    message.instrumentId = object.instrumentId?.map((e) => e) || [];
    return message;
  },
};

function createBaseGetTradingStatusesResponse(): GetTradingStatusesResponse {
  return { tradingStatuses: [] };
}

export const GetTradingStatusesResponse: MessageFns<GetTradingStatusesResponse> = {
  encode(message: GetTradingStatusesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.tradingStatuses) {
      GetTradingStatusResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTradingStatusesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTradingStatusesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.tradingStatuses.push(GetTradingStatusResponse.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetTradingStatusesResponse>): GetTradingStatusesResponse {
    return GetTradingStatusesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTradingStatusesResponse>): GetTradingStatusesResponse {
    const message = createBaseGetTradingStatusesResponse();
    message.tradingStatuses = object.tradingStatuses?.map((e) => GetTradingStatusResponse.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetTradingStatusResponse(): GetTradingStatusResponse {
  return {
    figi: "",
    tradingStatus: 0,
    limitOrderAvailableFlag: false,
    marketOrderAvailableFlag: false,
    apiTradeAvailableFlag: false,
    instrumentUid: "",
    bestpriceOrderAvailableFlag: false,
    onlyBestPrice: false,
  };
}

export const GetTradingStatusResponse: MessageFns<GetTradingStatusResponse> = {
  encode(message: GetTradingStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.figi !== "") {
      writer.uint32(10).string(message.figi);
    }
    if (message.tradingStatus !== 0) {
      writer.uint32(16).int32(message.tradingStatus);
    }
    if (message.limitOrderAvailableFlag !== false) {
      writer.uint32(24).bool(message.limitOrderAvailableFlag);
    }
    if (message.marketOrderAvailableFlag !== false) {
      writer.uint32(32).bool(message.marketOrderAvailableFlag);
    }
    if (message.apiTradeAvailableFlag !== false) {
      writer.uint32(40).bool(message.apiTradeAvailableFlag);
    }
    if (message.instrumentUid !== "") {
      writer.uint32(50).string(message.instrumentUid);
    }
    if (message.bestpriceOrderAvailableFlag !== false) {
      writer.uint32(64).bool(message.bestpriceOrderAvailableFlag);
    }
    if (message.onlyBestPrice !== false) {
      writer.uint32(72).bool(message.onlyBestPrice);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTradingStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTradingStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.figi = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.tradingStatus = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limitOrderAvailableFlag = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.marketOrderAvailableFlag = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.apiTradeAvailableFlag = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.instrumentUid = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.bestpriceOrderAvailableFlag = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.onlyBestPrice = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetTradingStatusResponse>): GetTradingStatusResponse {
    return GetTradingStatusResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTradingStatusResponse>): GetTradingStatusResponse {
    const message = createBaseGetTradingStatusResponse();
    message.figi = object.figi ?? "";
    message.tradingStatus = object.tradingStatus ?? 0;
    message.limitOrderAvailableFlag = object.limitOrderAvailableFlag ?? false;
    message.marketOrderAvailableFlag = object.marketOrderAvailableFlag ?? false;
    message.apiTradeAvailableFlag = object.apiTradeAvailableFlag ?? false;
    message.instrumentUid = object.instrumentUid ?? "";
    message.bestpriceOrderAvailableFlag = object.bestpriceOrderAvailableFlag ?? false;
    message.onlyBestPrice = object.onlyBestPrice ?? false;
    return message;
  },
};

function createBaseGetLastTradesRequest(): GetLastTradesRequest {
  return { figi: undefined, from: undefined, to: undefined, instrumentId: undefined, tradeSource: 0 };
}

export const GetLastTradesRequest: MessageFns<GetLastTradesRequest> = {
  encode(message: GetLastTradesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.figi !== undefined) {
      writer.uint32(10).string(message.figi);
    }
    if (message.from !== undefined) {
      Timestamp.encode(toTimestamp(message.from), writer.uint32(18).fork()).join();
    }
    if (message.to !== undefined) {
      Timestamp.encode(toTimestamp(message.to), writer.uint32(26).fork()).join();
    }
    if (message.instrumentId !== undefined) {
      writer.uint32(34).string(message.instrumentId);
    }
    if (message.tradeSource !== 0) {
      writer.uint32(40).int32(message.tradeSource);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLastTradesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLastTradesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.figi = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.from = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.to = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.instrumentId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.tradeSource = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetLastTradesRequest>): GetLastTradesRequest {
    return GetLastTradesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetLastTradesRequest>): GetLastTradesRequest {
    const message = createBaseGetLastTradesRequest();
    message.figi = object.figi ?? undefined;
    message.from = object.from ?? undefined;
    message.to = object.to ?? undefined;
    message.instrumentId = object.instrumentId ?? undefined;
    message.tradeSource = object.tradeSource ?? 0;
    return message;
  },
};

function createBaseGetLastTradesResponse(): GetLastTradesResponse {
  return { trades: [] };
}

export const GetLastTradesResponse: MessageFns<GetLastTradesResponse> = {
  encode(message: GetLastTradesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.trades) {
      Trade.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLastTradesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLastTradesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trades.push(Trade.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetLastTradesResponse>): GetLastTradesResponse {
    return GetLastTradesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetLastTradesResponse>): GetLastTradesResponse {
    const message = createBaseGetLastTradesResponse();
    message.trades = object.trades?.map((e) => Trade.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetMySubscriptions(): GetMySubscriptions {
  return {};
}

export const GetMySubscriptions: MessageFns<GetMySubscriptions> = {
  encode(_: GetMySubscriptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMySubscriptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMySubscriptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetMySubscriptions>): GetMySubscriptions {
    return GetMySubscriptions.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<GetMySubscriptions>): GetMySubscriptions {
    const message = createBaseGetMySubscriptions();
    return message;
  },
};

function createBaseGetClosePricesRequest(): GetClosePricesRequest {
  return { instruments: [], instrumentStatus: undefined };
}

export const GetClosePricesRequest: MessageFns<GetClosePricesRequest> = {
  encode(message: GetClosePricesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.instruments) {
      InstrumentClosePriceRequest.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.instrumentStatus !== undefined) {
      writer.uint32(72).int32(message.instrumentStatus);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetClosePricesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetClosePricesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.instruments.push(InstrumentClosePriceRequest.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.instrumentStatus = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetClosePricesRequest>): GetClosePricesRequest {
    return GetClosePricesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetClosePricesRequest>): GetClosePricesRequest {
    const message = createBaseGetClosePricesRequest();
    message.instruments = object.instruments?.map((e) => InstrumentClosePriceRequest.fromPartial(e)) || [];
    message.instrumentStatus = object.instrumentStatus ?? undefined;
    return message;
  },
};

function createBaseInstrumentClosePriceRequest(): InstrumentClosePriceRequest {
  return { instrumentId: "" };
}

export const InstrumentClosePriceRequest: MessageFns<InstrumentClosePriceRequest> = {
  encode(message: InstrumentClosePriceRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.instrumentId !== "") {
      writer.uint32(10).string(message.instrumentId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InstrumentClosePriceRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstrumentClosePriceRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.instrumentId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<InstrumentClosePriceRequest>): InstrumentClosePriceRequest {
    return InstrumentClosePriceRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InstrumentClosePriceRequest>): InstrumentClosePriceRequest {
    const message = createBaseInstrumentClosePriceRequest();
    message.instrumentId = object.instrumentId ?? "";
    return message;
  },
};

function createBaseGetClosePricesResponse(): GetClosePricesResponse {
  return { closePrices: [] };
}

export const GetClosePricesResponse: MessageFns<GetClosePricesResponse> = {
  encode(message: GetClosePricesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.closePrices) {
      InstrumentClosePriceResponse.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetClosePricesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetClosePricesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.closePrices.push(InstrumentClosePriceResponse.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetClosePricesResponse>): GetClosePricesResponse {
    return GetClosePricesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetClosePricesResponse>): GetClosePricesResponse {
    const message = createBaseGetClosePricesResponse();
    message.closePrices = object.closePrices?.map((e) => InstrumentClosePriceResponse.fromPartial(e)) || [];
    return message;
  },
};

function createBaseInstrumentClosePriceResponse(): InstrumentClosePriceResponse {
  return { figi: "", instrumentUid: "", price: undefined, eveningSessionPrice: undefined, time: undefined };
}

export const InstrumentClosePriceResponse: MessageFns<InstrumentClosePriceResponse> = {
  encode(message: InstrumentClosePriceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.figi !== "") {
      writer.uint32(10).string(message.figi);
    }
    if (message.instrumentUid !== "") {
      writer.uint32(18).string(message.instrumentUid);
    }
    if (message.price !== undefined) {
      Quotation.encode(message.price, writer.uint32(90).fork()).join();
    }
    if (message.eveningSessionPrice !== undefined) {
      Quotation.encode(message.eveningSessionPrice, writer.uint32(98).fork()).join();
    }
    if (message.time !== undefined) {
      Timestamp.encode(toTimestamp(message.time), writer.uint32(170).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InstrumentClosePriceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInstrumentClosePriceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.figi = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.instrumentUid = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.price = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.eveningSessionPrice = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.time = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<InstrumentClosePriceResponse>): InstrumentClosePriceResponse {
    return InstrumentClosePriceResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<InstrumentClosePriceResponse>): InstrumentClosePriceResponse {
    const message = createBaseInstrumentClosePriceResponse();
    message.figi = object.figi ?? "";
    message.instrumentUid = object.instrumentUid ?? "";
    message.price = (object.price !== undefined && object.price !== null)
      ? Quotation.fromPartial(object.price)
      : undefined;
    message.eveningSessionPrice = (object.eveningSessionPrice !== undefined && object.eveningSessionPrice !== null)
      ? Quotation.fromPartial(object.eveningSessionPrice)
      : undefined;
    message.time = object.time ?? undefined;
    return message;
  },
};

function createBaseGetTechAnalysisRequest(): GetTechAnalysisRequest {
  return {
    indicatorType: 0,
    instrumentUid: "",
    from: undefined,
    to: undefined,
    interval: 0,
    typeOfPrice: 0,
    length: 0,
    deviation: undefined,
    smoothing: undefined,
  };
}

export const GetTechAnalysisRequest: MessageFns<GetTechAnalysisRequest> = {
  encode(message: GetTechAnalysisRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.indicatorType !== 0) {
      writer.uint32(8).int32(message.indicatorType);
    }
    if (message.instrumentUid !== "") {
      writer.uint32(18).string(message.instrumentUid);
    }
    if (message.from !== undefined) {
      Timestamp.encode(toTimestamp(message.from), writer.uint32(26).fork()).join();
    }
    if (message.to !== undefined) {
      Timestamp.encode(toTimestamp(message.to), writer.uint32(34).fork()).join();
    }
    if (message.interval !== 0) {
      writer.uint32(40).int32(message.interval);
    }
    if (message.typeOfPrice !== 0) {
      writer.uint32(48).int32(message.typeOfPrice);
    }
    if (message.length !== 0) {
      writer.uint32(56).int32(message.length);
    }
    if (message.deviation !== undefined) {
      GetTechAnalysisRequest_Deviation.encode(message.deviation, writer.uint32(66).fork()).join();
    }
    if (message.smoothing !== undefined) {
      GetTechAnalysisRequest_Smoothing.encode(message.smoothing, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTechAnalysisRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTechAnalysisRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.indicatorType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.instrumentUid = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.from = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.to = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.interval = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.typeOfPrice = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.length = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.deviation = GetTechAnalysisRequest_Deviation.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.smoothing = GetTechAnalysisRequest_Smoothing.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetTechAnalysisRequest>): GetTechAnalysisRequest {
    return GetTechAnalysisRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTechAnalysisRequest>): GetTechAnalysisRequest {
    const message = createBaseGetTechAnalysisRequest();
    message.indicatorType = object.indicatorType ?? 0;
    message.instrumentUid = object.instrumentUid ?? "";
    message.from = object.from ?? undefined;
    message.to = object.to ?? undefined;
    message.interval = object.interval ?? 0;
    message.typeOfPrice = object.typeOfPrice ?? 0;
    message.length = object.length ?? 0;
    message.deviation = (object.deviation !== undefined && object.deviation !== null)
      ? GetTechAnalysisRequest_Deviation.fromPartial(object.deviation)
      : undefined;
    message.smoothing = (object.smoothing !== undefined && object.smoothing !== null)
      ? GetTechAnalysisRequest_Smoothing.fromPartial(object.smoothing)
      : undefined;
    return message;
  },
};

function createBaseGetTechAnalysisRequest_Smoothing(): GetTechAnalysisRequest_Smoothing {
  return { fastLength: 0, slowLength: 0, signalSmoothing: 0 };
}

export const GetTechAnalysisRequest_Smoothing: MessageFns<GetTechAnalysisRequest_Smoothing> = {
  encode(message: GetTechAnalysisRequest_Smoothing, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fastLength !== 0) {
      writer.uint32(8).int32(message.fastLength);
    }
    if (message.slowLength !== 0) {
      writer.uint32(16).int32(message.slowLength);
    }
    if (message.signalSmoothing !== 0) {
      writer.uint32(24).int32(message.signalSmoothing);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTechAnalysisRequest_Smoothing {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTechAnalysisRequest_Smoothing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.fastLength = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.slowLength = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.signalSmoothing = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetTechAnalysisRequest_Smoothing>): GetTechAnalysisRequest_Smoothing {
    return GetTechAnalysisRequest_Smoothing.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTechAnalysisRequest_Smoothing>): GetTechAnalysisRequest_Smoothing {
    const message = createBaseGetTechAnalysisRequest_Smoothing();
    message.fastLength = object.fastLength ?? 0;
    message.slowLength = object.slowLength ?? 0;
    message.signalSmoothing = object.signalSmoothing ?? 0;
    return message;
  },
};

function createBaseGetTechAnalysisRequest_Deviation(): GetTechAnalysisRequest_Deviation {
  return { deviationMultiplier: undefined };
}

export const GetTechAnalysisRequest_Deviation: MessageFns<GetTechAnalysisRequest_Deviation> = {
  encode(message: GetTechAnalysisRequest_Deviation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deviationMultiplier !== undefined) {
      Quotation.encode(message.deviationMultiplier, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTechAnalysisRequest_Deviation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTechAnalysisRequest_Deviation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.deviationMultiplier = Quotation.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetTechAnalysisRequest_Deviation>): GetTechAnalysisRequest_Deviation {
    return GetTechAnalysisRequest_Deviation.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTechAnalysisRequest_Deviation>): GetTechAnalysisRequest_Deviation {
    const message = createBaseGetTechAnalysisRequest_Deviation();
    message.deviationMultiplier = (object.deviationMultiplier !== undefined && object.deviationMultiplier !== null)
      ? Quotation.fromPartial(object.deviationMultiplier)
      : undefined;
    return message;
  },
};

function createBaseGetTechAnalysisResponse(): GetTechAnalysisResponse {
  return { technicalIndicators: [] };
}

export const GetTechAnalysisResponse: MessageFns<GetTechAnalysisResponse> = {
  encode(message: GetTechAnalysisResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.technicalIndicators) {
      GetTechAnalysisResponse_TechAnalysisItem.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTechAnalysisResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTechAnalysisResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.technicalIndicators.push(GetTechAnalysisResponse_TechAnalysisItem.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetTechAnalysisResponse>): GetTechAnalysisResponse {
    return GetTechAnalysisResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTechAnalysisResponse>): GetTechAnalysisResponse {
    const message = createBaseGetTechAnalysisResponse();
    message.technicalIndicators =
      object.technicalIndicators?.map((e) => GetTechAnalysisResponse_TechAnalysisItem.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetTechAnalysisResponse_TechAnalysisItem(): GetTechAnalysisResponse_TechAnalysisItem {
  return {
    timestamp: undefined,
    middleBand: undefined,
    upperBand: undefined,
    lowerBand: undefined,
    signal: undefined,
    macd: undefined,
  };
}

export const GetTechAnalysisResponse_TechAnalysisItem: MessageFns<GetTechAnalysisResponse_TechAnalysisItem> = {
  encode(message: GetTechAnalysisResponse_TechAnalysisItem, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(10).fork()).join();
    }
    if (message.middleBand !== undefined) {
      Quotation.encode(message.middleBand, writer.uint32(18).fork()).join();
    }
    if (message.upperBand !== undefined) {
      Quotation.encode(message.upperBand, writer.uint32(26).fork()).join();
    }
    if (message.lowerBand !== undefined) {
      Quotation.encode(message.lowerBand, writer.uint32(34).fork()).join();
    }
    if (message.signal !== undefined) {
      Quotation.encode(message.signal, writer.uint32(42).fork()).join();
    }
    if (message.macd !== undefined) {
      Quotation.encode(message.macd, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetTechAnalysisResponse_TechAnalysisItem {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetTechAnalysisResponse_TechAnalysisItem();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.middleBand = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.upperBand = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.lowerBand = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.signal = Quotation.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.macd = Quotation.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  create(base?: DeepPartial<GetTechAnalysisResponse_TechAnalysisItem>): GetTechAnalysisResponse_TechAnalysisItem {
    return GetTechAnalysisResponse_TechAnalysisItem.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetTechAnalysisResponse_TechAnalysisItem>): GetTechAnalysisResponse_TechAnalysisItem {
    const message = createBaseGetTechAnalysisResponse_TechAnalysisItem();
    message.timestamp = object.timestamp ?? undefined;
    message.middleBand = (object.middleBand !== undefined && object.middleBand !== null)
      ? Quotation.fromPartial(object.middleBand)
      : undefined;
    message.upperBand = (object.upperBand !== undefined && object.upperBand !== null)
      ? Quotation.fromPartial(object.upperBand)
      : undefined;
    message.lowerBand = (object.lowerBand !== undefined && object.lowerBand !== null)
      ? Quotation.fromPartial(object.lowerBand)
      : undefined;
    message.signal = (object.signal !== undefined && object.signal !== null)
      ? Quotation.fromPartial(object.signal)
      : undefined;
    message.macd = (object.macd !== undefined && object.macd !== null) ? Quotation.fromPartial(object.macd) : undefined;
    return message;
  },
};

/** Сервис для получения биржевой информации:</br> 1. Свечи.</br> 2. Стаканы.</br> 3. Торговые статусы.</br> 4. Лента сделок. */
export type MarketDataServiceDefinition = typeof MarketDataServiceDefinition;
export const MarketDataServiceDefinition = {
  name: "MarketDataService",
  fullName: "tinkoff.public.invest.api.contract.v1.MarketDataService",
  methods: {
    /** Запросить исторические свечи по инструменту. */
    getCandles: {
      name: "GetCandles",
      requestType: GetCandlesRequest,
      requestStream: false,
      responseType: GetCandlesResponse,
      responseStream: false,
      options: {},
    },
    /** Запросить цены последних сделок по инструментам. */
    getLastPrices: {
      name: "GetLastPrices",
      requestType: GetLastPricesRequest,
      requestStream: false,
      responseType: GetLastPricesResponse,
      responseStream: false,
      options: {},
    },
    /** Получить стакан по инструменту. */
    getOrderBook: {
      name: "GetOrderBook",
      requestType: GetOrderBookRequest,
      requestStream: false,
      responseType: GetOrderBookResponse,
      responseStream: false,
      options: {},
    },
    /** Запросить статус торгов по инструментам. */
    getTradingStatus: {
      name: "GetTradingStatus",
      requestType: GetTradingStatusRequest,
      requestStream: false,
      responseType: GetTradingStatusResponse,
      responseStream: false,
      options: {},
    },
    /** Запросить статус торгов по инструментам. */
    getTradingStatuses: {
      name: "GetTradingStatuses",
      requestType: GetTradingStatusesRequest,
      requestStream: false,
      responseType: GetTradingStatusesResponse,
      responseStream: false,
      options: {},
    },
    /** Запросить обезличенные сделки за последний час. */
    getLastTrades: {
      name: "GetLastTrades",
      requestType: GetLastTradesRequest,
      requestStream: false,
      responseType: GetLastTradesResponse,
      responseStream: false,
      options: {},
    },
    /** Запросить цены закрытия торговой сессии по инструментам. */
    getClosePrices: {
      name: "GetClosePrices",
      requestType: GetClosePricesRequest,
      requestStream: false,
      responseType: GetClosePricesResponse,
      responseStream: false,
      options: {},
    },
    /** Получить технические индикаторы по инструменту. */
    getTechAnalysis: {
      name: "GetTechAnalysis",
      requestType: GetTechAnalysisRequest,
      requestStream: false,
      responseType: GetTechAnalysisResponse,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface MarketDataServiceImplementation<CallContextExt = {}> {
  /** Запросить исторические свечи по инструменту. */
  getCandles(
    request: GetCandlesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetCandlesResponse>>;
  /** Запросить цены последних сделок по инструментам. */
  getLastPrices(
    request: GetLastPricesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetLastPricesResponse>>;
  /** Получить стакан по инструменту. */
  getOrderBook(
    request: GetOrderBookRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetOrderBookResponse>>;
  /** Запросить статус торгов по инструментам. */
  getTradingStatus(
    request: GetTradingStatusRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetTradingStatusResponse>>;
  /** Запросить статус торгов по инструментам. */
  getTradingStatuses(
    request: GetTradingStatusesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetTradingStatusesResponse>>;
  /** Запросить обезличенные сделки за последний час. */
  getLastTrades(
    request: GetLastTradesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetLastTradesResponse>>;
  /** Запросить цены закрытия торговой сессии по инструментам. */
  getClosePrices(
    request: GetClosePricesRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetClosePricesResponse>>;
  /** Получить технические индикаторы по инструменту. */
  getTechAnalysis(
    request: GetTechAnalysisRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<GetTechAnalysisResponse>>;
}

export interface MarketDataServiceClient<CallOptionsExt = {}> {
  /** Запросить исторические свечи по инструменту. */
  getCandles(
    request: DeepPartial<GetCandlesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetCandlesResponse>;
  /** Запросить цены последних сделок по инструментам. */
  getLastPrices(
    request: DeepPartial<GetLastPricesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetLastPricesResponse>;
  /** Получить стакан по инструменту. */
  getOrderBook(
    request: DeepPartial<GetOrderBookRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetOrderBookResponse>;
  /** Запросить статус торгов по инструментам. */
  getTradingStatus(
    request: DeepPartial<GetTradingStatusRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetTradingStatusResponse>;
  /** Запросить статус торгов по инструментам. */
  getTradingStatuses(
    request: DeepPartial<GetTradingStatusesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetTradingStatusesResponse>;
  /** Запросить обезличенные сделки за последний час. */
  getLastTrades(
    request: DeepPartial<GetLastTradesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetLastTradesResponse>;
  /** Запросить цены закрытия торговой сессии по инструментам. */
  getClosePrices(
    request: DeepPartial<GetClosePricesRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetClosePricesResponse>;
  /** Получить технические индикаторы по инструменту. */
  getTechAnalysis(
    request: DeepPartial<GetTechAnalysisRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<GetTechAnalysisResponse>;
}

export type MarketDataStreamServiceDefinition = typeof MarketDataStreamServiceDefinition;
export const MarketDataStreamServiceDefinition = {
  name: "MarketDataStreamService",
  fullName: "tinkoff.public.invest.api.contract.v1.MarketDataStreamService",
  methods: {
    /** Bidirectional-стрим предоставления биржевой информации. */
    marketDataStream: {
      name: "MarketDataStream",
      requestType: MarketDataRequest,
      requestStream: true,
      responseType: MarketDataResponse,
      responseStream: true,
      options: {},
    },
    /** Server-side стрим предоставления биржевой информации. */
    marketDataServerSideStream: {
      name: "MarketDataServerSideStream",
      requestType: MarketDataServerSideStreamRequest,
      requestStream: false,
      responseType: MarketDataResponse,
      responseStream: true,
      options: {},
    },
  },
} as const;

export interface MarketDataStreamServiceImplementation<CallContextExt = {}> {
  /** Bidirectional-стрим предоставления биржевой информации. */
  marketDataStream(
    request: AsyncIterable<MarketDataRequest>,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<DeepPartial<MarketDataResponse>>;
  /** Server-side стрим предоставления биржевой информации. */
  marketDataServerSideStream(
    request: MarketDataServerSideStreamRequest,
    context: CallContext & CallContextExt,
  ): ServerStreamingMethodResult<DeepPartial<MarketDataResponse>>;
}

export interface MarketDataStreamServiceClient<CallOptionsExt = {}> {
  /** Bidirectional-стрим предоставления биржевой информации. */
  marketDataStream(
    request: AsyncIterable<DeepPartial<MarketDataRequest>>,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<MarketDataResponse>;
  /** Server-side стрим предоставления биржевой информации. */
  marketDataServerSideStream(
    request: DeepPartial<MarketDataServerSideStreamRequest>,
    options?: CallOptions & CallOptionsExt,
  ): AsyncIterable<MarketDataResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

type ServerStreamingMethodResult<Response> = { [Symbol.asyncIterator](): AsyncIterator<Response, void> };

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
